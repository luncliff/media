<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  
  <link rel="shortcut icon" href="../img/favicon.ico">
  <title>File media.cpp - luncliff-media</title>
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700|Roboto+Slab:400,700|Inconsolata:400,700' rel='stylesheet' type='text/css'>

  <link rel="stylesheet" href="../css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../css/theme_extra.css" type="text/css" />
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
  
  <script>
    // Current page data
    var mkdocs_page_name = "File media.cpp";
    var mkdocs_page_input_path = "media_8cpp_source.md";
    var mkdocs_page_url = "/media/media_8cpp_source/";
  </script>
  
  <script src="../js/jquery-2.1.1.min.js" defer></script>
  <script src="../js/modernizr-2.8.3.min.js" defer></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
  <script>hljs.initHighlightingOnLoad();</script> 
  
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
      <div class="wy-side-nav-search">
        <a href=".." class="icon icon-home"> luncliff-media</a>
        <div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
	<ul class="current">
	  
          
            <li class="toctree-l1">
		
    <a class="" href="../functions/">Functions</a>
	    </li>
          
        </ul>
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="..">luncliff-media</a>
      </nav>

      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="..">Docs</a> &raquo;</li>
    
      
    
    <li>File media.cpp</li>
    <li class="wy-breadcrumbs-aside">
      
        <a href="https://github.com/luncliff/media/edit/master/docs/media_8cpp_source.md"> Edit on luncliff/media</a>
      
    </li>
  </ul>
  <hr/>
</div>
          <div role="main">
            <div class="section">
              
                <h1 id="file-mediacpp">File media.cpp</h1>
<p><a href="../files/"><strong>File List</strong></a> <strong>&gt;</strong> <a href="../dir_68267d1309a1af8e8297ef4c3efbcdba/"><strong>src</strong></a> <strong>&gt;</strong> <a href="../media_8cpp/"><strong>media.cpp</strong></a></p>
<p><a href="../media_8cpp/">Go to the documentation of this file.</a> </p>
<pre><code class="cpp">#include &lt;winrt/Windows.Foundation.h&gt;
#include &lt;winrt/Windows.System.Threading.h&gt;

#include &lt;media.hpp&gt;
#include &lt;spdlog/spdlog.h&gt;

#include &lt;codecapi.h&gt; // for [codec]
#include &lt;dshowasf.h&gt;
#include &lt;mediaobj.h&gt; // for [dsp]

using namespace std;

struct critical_section_t final : public CRITICAL_SECTION {
  public:
    critical_section_t() noexcept : CRITICAL_SECTION{} {
        InitializeCriticalSection(this);
    }
    ~critical_section_t() noexcept {
        DeleteCriticalSection(this);
    }
    bool try_lock() noexcept {
        return TryEnterCriticalSection(this);
    }
    void lock() noexcept {
        return EnterCriticalSection(this);
    }
    void unlock() noexcept {
        return LeaveCriticalSection(this);
    }
};

auto media_startup() noexcept(false) -&gt; gsl::final_action&lt;HRESULT(WINAPI*)()&gt; {
    if (auto hr = MFStartup(MF_VERSION))
        throw winrt::hresult_error{hr};
    spdlog::info(&quot;media_foundation:&quot;);
    spdlog::info(&quot;- version: {:x}&quot;, MF_VERSION);
    return gsl::finally(&amp;MFShutdown);
}

HRESULT get_devices(std::vector&lt;com_ptr&lt;IMFActivate&gt;&gt;&amp; devices, IMFAttributes* attributes) noexcept {
    IMFActivate** handles = nullptr;
    UINT32 count = 0;
    if (auto hr = MFEnumDeviceSources(attributes, &amp;handles, &amp;count); FAILED(hr))
        return hr;
    auto on_return = gsl::finally([handles]() {
        CoTaskMemFree(handles); // must be deallocated
    });
    for (auto i = 0u; i &lt; count; ++i) {
        com_ptr&lt;IMFActivate&gt; activate{};
        activate.attach(handles[i]);
        devices.emplace_back(move(activate));
    }
    return S_OK;
}

HRESULT get_string(gsl::not_null&lt;IMFAttributes*&gt; attribute, const GUID&amp; uuid, winrt::hstring&amp; name) noexcept {
    constexpr UINT32 max_size = 240;
    WCHAR buf[max_size]{};
    UINT32 buflen{};
    HRESULT hr = attribute-&gt;GetString(uuid, buf, max_size, &amp;buflen);
    if (SUCCEEDED(hr))
        name = {buf, buflen};
    return hr;
}

HRESULT get_name(gsl::not_null&lt;IMFActivate*&gt; device, winrt::hstring&amp; name) noexcept {
    return get_string(device, MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME, name);
}

HRESULT get_name(gsl::not_null&lt;IMFActivate*&gt; device, std::string&amp; ref) noexcept {
    winrt::hstring name{};
    auto hr = get_name(device, name);
    if SUCCEEDED (hr)
        ref = winrt::to_string(name);
    return hr;
}

HRESULT get_name(gsl::not_null&lt;IMFActivate*&gt; device, std::wstring&amp; ref) noexcept {
    winrt::hstring name{};
    auto hr = get_name(device, name);
    if SUCCEEDED (hr)
        ref = name.c_str();
    return hr;
}

HRESULT get_hardware_url(gsl::not_null&lt;IMFTransform*&gt; transform, winrt::hstring&amp; name) noexcept {
    com_ptr&lt;IMFAttributes&gt; attrs{};
    if (auto hr = transform-&gt;GetAttributes(attrs.put()))
        return hr;
    constexpr UINT32 max_size = 240;
    WCHAR buf[max_size]{};
    UINT32 buflen{};
    HRESULT hr = attrs-&gt;GetString(MFT_ENUM_HARDWARE_URL_Attribute, buf, max_size, &amp;buflen);
    if (SUCCEEDED(hr))
        name = {buf, buflen};
    return hr;
}

HRESULT resolve(const fs::path&amp; fpath, IMFMediaSourceEx** source, MF_OBJECT_TYPE&amp; media_object_type) noexcept {
    com_ptr&lt;IMFSourceResolver&gt; resolver{};
    if (auto hr = MFCreateSourceResolver(resolver.put()))
        return hr;
    com_ptr&lt;IUnknown&gt; unknown{};
    if (auto hr = resolver-&gt;CreateObjectFromURL(fpath.c_str(), MF_RESOLUTION_MEDIASOURCE | MF_RESOLUTION_READ, NULL,
                                                &amp;media_object_type, unknown.put()))
        return hr;
    return unknown-&gt;QueryInterface(source);
}

HRESULT make_transform_H264(IMFTransform** transform) noexcept {
    com_ptr&lt;IUnknown&gt; unknown{};
    if (auto hr = CoCreateInstance(CLSID_CMSH264DecoderMFT, NULL, CLSCTX_INPROC_SERVER, //
                                   IID_PPV_ARGS(unknown.put())))
        return hr;
    return unknown-&gt;QueryInterface(transform);
}

HRESULT make_transform_video(IMFTransform** transform, const IID&amp; iid) noexcept {
    com_ptr&lt;IUnknown&gt; unknown{};
    if (auto hr = CoCreateInstance(iid, NULL, CLSCTX_INPROC_SERVER, //
                                   IID_PPV_ARGS(unknown.put())))
        return hr;
    return unknown-&gt;QueryInterface(transform);
}

HRESULT make_transform_video(IMFTransform** transform) noexcept {
    return make_transform_video(transform, CLSID_VideoProcessorMFT);
}

HRESULT configure_D3D11_DXGI(gsl::not_null&lt;IMFTransform*&gt; transform, IMFDXGIDeviceManager* device_manager) noexcept {
    com_ptr&lt;IMFAttributes&gt; attrs{};
    if (auto hr = transform-&gt;GetAttributes(attrs.put())) // return can be E_NOTIMPL
        return hr;
    UINT32 supported{};
    if (auto hr = attrs-&gt;GetUINT32(MF_SA_D3D11_AWARE, &amp;supported); FAILED(hr))
        return hr;
    if (supported == false)
        return E_FAIL;
    return transform-&gt;ProcessMessage(MFT_MESSAGE_SET_D3D_MANAGER, //
                                     reinterpret_cast&lt;ULONG_PTR&gt;(static_cast&lt;IUnknown*&gt;(device_manager)));
}

// @see https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder#transform-attributes
HRESULT configure_acceleration_H264(gsl::not_null&lt;IMFTransform*&gt; transform) noexcept {
    com_ptr&lt;IMFAttributes&gt; attrs{};
    if (auto hr = transform-&gt;GetAttributes(attrs.put()))
        return hr;
    if (auto hr = attrs-&gt;SetUINT32(CODECAPI_AVDecVideoAcceleration_H264, TRUE); FAILED(hr))
        spdlog::error(&quot;CODECAPI_AVDecVideoAcceleration_H264: {:#08x}&quot;, hr);
    if (auto hr = attrs-&gt;SetUINT32(CODECAPI_AVLowLatencyMode, TRUE); FAILED(hr))
        spdlog::error(&quot;CODECAPI_AVLowLatencyMode: {:#08x}&quot;, hr);
    if (auto hr = attrs-&gt;SetUINT32(CODECAPI_AVDecNumWorkerThreads, 1); FAILED(hr))
        spdlog::error(&quot;CODECAPI_AVDecNumWorkerThreads: {:#08x}&quot;, hr);
    return S_OK;
}

HRESULT configure_video_output_RGB565(IMFMediaType* type) noexcept {
    if (type == nullptr)
        return E_INVALIDARG;
    if (auto hr = type-&gt;SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video))
        return hr;
    if (auto hr = type-&gt;SetUINT32(MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE))
        return hr;
    return type-&gt;SetGUID(MF_MT_SUBTYPE, MFVideoFormat_RGB565);
}

HRESULT make_video_output_RGB565(IMFMediaType** ptr) noexcept {
    if (ptr == nullptr)
        return E_INVALIDARG;
    *ptr = nullptr;
    com_ptr&lt;IMFMediaType&gt; output_type{};
    if (auto hr = MFCreateMediaType(output_type.put()))
        return hr;
    if (auto hr = configure_video_output_RGB565(output_type.get()))
        return hr;
    output_type-&gt;AddRef();
    *ptr = output_type.get();
    return S_OK;
}

HRESULT configure_video_output_RGB32(IMFMediaType* type) noexcept {
    if (type == nullptr)
        return E_INVALIDARG;
    if (auto hr = type-&gt;SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video))
        return hr;
    if (auto hr = type-&gt;SetUINT32(MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE))
        return hr;
    if (auto hr = type-&gt;SetUINT32(MF_MT_INTERLACE_MODE, MFVideoInterlace_Unknown))
        return hr;
    //if (auto hr = MFSetAttributeRatio(output_type.get(), MF_MT_PIXEL_ASPECT_RATIO, 16, 9))
    //    return hr;
    return type-&gt;SetGUID(MF_MT_SUBTYPE, MFVideoFormat_RGB32);
}

HRESULT make_video_output_RGB32(IMFMediaType** ptr) noexcept {
    if (ptr == nullptr)
        return E_INVALIDARG;
    *ptr = nullptr;
    com_ptr&lt;IMFMediaType&gt; output_type{};
    if (auto hr = MFCreateMediaType(output_type.put()))
        return hr;
    if (auto hr = configure_video_output_RGB32(output_type.get()))
        return hr;
    output_type-&gt;AddRef();
    *ptr = output_type.get();
    return S_OK;
}

HRESULT try_output_type(com_ptr&lt;IMFTransform&gt; transform, DWORD ostream, const GUID&amp; desired,
                        IMFMediaType** output_type) noexcept {
    DWORD type_index = 0;
    for (com_ptr&lt;IMFMediaType&gt; candidate : try_output_available_types(transform, ostream, type_index)) {
        GUID subtype{};
        if (auto hr = candidate-&gt;GetGUID(MF_MT_SUBTYPE, &amp;subtype))
            return hr;
        if (subtype != desired)
            continue;
        if (auto hr = transform-&gt;SetOutputType(ostream, candidate.get(), 0))
            return hr;
        break;
    }
    if (type_index == 0)
        return E_FAIL;
    return transform-&gt;GetOutputCurrentType(ostream, output_type);
}

auto get_input_available_types(com_ptr&lt;IMFTransform&gt; transform, DWORD num_input, HRESULT&amp; ec) noexcept(false)
    -&gt; generator&lt;com_ptr&lt;IMFMediaType&gt;&gt; {
    for (auto stream_id = 0u; stream_id &lt; num_input; ++stream_id) {
        DWORD type_index = 0;
        com_ptr&lt;IMFMediaType&gt; media_type{};
        for (ec = transform-&gt;GetInputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(ec);
             ec = transform-&gt;GetInputAvailableType(stream_id, type_index++, media_type.put())) {
            co_yield media_type;
            media_type = nullptr;
        }
    }
}
auto try_output_available_types(com_ptr&lt;IMFTransform&gt; transform, DWORD stream_id, DWORD&amp; type_index) noexcept(false)
    -&gt; generator&lt;com_ptr&lt;IMFMediaType&gt;&gt; {
    type_index = 0;
    com_ptr&lt;IMFMediaType&gt; media_type{};
    for (auto hr = transform-&gt;GetOutputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(hr);
         hr = transform-&gt;GetOutputAvailableType(stream_id, type_index++, media_type.put())) {
        co_yield media_type;
        media_type = nullptr;
    }
}

auto get_output_available_types(com_ptr&lt;IMFTransform&gt; transform, DWORD num_output, HRESULT&amp; ec) noexcept(false)
    -&gt; generator&lt;com_ptr&lt;IMFMediaType&gt;&gt; {
    for (auto stream_id = 0u; stream_id &lt; num_output; ++stream_id) {
        DWORD type_index = 0;
        com_ptr&lt;IMFMediaType&gt; media_type{};
        for (ec = transform-&gt;GetOutputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(ec);
             ec = transform-&gt;GetOutputAvailableType(stream_id, type_index++, media_type.put())) {
            co_yield media_type;
            media_type = nullptr;
        }
    }
}
auto try_input_available_types(com_ptr&lt;IMFTransform&gt; transform, DWORD stream_id, DWORD&amp; type_index) noexcept(false)
    -&gt; generator&lt;com_ptr&lt;IMFMediaType&gt;&gt; {
    type_index = 0;
    com_ptr&lt;IMFMediaType&gt; media_type{};
    for (auto hr = transform-&gt;GetInputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(hr);
         hr = transform-&gt;GetInputAvailableType(stream_id, type_index++, media_type.put())) {
        co_yield media_type;
        media_type = nullptr;
    }
}

HRESULT configure_rectangle(gsl::not_null&lt;IMFVideoProcessorControl*&gt; control,
                            gsl::not_null&lt;IMFMediaType*&gt; media_type) noexcept {
    UINT32 w = 0, h = 0;
    if (auto hr = MFGetAttributeSize(media_type, MF_MT_FRAME_SIZE, &amp;w, &amp;h); FAILED(hr))
        return hr;
    RECT rect{};
    rect.right = w; // LTRB rectangle
    rect.bottom = h;
    if (auto hr = control-&gt;SetSourceRectangle(&amp;rect); FAILED(hr))
        return hr;
    return control-&gt;SetDestinationRectangle(&amp;rect);
}

HRESULT configure_source_rectangle(gsl::not_null&lt;IPropertyStore*&gt; props, const RECT&amp; rect) noexcept {
    PROPVARIANT val{};
    val.intVal = rect.left;
    if (auto hr = props-&gt;SetValue(MFPKEY_RESIZE_SRC_LEFT, val))
        return hr;
    val.intVal = rect.top;
    if (auto hr = props-&gt;SetValue(MFPKEY_RESIZE_SRC_TOP, val))
        return hr;
    val.intVal = rect.right - rect.left;
    if (auto hr = props-&gt;SetValue(MFPKEY_RESIZE_SRC_WIDTH, val))
        return hr;
    val.intVal = rect.bottom - rect.top;
    return props-&gt;SetValue(MFPKEY_RESIZE_SRC_HEIGHT, val);
}

HRESULT configure_destination_rectangle(gsl::not_null&lt;IPropertyStore*&gt; props, const RECT&amp; rect) noexcept {
    PROPVARIANT val{};
    val.intVal = rect.left;
    if (auto hr = props-&gt;SetValue(MFPKEY_RESIZE_DST_LEFT, val))
        return hr;
    val.intVal = rect.top;
    if (auto hr = props-&gt;SetValue(MFPKEY_RESIZE_DST_TOP, val))
        return hr;
    val.intVal = rect.right - rect.left;
    if (auto hr = props-&gt;SetValue(MFPKEY_RESIZE_DST_WIDTH, val))
        return hr;
    val.intVal = rect.bottom - rect.top;
    return props-&gt;SetValue(MFPKEY_RESIZE_DST_HEIGHT, val);
}

HRESULT get_stream_descriptor(IMFPresentationDescriptor* presentation, IMFStreamDescriptor** ptr) {
    DWORD num_stream = 0;
    if (auto hr = presentation-&gt;GetStreamDescriptorCount(&amp;num_stream); SUCCEEDED(hr) == false)
        return hr;
    for (auto i = 0u; i &lt; num_stream; ++i) {
        BOOL selected = false;
        if (auto hr = presentation-&gt;GetStreamDescriptorByIndex(i, &amp;selected, ptr); FAILED(hr))
            return hr;
        if (selected)
            break;
    }
    return S_OK;
}

HRESULT configure_video(com_ptr&lt;IMFMediaType&gt; type) {
    GUID subtype{};
    type-&gt;GetGUID(MF_MT_SUBTYPE, &amp;subtype);

    UINT32 interlace = 0;
    type-&gt;GetUINT32(MF_MT_INTERLACE_MODE, &amp;interlace);
    const auto imode = static_cast&lt;MFVideoInterlaceMode&gt;(interlace);

    UINT32 stride = 0;
    type-&gt;GetUINT32(MF_MT_DEFAULT_STRIDE, &amp;stride);

    UINT32 ycbcr2rgb = 0;
    type-&gt;GetUINT32(MF_MT_YUV_MATRIX, &amp;ycbcr2rgb);
    const auto matrix = static_cast&lt;MFVideoTransferMatrix&gt;(ycbcr2rgb);

    UINT64 size = 0;
    type-&gt;GetUINT64(MF_MT_FRAME_SIZE, &amp;size); // MFGetAttributeSize
    UINT32 w = size &gt;&gt; 32, h = size &amp; UINT32_MAX;

    UINT64 framerate = 0; // framerate &gt;&gt; 32;
    type-&gt;GetUINT64(MF_MT_FRAME_RATE_RANGE_MAX, &amp;framerate);
    return type-&gt;SetUINT64(MF_MT_FRAME_RATE, framerate);
}

HRESULT configure(com_ptr&lt;IMFStreamDescriptor&gt; stream) noexcept {
    com_ptr&lt;IMFMediaTypeHandler&gt; handler{};
    if (auto hr = stream-&gt;GetMediaTypeHandler(handler.put()); SUCCEEDED(hr) == false)
        return hr;
    DWORD num_types = 0;
    if (auto hr = handler-&gt;GetMediaTypeCount(&amp;num_types); SUCCEEDED(hr) == false)
        return hr;
    com_ptr&lt;IMFMediaType&gt; type{};
    for (auto i = 0u; i &lt; num_types; ++i) {
        com_ptr&lt;IMFMediaType&gt; current{};
        if (auto hr = handler-&gt;GetMediaTypeByIndex(i, current.put()); FAILED(hr))
            return hr;
        if (type == nullptr)
            type = current;

        print(current.get());
    }
    return handler-&gt;SetCurrentMediaType(type.get());
}

auto read_samples(com_ptr&lt;IMFSourceReader&gt; source_reader, //
                  DWORD&amp; index, DWORD&amp; flags, LONGLONG&amp; timestamp, LONGLONG&amp; duration) noexcept(false)
    -&gt; generator&lt;com_ptr&lt;IMFSample&gt;&gt; {
    const auto stream = static_cast&lt;DWORD&gt;(MF_SOURCE_READER_FIRST_VIDEO_STREAM);
    while (true) {
        com_ptr&lt;IMFSample&gt; input_sample{};
        if (auto hr = source_reader-&gt;ReadSample(stream, 0, &amp;index, &amp;flags, &amp;timestamp, input_sample.put()))
            throw winrt::hresult_error{hr};

        if (flags &amp; MF_SOURCE_READERF_ENDOFSTREAM)
            co_return;
        if (flags &amp; MF_SOURCE_READERF_STREAMTICK)
            spdlog::debug(&quot;MF_SOURCE_READERF_STREAMTICK&quot;);
        if (input_sample == nullptr) // probably MF_SOURCE_READERF_STREAMTICK
            continue;
        co_yield input_sample;
    }
};

auto decode(com_ptr&lt;IMFTransform&gt; transform, DWORD ostream, com_ptr&lt;IMFMediaType&gt; output_type, HRESULT&amp; ec) noexcept
    -&gt; generator&lt;com_ptr&lt;IMFSample&gt;&gt; {
    MFT_OUTPUT_STREAM_INFO output_stream_info{};
    if (ec = transform-&gt;GetOutputStreamInfo(ostream, &amp;output_stream_info); FAILED(ec))
        co_return;

    while (true) {
        MFT_OUTPUT_DATA_BUFFER output_buffer{};
        com_ptr&lt;IMFSample&gt; output_sample{};
        if (output_stream_info.dwFlags &amp; MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) {
            // ...
        } else {
            if (ec = create_single_buffer_sample(output_stream_info.cbSize, output_sample.put()); FAILED(ec))
                co_return;
            output_buffer.pSample = output_sample.get();
        }

        DWORD status = 0; // MFT_OUTPUT_STATUS_SAMPLE_READY
        ec = transform-&gt;ProcessOutput(0, 1, &amp;output_buffer, &amp;status);
        if (ec == MF_E_TRANSFORM_NEED_MORE_INPUT)
            break;
        if (ec == MF_E_TRANSFORM_STREAM_CHANGE) {
            if (output_buffer.dwStatus != MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE) {
                // todo: add more works for this case
                co_return;
            }
            // the type is changed. update after reset
            output_type = nullptr;
            if (ec = transform-&gt;GetOutputAvailableType(output_buffer.dwStreamID, 0, output_type.put()); FAILED(ec))
                co_return;
            // specify the format we want ...
            GUID output_subtype{};
            if (ec = output_type-&gt;GetGUID(MF_MT_SUBTYPE, &amp;output_subtype); FAILED(ec))
                co_return;
            if (ec = transform-&gt;SetOutputType(ostream, output_type.get(), 0); FAILED(ec))
                co_return;
            continue;
        }
        if (ec != S_OK)
            co_return;

        if (output_stream_info.dwFlags &amp; MFT_OUTPUT_STREAM_PROVIDES_SAMPLES)
            output_sample.attach(output_buffer.pSample);
        co_yield output_sample;
    }
}

auto process(com_ptr&lt;IMFTransform&gt; transform, DWORD istream, DWORD ostream, //
             com_ptr&lt;IMFSample&gt; input_sample, com_ptr&lt;IMFMediaType&gt; output_type, HRESULT&amp; ec) noexcept
    -&gt; generator&lt;com_ptr&lt;IMFSample&gt;&gt; {
    DWORD index{};
    DWORD flags{};
    LONGLONG timestamp{}; // unit 100-nanosecond
    LONGLONG duration{};
    if (ec = input_sample-&gt;SetSampleTime(timestamp); FAILED(ec))
        co_return;

    switch (ec = transform-&gt;ProcessInput(istream, input_sample.get(), 0)) {
    case S_OK: // MF_E_TRANSFORM_TYPE_NOT_SET, MF_E_NO_SAMPLE_DURATION, MF_E_NO_SAMPLE_TIMESTAMP
        break;
    case MF_E_UNSUPPORTED_D3D_TYPE:
    case MF_E_NOTACCEPTING:
    default:
        // error
        co_return;
    }
    // fetch output if available
    for (com_ptr&lt;IMFSample&gt; output_sample : decode(transform, ostream, output_type, ec))
        co_yield output_sample;
}

auto process(com_ptr&lt;IMFTransform&gt; transform, DWORD istream, DWORD ostream, com_ptr&lt;IMFSourceReader&gt; source_reader,
             HRESULT&amp; ec) -&gt; generator&lt;com_ptr&lt;IMFSample&gt;&gt; {
    com_ptr&lt;IMFMediaType&gt; output_type{};
    if (ec = transform-&gt;GetOutputCurrentType(ostream, output_type.put()); FAILED(ec))
        co_return;
    if (ec = transform-&gt;ProcessMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, NULL); FAILED(ec))
        co_return;
    if (ec = transform-&gt;ProcessMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, NULL); FAILED(ec))
        co_return;

    DWORD index{};
    DWORD flags{};
    LONGLONG timestamp{}; // unit 100-nanosecond
    LONGLONG duration{};
    for (com_ptr&lt;IMFSample&gt; input_sample : read_samples(source_reader, //
                                                        index, flags, timestamp, duration)) {
        input_sample-&gt;SetSampleTime(timestamp);
        for (com_ptr&lt;IMFSample&gt; output_sample : process(transform, istream, ostream, input_sample, output_type, ec))
            co_yield output_sample;
        if (ec)
            co_return;
    }
    if (ec = transform-&gt;ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, NULL); FAILED(ec))
        co_return;
    if (ec = transform-&gt;ProcessMessage(MFT_MESSAGE_COMMAND_DRAIN, NULL); FAILED(ec))
        co_return;

    for (com_ptr&lt;IMFSample&gt; output_sample : decode(transform, ostream, output_type, ec))
        co_yield output_sample;
}

HRESULT create_single_buffer_sample(DWORD bufsz, IMFSample** sample) {
    if (auto hr = MFCreateSample(sample))
        return hr;
    com_ptr&lt;IMFMediaBuffer&gt; buffer{};
    if (auto hr = MFCreateMemoryBuffer(bufsz, buffer.put()))
        return hr;
    return (*sample)-&gt;AddBuffer(buffer.get());
}

HRESULT create_and_copy_single_buffer_sample(IMFSample* src, IMFSample** dst) {
    DWORD total{};
    if (auto hr = src-&gt;GetTotalLength(&amp;total))
        return hr;
    if (auto hr = create_single_buffer_sample(total, dst))
        return hr;
    if (auto hr = src-&gt;CopyAllItems(*dst))
        return hr;
    com_ptr&lt;IMFMediaBuffer&gt; buffer{};
    if (auto hr = (*dst)-&gt;GetBufferByIndex(0, buffer.put()))
        return hr;
    return src-&gt;CopyToBuffer(buffer.get());
}

HRESULT get_transform_output(IMFTransform* transform, IMFSample** sample, BOOL&amp; flushed) {
    MFT_OUTPUT_STREAM_INFO stream_info{};
    if (auto hr = transform-&gt;GetOutputStreamInfo(0, &amp;stream_info))
        return hr;

    flushed = FALSE;
    *sample = nullptr;

    MFT_OUTPUT_DATA_BUFFER output{};
    if ((stream_info.dwFlags &amp; MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) == 0) {
        if (auto hr = create_single_buffer_sample(stream_info.cbSize, sample))
            return hr;
        output.pSample = *sample;
    }

    DWORD status = 0;
    HRESULT const result = transform-&gt;ProcessOutput(0, 1, &amp;output, &amp;status);
    if (result == S_OK) {
        *sample = output.pSample;
        return S_OK;
    }

    // see https://docs.microsoft.com/en-us/windows/win32/medfound/handling-stream-changes
    if (result == MF_E_TRANSFORM_STREAM_CHANGE) {
        com_ptr&lt;IMFMediaType&gt; changed_output_type{};
        if (output.dwStatus != MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE) {
            // todo: add more works for this case
            return E_NOTIMPL;
        }

        if (auto hr = transform-&gt;GetOutputAvailableType(0, 0, changed_output_type.put()))
            return hr;

        // check new output media type

        if (auto hr = changed_output_type-&gt;SetGUID(MF_MT_SUBTYPE, MFVideoFormat_IYUV))
            return hr;
        if (auto hr = transform-&gt;SetOutputType(0, changed_output_type.get(), 0))
            return hr;

        if (auto hr = transform-&gt;ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL))
            return hr;
        flushed = TRUE;

        return S_OK;
    }
    // MF_E_TRANSFORM_NEED_MORE_INPUT: not an error condition but it means the allocated output sample is empty.
    return result;
}
</code></pre>
              
            </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
    
  </div>

  Built with <a href="http://www.mkdocs.org">MkDocs</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
      
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" style="cursor: pointer">
    <span class="rst-current-version" data-toggle="rst-current-version">
      
      
      
    </span>
</div>
    <script>var base_url = '..';</script>
    <script src="../js/theme.js" defer></script>
      <script src="../search/main.js" defer></script>

</body>
</html>
