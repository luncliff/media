{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../readme.md","title":"Home"},{"location":"annotated/","text":"Class List Here are the classes, structs, unions and interfaces with brief descriptions: struct critical_section_t class qpc_timer_t namespace std","title":"Class List"},{"location":"annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: struct critical_section_t class qpc_timer_t namespace std","title":"Class List"},{"location":"class_member_enums/","text":"Class Member Enums","title":"Class Member Enums"},{"location":"class_member_enums/#class-member-enums","text":"","title":"Class Member Enums"},{"location":"class_member_functions/","text":"Class Member Functions c critical_section_t ( critical_section_t ) l lock ( critical_section_t ) p pick ( qpc_timer_t ) q qpc_timer_t ( qpc_timer_t ) r reset ( qpc_timer_t ) t try_lock ( critical_section_t ) u unlock ( critical_section_t ) ~ ~critical_section_t ( critical_section_t )","title":"Class Member Functions"},{"location":"class_member_functions/#class-member-functions","text":"","title":"Class Member Functions"},{"location":"class_member_functions/#c","text":"critical_section_t ( critical_section_t )","title":"c"},{"location":"class_member_functions/#l","text":"lock ( critical_section_t )","title":"l"},{"location":"class_member_functions/#p","text":"pick ( qpc_timer_t )","title":"p"},{"location":"class_member_functions/#q","text":"qpc_timer_t ( qpc_timer_t )","title":"q"},{"location":"class_member_functions/#r","text":"reset ( qpc_timer_t )","title":"r"},{"location":"class_member_functions/#t","text":"try_lock ( critical_section_t )","title":"t"},{"location":"class_member_functions/#u","text":"unlock ( critical_section_t )","title":"u"},{"location":"class_member_functions/#_1","text":"~critical_section_t ( critical_section_t )","title":"~"},{"location":"class_member_typedefs/","text":"Class Member Typedefs","title":"Class Member Typedefs"},{"location":"class_member_typedefs/#class-member-typedefs","text":"","title":"Class Member Typedefs"},{"location":"class_member_variables/","text":"Class Member Variables f frequency ( qpc_timer_t ) s start ( qpc_timer_t )","title":"Class Member Variables"},{"location":"class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"class_member_variables/#f","text":"frequency ( qpc_timer_t )","title":"f"},{"location":"class_member_variables/#s","text":"start ( qpc_timer_t )","title":"s"},{"location":"class_members/","text":"Class Members c critical_section_t ( critical_section_t ) f frequency ( qpc_timer_t ) l lock ( critical_section_t ) p pick ( qpc_timer_t ) q qpc_timer_t ( qpc_timer_t ) r reset ( qpc_timer_t ) s start ( qpc_timer_t ) t try_lock ( critical_section_t ) u unlock ( critical_section_t ) ~ ~critical_section_t ( critical_section_t )","title":"Class Members"},{"location":"class_members/#class-members","text":"","title":"Class Members"},{"location":"class_members/#c","text":"critical_section_t ( critical_section_t )","title":"c"},{"location":"class_members/#f","text":"frequency ( qpc_timer_t )","title":"f"},{"location":"class_members/#l","text":"lock ( critical_section_t )","title":"l"},{"location":"class_members/#p","text":"pick ( qpc_timer_t )","title":"p"},{"location":"class_members/#q","text":"qpc_timer_t ( qpc_timer_t )","title":"q"},{"location":"class_members/#r","text":"reset ( qpc_timer_t )","title":"r"},{"location":"class_members/#s","text":"start ( qpc_timer_t )","title":"s"},{"location":"class_members/#t","text":"try_lock ( critical_section_t )","title":"t"},{"location":"class_members/#u","text":"unlock ( critical_section_t )","title":"u"},{"location":"class_members/#_1","text":"~critical_section_t ( critical_section_t )","title":"~"},{"location":"classes/","text":"Class Index c critical_section_t q qpc_timer_t","title":"Class Index"},{"location":"classes/#class-index","text":"","title":"Class Index"},{"location":"classes/#c","text":"critical_section_t","title":"c"},{"location":"classes/#q","text":"qpc_timer_t","title":"q"},{"location":"classqpc__timer__t/","text":"Class qpc_timer_t Class List > qpc_timer_t More... #include <media.hpp> Public Functions Type Name auto pick () noexcept const qpc_timer_t () noexcept auto reset () noexcept Detailed Description Todo use static_assert for Windows SDK Public Functions Documentation function pick inline auto qpc_timer_t::pick () noexcept const Returns: elapsed time in millisecond unit function qpc_timer_t inline qpc_timer_t::qpc_timer_t () noexcept function reset inline auto qpc_timer_t::reset () noexcept The documentation for this class was generated from the following file src/media.hpp","title":"Class qpc\\_timer\\_t"},{"location":"classqpc__timer__t/#class-qpc_timer_t","text":"Class List > qpc_timer_t More... #include <media.hpp>","title":"Class qpc_timer_t"},{"location":"classqpc__timer__t/#public-functions","text":"Type Name auto pick () noexcept const qpc_timer_t () noexcept auto reset () noexcept","title":"Public Functions"},{"location":"classqpc__timer__t/#detailed-description","text":"Todo use static_assert for Windows SDK","title":"Detailed Description"},{"location":"classqpc__timer__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classqpc__timer__t/#function-pick","text":"inline auto qpc_timer_t::pick () noexcept const Returns: elapsed time in millisecond unit","title":"function pick"},{"location":"classqpc__timer__t/#function-qpc_timer_t","text":"inline qpc_timer_t::qpc_timer_t () noexcept","title":"function qpc_timer_t"},{"location":"classqpc__timer__t/#function-reset","text":"inline auto qpc_timer_t::reset () noexcept The documentation for this class was generated from the following file src/media.hpp","title":"function reset"},{"location":"dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"Dir src File List > src Files Type Name file media.cpp file media.hpp file media_print.cpp The documentation for this class was generated from the following file src/","title":"Dir src"},{"location":"dir_68267d1309a1af8e8297ef4c3efbcdba/#dir-src","text":"File List > src","title":"Dir src"},{"location":"dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Type Name file media.cpp file media.hpp file media_print.cpp The documentation for this class was generated from the following file src/","title":"Files"},{"location":"files/","text":"File List Here is a list of all files with brief descriptions: dir src file media.cpp file media.hpp file media_print.cpp","title":"File List"},{"location":"files/#file-list","text":"Here is a list of all files with brief descriptions: dir src file media.cpp file media.hpp file media_print.cpp","title":"File List"},{"location":"functions/","text":"Functions c configure ( media.cpp , media.hpp ) configure_D3D11_DXGI ( media.cpp , media.hpp ) configure_acceleration_H264 ( media.cpp , media.hpp ) configure_destination_rectangle ( media.cpp , media.hpp ) configure_rectangle ( media.cpp , media.hpp ) configure_source_rectangle ( media.cpp , media.hpp ) configure_video ( media.cpp ) configure_video_output_RGB32 ( media.cpp ) configure_video_output_RGB565 ( media.cpp ) create_and_copy_single_buffer_sample ( media.cpp , media.hpp ) create_single_buffer_sample ( media.cpp , media.hpp ) d decode ( media.cpp , media.hpp ) g get_devices ( media.cpp , media.hpp ) get_hardware_url ( media.cpp , media.hpp ) get_input_available_types ( media.cpp , media.hpp ) get_name ( media.cpp , media.hpp ) get_output_available_types ( media.cpp , media.hpp ) get_stream_descriptor ( media.cpp , media.hpp ) get_string ( media.cpp , media.hpp ) get_transform_output ( media.cpp , media.hpp ) m make_transform_H264 ( media.cpp , media.hpp ) make_transform_video ( media.cpp , media.hpp ) make_video_output_RGB32 ( media.cpp , media.hpp ) make_video_output_RGB565 ( media.cpp , media.hpp ) media_startup ( media.cpp , media.hpp ) mb2w ( media_print.cpp ) p process ( media.cpp , media.hpp ) print ( media.hpp , media_print.cpp ) print_CLSID_CColorConvertDMO ( media_print.cpp ) print_CLSID_CResizerDMO ( media_print.cpp ) r read_samples ( media.cpp , media.hpp ) resolve ( media.cpp , media.hpp ) t try_input_available_types ( media.cpp , media.hpp ) try_output_available_types ( media.cpp , media.hpp ) try_output_type ( media.cpp , media.hpp ) to_hstring ( media.hpp , media_print.cpp ) to_readable ( media.hpp , media_print.cpp ) to_string ( media.hpp , media_print.cpp ) w w2mb ( media_print.cpp )","title":"Functions"},{"location":"functions/#functions","text":"","title":"Functions"},{"location":"functions/#c","text":"configure ( media.cpp , media.hpp ) configure_D3D11_DXGI ( media.cpp , media.hpp ) configure_acceleration_H264 ( media.cpp , media.hpp ) configure_destination_rectangle ( media.cpp , media.hpp ) configure_rectangle ( media.cpp , media.hpp ) configure_source_rectangle ( media.cpp , media.hpp ) configure_video ( media.cpp ) configure_video_output_RGB32 ( media.cpp ) configure_video_output_RGB565 ( media.cpp ) create_and_copy_single_buffer_sample ( media.cpp , media.hpp ) create_single_buffer_sample ( media.cpp , media.hpp )","title":"c"},{"location":"functions/#d","text":"decode ( media.cpp , media.hpp )","title":"d"},{"location":"functions/#g","text":"get_devices ( media.cpp , media.hpp ) get_hardware_url ( media.cpp , media.hpp ) get_input_available_types ( media.cpp , media.hpp ) get_name ( media.cpp , media.hpp ) get_output_available_types ( media.cpp , media.hpp ) get_stream_descriptor ( media.cpp , media.hpp ) get_string ( media.cpp , media.hpp ) get_transform_output ( media.cpp , media.hpp )","title":"g"},{"location":"functions/#m","text":"make_transform_H264 ( media.cpp , media.hpp ) make_transform_video ( media.cpp , media.hpp ) make_video_output_RGB32 ( media.cpp , media.hpp ) make_video_output_RGB565 ( media.cpp , media.hpp ) media_startup ( media.cpp , media.hpp ) mb2w ( media_print.cpp )","title":"m"},{"location":"functions/#p","text":"process ( media.cpp , media.hpp ) print ( media.hpp , media_print.cpp ) print_CLSID_CColorConvertDMO ( media_print.cpp ) print_CLSID_CResizerDMO ( media_print.cpp )","title":"p"},{"location":"functions/#r","text":"read_samples ( media.cpp , media.hpp ) resolve ( media.cpp , media.hpp )","title":"r"},{"location":"functions/#t","text":"try_input_available_types ( media.cpp , media.hpp ) try_output_available_types ( media.cpp , media.hpp ) try_output_type ( media.cpp , media.hpp ) to_hstring ( media.hpp , media_print.cpp ) to_readable ( media.hpp , media_print.cpp ) to_string ( media.hpp , media_print.cpp )","title":"t"},{"location":"functions/#w","text":"w2mb ( media_print.cpp )","title":"w"},{"location":"hierarchy/","text":"Class Hierarchy This inheritance list is sorted roughly, but not completely, alphabetically: class qpc_timer_t class CRITICAL_SECTION struct critical_section_t","title":"Class Hierarchy"},{"location":"hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: class qpc_timer_t class CRITICAL_SECTION struct critical_section_t","title":"Class Hierarchy"},{"location":"macros/","text":"Macros i IF_EQUAL_RETURN ( media_print.cpp ) s SPDLOG_FMT_EXTERNAL ( media_print.cpp )","title":"Macros"},{"location":"macros/#macros","text":"","title":"Macros"},{"location":"macros/#i","text":"IF_EQUAL_RETURN ( media_print.cpp )","title":"i"},{"location":"macros/#s","text":"SPDLOG_FMT_EXTERNAL ( media_print.cpp )","title":"s"},{"location":"media_8cpp/","text":"File media.cpp File List > src > media.cpp Go to the source code of this file. #include <winrt/Windows.Foundation.h> #include <winrt/Windows.System.Threading.h> #include <media.hpp> #include <spdlog/spdlog.h> #include <codecapi.h> #include <dshowasf.h> #include <mediaobj.h> Namespaces Type Name namespace std Classes Type Name struct critical_section_t Public Functions Type Name HRESULT configure (com_ptr< IMFStreamDescriptor > stream) noexcept HRESULT configure_D3D11_DXGI (gsl::not_null< IMFTransform *> transform, IMFDXGIDeviceManager * device_manager) noexcept configure D3D11 if the transform supports it HRESULT configure_acceleration_H264 (gsl::not_null< IMFTransform *> transform) noexcept HRESULT configure_destination_rectangle (gsl::not_null< IPropertyStore *> props, const RECT & rect) noexcept HRESULT configure_rectangle (gsl::not_null< IMFVideoProcessorControl *> control, gsl::not_null< IMFMediaType *> media_type) noexcept exactly same sized src/dst rectangle; HRESULT configure_source_rectangle (gsl::not_null< IPropertyStore *> props, const RECT & rect) noexcept HRESULT configure_video (com_ptr< IMFMediaType > type) HRESULT configure_video_output_RGB32 (IMFMediaType * type) noexcept HRESULT configure_video_output_RGB565 (IMFMediaType * type) noexcept HRESULT create_and_copy_single_buffer_sample (IMFSample * src, IMFSample ** dst) HRESULT create_single_buffer_sample (DWORD bufsz, IMFSample ** sample) auto decode (com_ptr< IMFTransform > transform, DWORD ostream, com_ptr< IMFMediaType > output_type, HRESULT & ec) noexcept HRESULT get_devices (std::vector< com_ptr< IMFActivate >> & devices, IMFAttributes * attributes) noexcept HRESULT get_hardware_url (gsl::not_null< IMFTransform *> transform, winrt::hstring & name) noexcept auto get_input_available_types (com_ptr< IMFTransform > transform, DWORD num_input, HRESULT & ec) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, winrt::hstring & name) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, std::string & ref) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, std::wstring & ref) noexcept auto get_output_available_types (com_ptr< IMFTransform > transform, DWORD num_output, HRESULT & ec) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) HRESULT get_string (gsl::not_null< IMFAttributes *> attribute, const GUID & uuid, winrt::hstring & name) noexcept HRESULT get_transform_output (IMFTransform * transform, IMFSample ** sample, BOOL & flushed) HRESULT make_transform_H264 (IMFTransform ** transform) noexcept HRESULT make_transform_video (IMFTransform ** transform, const IID & iid) noexcept HRESULT make_transform_video (IMFTransform ** transform) noexcept HRESULT make_video_output_RGB32 (IMFMediaType ** ptr) noexcept HRESULT make_video_output_RGB565 (IMFMediaType ** ptr) noexcept auto media_startup () noexcept auto process (com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSample > input_sample, com_ptr< IMFMediaType > output_type, HRESULT & ec) noexcept auto process (com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSourceReader > source_reader, HRESULT & ec) auto read_samples (com_ptr< IMFSourceReader > source_reader, DWORD & index, DWORD & flags, LONGLONG & timestamp, LONGLONG & duration) noexcept HRESULT resolve (const fs::path & fpath, IMFMediaSourceEx ** source, MF_OBJECT_TYPE & media_object_type) noexcept auto try_input_available_types (com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index) noexcept auto try_output_available_types (com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index) noexcept HRESULT try_output_type (com_ptr< IMFTransform > transform, DWORD ostream, const GUID & desired, IMFMediaType ** output_type) noexcept Public Functions Documentation function configure HRESULT configure ( com_ptr< IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video function configure_D3D11_DXGI HRESULT configure_D3D11_DXGI ( gsl::not_null< IMFTransform *> transform, IMFDXGIDeviceManager * device_manager ) noexcept Returns: E_NOTIMPL, E_FAIL ... See also: https://docs.microsoft.com/en-us/windows/win32/medfound/hardware-mfts function configure_acceleration_H264 HRESULT configure_acceleration_H264 ( gsl::not_null< IMFTransform *> transform ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder#transform-attributes function configure_destination_rectangle HRESULT configure_destination_rectangle ( gsl::not_null< IPropertyStore *> props, const RECT & rect ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/videoresizer function configure_rectangle HRESULT configure_rectangle ( gsl::not_null< IMFVideoProcessorControl *> control, gsl::not_null< IMFMediaType *> media_type ) noexcept function configure_source_rectangle HRESULT configure_source_rectangle ( gsl::not_null< IPropertyStore *> props, const RECT & rect ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/videoresizer function configure_video HRESULT configure_video ( com_ptr< IMFMediaType > type ) function configure_video_output_RGB32 HRESULT configure_video_output_RGB32 ( IMFMediaType * type ) noexcept function configure_video_output_RGB565 HRESULT configure_video_output_RGB565 ( IMFMediaType * type ) noexcept function create_and_copy_single_buffer_sample HRESULT create_and_copy_single_buffer_sample ( IMFSample * src, IMFSample ** dst ) function create_single_buffer_sample HRESULT create_single_buffer_sample ( DWORD bufsz, IMFSample ** sample ) function decode auto decode ( com_ptr< IMFTransform > transform, DWORD ostream, com_ptr< IMFMediaType > output_type, HRESULT & ec ) noexcept function get_devices HRESULT get_devices ( std::vector< com_ptr< IMFActivate >> & devices, IMFAttributes * attributes ) noexcept See also: MFEnumDeviceSources function get_hardware_url HRESULT get_hardware_url ( gsl::not_null< IMFTransform *> transform, winrt::hstring & name ) noexcept function get_input_available_types auto get_input_available_types ( com_ptr< IMFTransform > transform, DWORD num_input, HRESULT & ec ) noexcept function get_name HRESULT get_name ( gsl::not_null< IMFActivate *> device, winrt::hstring & name ) noexcept See also: MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME function get_name HRESULT get_name ( gsl::not_null< IMFActivate *> device, std::string & ref ) noexcept function get_name HRESULT get_name ( gsl::not_null< IMFActivate *> device, std::wstring & ref ) noexcept function get_output_available_types auto get_output_available_types ( com_ptr< IMFTransform > transform, DWORD num_output, HRESULT & ec ) noexcept function get_stream_descriptor HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr ) function get_string HRESULT get_string ( gsl::not_null< IMFAttributes *> attribute, const GUID & uuid, winrt::hstring & name ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/api/mfobjects/nf-mfobjects-imfattributes-getstring function get_transform_output HRESULT get_transform_output ( IMFTransform * transform, IMFSample ** sample, BOOL & flushed ) function make_transform_H264 HRESULT make_transform_H264 ( IMFTransform ** transform ) noexcept See also: CoCreateInstance See also: CLSID_CMSH264DecoderMFT See also: https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder function make_transform_video HRESULT make_transform_video ( IMFTransform ** transform, const IID & iid ) noexcept See also: CoCreateInstance See also: Color Converter DSP https://docs.microsoft.com/en-us/windows/win32/medfound/colorconverter Parameters: iid CLSID_CColorConvertDMO Todo test CLSID_OpenCLMFTDx11 function make_transform_video HRESULT make_transform_video ( IMFTransform ** transform ) noexcept See also: CoCreateInstance See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: CLSID_VideoProcessorMFT function make_video_output_RGB32 HRESULT make_video_output_RGB32 ( IMFMediaType ** ptr ) noexcept Todo : configure MF_MT_FRAME_SIZE, MF_MT_FRAME_RATE : configure MF_MT_PIXEL_ASPECT_RATIO function make_video_output_RGB565 HRESULT make_video_output_RGB565 ( IMFMediaType ** ptr ) noexcept function media_startup auto media_startup () noexcept See also: MFStartup See also: MFShutdown Exception: winrt::hresult_error function process auto process ( com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSample > input_sample, com_ptr< IMFMediaType > output_type, HRESULT & ec ) noexcept function process auto process ( com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSourceReader > source_reader, HRESULT & ec ) function read_samples auto read_samples ( com_ptr< IMFSourceReader > source_reader, DWORD & index, DWORD & flags, LONGLONG & timestamp, LONGLONG & duration ) noexcept Todo https://docs.microsoft.com/en-us/windows/win32/medfound/mf-source-reader-enable-advanced-video-processing#remarks function resolve HRESULT resolve ( const fs::path & fpath, IMFMediaSourceEx ** source, MF_OBJECT_TYPE & media_object_type ) noexcept See also: MFCreateSourceResolver function try_input_available_types auto try_input_available_types ( com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index ) noexcept function try_output_available_types auto try_output_available_types ( com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index ) noexcept function try_output_type HRESULT try_output_type ( com_ptr< IMFTransform > transform, DWORD ostream, const GUID & desired, IMFMediaType ** output_type ) noexcept The documentation for this class was generated from the following file src/media.cpp","title":"File media.cpp"},{"location":"media_8cpp/#file-mediacpp","text":"File List > src > media.cpp Go to the source code of this file. #include <winrt/Windows.Foundation.h> #include <winrt/Windows.System.Threading.h> #include <media.hpp> #include <spdlog/spdlog.h> #include <codecapi.h> #include <dshowasf.h> #include <mediaobj.h>","title":"File media.cpp"},{"location":"media_8cpp/#namespaces","text":"Type Name namespace std","title":"Namespaces"},{"location":"media_8cpp/#classes","text":"Type Name struct critical_section_t","title":"Classes"},{"location":"media_8cpp/#public-functions","text":"Type Name HRESULT configure (com_ptr< IMFStreamDescriptor > stream) noexcept HRESULT configure_D3D11_DXGI (gsl::not_null< IMFTransform *> transform, IMFDXGIDeviceManager * device_manager) noexcept configure D3D11 if the transform supports it HRESULT configure_acceleration_H264 (gsl::not_null< IMFTransform *> transform) noexcept HRESULT configure_destination_rectangle (gsl::not_null< IPropertyStore *> props, const RECT & rect) noexcept HRESULT configure_rectangle (gsl::not_null< IMFVideoProcessorControl *> control, gsl::not_null< IMFMediaType *> media_type) noexcept exactly same sized src/dst rectangle; HRESULT configure_source_rectangle (gsl::not_null< IPropertyStore *> props, const RECT & rect) noexcept HRESULT configure_video (com_ptr< IMFMediaType > type) HRESULT configure_video_output_RGB32 (IMFMediaType * type) noexcept HRESULT configure_video_output_RGB565 (IMFMediaType * type) noexcept HRESULT create_and_copy_single_buffer_sample (IMFSample * src, IMFSample ** dst) HRESULT create_single_buffer_sample (DWORD bufsz, IMFSample ** sample) auto decode (com_ptr< IMFTransform > transform, DWORD ostream, com_ptr< IMFMediaType > output_type, HRESULT & ec) noexcept HRESULT get_devices (std::vector< com_ptr< IMFActivate >> & devices, IMFAttributes * attributes) noexcept HRESULT get_hardware_url (gsl::not_null< IMFTransform *> transform, winrt::hstring & name) noexcept auto get_input_available_types (com_ptr< IMFTransform > transform, DWORD num_input, HRESULT & ec) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, winrt::hstring & name) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, std::string & ref) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, std::wstring & ref) noexcept auto get_output_available_types (com_ptr< IMFTransform > transform, DWORD num_output, HRESULT & ec) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) HRESULT get_string (gsl::not_null< IMFAttributes *> attribute, const GUID & uuid, winrt::hstring & name) noexcept HRESULT get_transform_output (IMFTransform * transform, IMFSample ** sample, BOOL & flushed) HRESULT make_transform_H264 (IMFTransform ** transform) noexcept HRESULT make_transform_video (IMFTransform ** transform, const IID & iid) noexcept HRESULT make_transform_video (IMFTransform ** transform) noexcept HRESULT make_video_output_RGB32 (IMFMediaType ** ptr) noexcept HRESULT make_video_output_RGB565 (IMFMediaType ** ptr) noexcept auto media_startup () noexcept auto process (com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSample > input_sample, com_ptr< IMFMediaType > output_type, HRESULT & ec) noexcept auto process (com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSourceReader > source_reader, HRESULT & ec) auto read_samples (com_ptr< IMFSourceReader > source_reader, DWORD & index, DWORD & flags, LONGLONG & timestamp, LONGLONG & duration) noexcept HRESULT resolve (const fs::path & fpath, IMFMediaSourceEx ** source, MF_OBJECT_TYPE & media_object_type) noexcept auto try_input_available_types (com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index) noexcept auto try_output_available_types (com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index) noexcept HRESULT try_output_type (com_ptr< IMFTransform > transform, DWORD ostream, const GUID & desired, IMFMediaType ** output_type) noexcept","title":"Public Functions"},{"location":"media_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"media_8cpp/#function-configure","text":"HRESULT configure ( com_ptr< IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video","title":"function configure"},{"location":"media_8cpp/#function-configure_d3d11_dxgi","text":"HRESULT configure_D3D11_DXGI ( gsl::not_null< IMFTransform *> transform, IMFDXGIDeviceManager * device_manager ) noexcept Returns: E_NOTIMPL, E_FAIL ... See also: https://docs.microsoft.com/en-us/windows/win32/medfound/hardware-mfts","title":"function configure_D3D11_DXGI"},{"location":"media_8cpp/#function-configure_acceleration_h264","text":"HRESULT configure_acceleration_H264 ( gsl::not_null< IMFTransform *> transform ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder#transform-attributes","title":"function configure_acceleration_H264"},{"location":"media_8cpp/#function-configure_destination_rectangle","text":"HRESULT configure_destination_rectangle ( gsl::not_null< IPropertyStore *> props, const RECT & rect ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/videoresizer","title":"function configure_destination_rectangle"},{"location":"media_8cpp/#function-configure_rectangle","text":"HRESULT configure_rectangle ( gsl::not_null< IMFVideoProcessorControl *> control, gsl::not_null< IMFMediaType *> media_type ) noexcept","title":"function configure_rectangle"},{"location":"media_8cpp/#function-configure_source_rectangle","text":"HRESULT configure_source_rectangle ( gsl::not_null< IPropertyStore *> props, const RECT & rect ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/videoresizer","title":"function configure_source_rectangle"},{"location":"media_8cpp/#function-configure_video","text":"HRESULT configure_video ( com_ptr< IMFMediaType > type )","title":"function configure_video"},{"location":"media_8cpp/#function-configure_video_output_rgb32","text":"HRESULT configure_video_output_RGB32 ( IMFMediaType * type ) noexcept","title":"function configure_video_output_RGB32"},{"location":"media_8cpp/#function-configure_video_output_rgb565","text":"HRESULT configure_video_output_RGB565 ( IMFMediaType * type ) noexcept","title":"function configure_video_output_RGB565"},{"location":"media_8cpp/#function-create_and_copy_single_buffer_sample","text":"HRESULT create_and_copy_single_buffer_sample ( IMFSample * src, IMFSample ** dst )","title":"function create_and_copy_single_buffer_sample"},{"location":"media_8cpp/#function-create_single_buffer_sample","text":"HRESULT create_single_buffer_sample ( DWORD bufsz, IMFSample ** sample )","title":"function create_single_buffer_sample"},{"location":"media_8cpp/#function-decode","text":"auto decode ( com_ptr< IMFTransform > transform, DWORD ostream, com_ptr< IMFMediaType > output_type, HRESULT & ec ) noexcept","title":"function decode"},{"location":"media_8cpp/#function-get_devices","text":"HRESULT get_devices ( std::vector< com_ptr< IMFActivate >> & devices, IMFAttributes * attributes ) noexcept See also: MFEnumDeviceSources","title":"function get_devices"},{"location":"media_8cpp/#function-get_hardware_url","text":"HRESULT get_hardware_url ( gsl::not_null< IMFTransform *> transform, winrt::hstring & name ) noexcept","title":"function get_hardware_url"},{"location":"media_8cpp/#function-get_input_available_types","text":"auto get_input_available_types ( com_ptr< IMFTransform > transform, DWORD num_input, HRESULT & ec ) noexcept","title":"function get_input_available_types"},{"location":"media_8cpp/#function-get_name","text":"HRESULT get_name ( gsl::not_null< IMFActivate *> device, winrt::hstring & name ) noexcept See also: MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME","title":"function get_name"},{"location":"media_8cpp/#function-get_name_1","text":"HRESULT get_name ( gsl::not_null< IMFActivate *> device, std::string & ref ) noexcept","title":"function get_name"},{"location":"media_8cpp/#function-get_name_2","text":"HRESULT get_name ( gsl::not_null< IMFActivate *> device, std::wstring & ref ) noexcept","title":"function get_name"},{"location":"media_8cpp/#function-get_output_available_types","text":"auto get_output_available_types ( com_ptr< IMFTransform > transform, DWORD num_output, HRESULT & ec ) noexcept","title":"function get_output_available_types"},{"location":"media_8cpp/#function-get_stream_descriptor","text":"HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr )","title":"function get_stream_descriptor"},{"location":"media_8cpp/#function-get_string","text":"HRESULT get_string ( gsl::not_null< IMFAttributes *> attribute, const GUID & uuid, winrt::hstring & name ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/api/mfobjects/nf-mfobjects-imfattributes-getstring","title":"function get_string"},{"location":"media_8cpp/#function-get_transform_output","text":"HRESULT get_transform_output ( IMFTransform * transform, IMFSample ** sample, BOOL & flushed )","title":"function get_transform_output"},{"location":"media_8cpp/#function-make_transform_h264","text":"HRESULT make_transform_H264 ( IMFTransform ** transform ) noexcept See also: CoCreateInstance See also: CLSID_CMSH264DecoderMFT See also: https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder","title":"function make_transform_H264"},{"location":"media_8cpp/#function-make_transform_video","text":"HRESULT make_transform_video ( IMFTransform ** transform, const IID & iid ) noexcept See also: CoCreateInstance See also: Color Converter DSP https://docs.microsoft.com/en-us/windows/win32/medfound/colorconverter Parameters: iid CLSID_CColorConvertDMO Todo test CLSID_OpenCLMFTDx11","title":"function make_transform_video"},{"location":"media_8cpp/#function-make_transform_video_1","text":"HRESULT make_transform_video ( IMFTransform ** transform ) noexcept See also: CoCreateInstance See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: CLSID_VideoProcessorMFT","title":"function make_transform_video"},{"location":"media_8cpp/#function-make_video_output_rgb32","text":"HRESULT make_video_output_RGB32 ( IMFMediaType ** ptr ) noexcept Todo : configure MF_MT_FRAME_SIZE, MF_MT_FRAME_RATE : configure MF_MT_PIXEL_ASPECT_RATIO","title":"function make_video_output_RGB32"},{"location":"media_8cpp/#function-make_video_output_rgb565","text":"HRESULT make_video_output_RGB565 ( IMFMediaType ** ptr ) noexcept","title":"function make_video_output_RGB565"},{"location":"media_8cpp/#function-media_startup","text":"auto media_startup () noexcept See also: MFStartup See also: MFShutdown Exception: winrt::hresult_error","title":"function media_startup"},{"location":"media_8cpp/#function-process","text":"auto process ( com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSample > input_sample, com_ptr< IMFMediaType > output_type, HRESULT & ec ) noexcept","title":"function process"},{"location":"media_8cpp/#function-process_1","text":"auto process ( com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSourceReader > source_reader, HRESULT & ec )","title":"function process"},{"location":"media_8cpp/#function-read_samples","text":"auto read_samples ( com_ptr< IMFSourceReader > source_reader, DWORD & index, DWORD & flags, LONGLONG & timestamp, LONGLONG & duration ) noexcept Todo https://docs.microsoft.com/en-us/windows/win32/medfound/mf-source-reader-enable-advanced-video-processing#remarks","title":"function read_samples"},{"location":"media_8cpp/#function-resolve","text":"HRESULT resolve ( const fs::path & fpath, IMFMediaSourceEx ** source, MF_OBJECT_TYPE & media_object_type ) noexcept See also: MFCreateSourceResolver","title":"function resolve"},{"location":"media_8cpp/#function-try_input_available_types","text":"auto try_input_available_types ( com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index ) noexcept","title":"function try_input_available_types"},{"location":"media_8cpp/#function-try_output_available_types","text":"auto try_output_available_types ( com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index ) noexcept","title":"function try_output_available_types"},{"location":"media_8cpp/#function-try_output_type","text":"HRESULT try_output_type ( com_ptr< IMFTransform > transform, DWORD ostream, const GUID & desired, IMFMediaType ** output_type ) noexcept The documentation for this class was generated from the following file src/media.cpp","title":"function try_output_type"},{"location":"media_8cpp_source/","text":"File media.cpp File List > src > media.cpp Go to the documentation of this file. #include <winrt/Windows.Foundation.h> #include <winrt/Windows.System.Threading.h> #include <media.hpp> #include <spdlog/spdlog.h> #include <codecapi.h> // for [codec] #include <dshowasf.h> #include <mediaobj.h> // for [dsp] using namespace std; struct critical_section_t final : public CRITICAL_SECTION { public: critical_section_t() noexcept : CRITICAL_SECTION{} { InitializeCriticalSection(this); } ~critical_section_t() noexcept { DeleteCriticalSection(this); } bool try_lock() noexcept { return TryEnterCriticalSection(this); } void lock() noexcept { return EnterCriticalSection(this); } void unlock() noexcept { return LeaveCriticalSection(this); } }; auto media_startup() noexcept(false) -> gsl::final_action<HRESULT(WINAPI*)()> { if (auto hr = MFStartup(MF_VERSION)) throw winrt::hresult_error{hr}; spdlog::info(\"media_foundation:\"); spdlog::info(\"- version: {:x}\", MF_VERSION); return gsl::finally(&MFShutdown); } HRESULT get_devices(std::vector<com_ptr<IMFActivate>>& devices, IMFAttributes* attributes) noexcept { IMFActivate** handles = nullptr; UINT32 count = 0; if (auto hr = MFEnumDeviceSources(attributes, &handles, &count); FAILED(hr)) return hr; auto on_return = gsl::finally([handles]() { CoTaskMemFree(handles); // must be deallocated }); for (auto i = 0u; i < count; ++i) { com_ptr<IMFActivate> activate{}; activate.attach(handles[i]); devices.emplace_back(move(activate)); } return S_OK; } HRESULT get_string(gsl::not_null<IMFAttributes*> attribute, const GUID& uuid, winrt::hstring& name) noexcept { constexpr UINT32 max_size = 240; WCHAR buf[max_size]{}; UINT32 buflen{}; HRESULT hr = attribute->GetString(uuid, buf, max_size, &buflen); if (SUCCEEDED(hr)) name = {buf, buflen}; return hr; } HRESULT get_name(gsl::not_null<IMFActivate*> device, winrt::hstring& name) noexcept { return get_string(device, MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME, name); } HRESULT get_name(gsl::not_null<IMFActivate*> device, std::string& ref) noexcept { winrt::hstring name{}; auto hr = get_name(device, name); if SUCCEEDED (hr) ref = winrt::to_string(name); return hr; } HRESULT get_name(gsl::not_null<IMFActivate*> device, std::wstring& ref) noexcept { winrt::hstring name{}; auto hr = get_name(device, name); if SUCCEEDED (hr) ref = name.c_str(); return hr; } HRESULT get_hardware_url(gsl::not_null<IMFTransform*> transform, winrt::hstring& name) noexcept { com_ptr<IMFAttributes> attrs{}; if (auto hr = transform->GetAttributes(attrs.put())) return hr; constexpr UINT32 max_size = 240; WCHAR buf[max_size]{}; UINT32 buflen{}; HRESULT hr = attrs->GetString(MFT_ENUM_HARDWARE_URL_Attribute, buf, max_size, &buflen); if (SUCCEEDED(hr)) name = {buf, buflen}; return hr; } HRESULT resolve(const fs::path& fpath, IMFMediaSourceEx** source, MF_OBJECT_TYPE& media_object_type) noexcept { com_ptr<IMFSourceResolver> resolver{}; if (auto hr = MFCreateSourceResolver(resolver.put())) return hr; com_ptr<IUnknown> unknown{}; if (auto hr = resolver->CreateObjectFromURL(fpath.c_str(), MF_RESOLUTION_MEDIASOURCE | MF_RESOLUTION_READ, NULL, &media_object_type, unknown.put())) return hr; return unknown->QueryInterface(source); } HRESULT make_transform_H264(IMFTransform** transform) noexcept { com_ptr<IUnknown> unknown{}; if (auto hr = CoCreateInstance(CLSID_CMSH264DecoderMFT, NULL, CLSCTX_INPROC_SERVER, // IID_PPV_ARGS(unknown.put()))) return hr; return unknown->QueryInterface(transform); } HRESULT make_transform_video(IMFTransform** transform, const IID& iid) noexcept { com_ptr<IUnknown> unknown{}; if (auto hr = CoCreateInstance(iid, NULL, CLSCTX_INPROC_SERVER, // IID_PPV_ARGS(unknown.put()))) return hr; return unknown->QueryInterface(transform); } HRESULT make_transform_video(IMFTransform** transform) noexcept { return make_transform_video(transform, CLSID_VideoProcessorMFT); } HRESULT configure_D3D11_DXGI(gsl::not_null<IMFTransform*> transform, IMFDXGIDeviceManager* device_manager) noexcept { com_ptr<IMFAttributes> attrs{}; if (auto hr = transform->GetAttributes(attrs.put())) // return can be E_NOTIMPL return hr; UINT32 supported{}; if (auto hr = attrs->GetUINT32(MF_SA_D3D11_AWARE, &supported); FAILED(hr)) return hr; if (supported == false) return E_FAIL; return transform->ProcessMessage(MFT_MESSAGE_SET_D3D_MANAGER, // reinterpret_cast<ULONG_PTR>(static_cast<IUnknown*>(device_manager))); } // @see https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder#transform-attributes HRESULT configure_acceleration_H264(gsl::not_null<IMFTransform*> transform) noexcept { com_ptr<IMFAttributes> attrs{}; if (auto hr = transform->GetAttributes(attrs.put())) return hr; if (auto hr = attrs->SetUINT32(CODECAPI_AVDecVideoAcceleration_H264, TRUE); FAILED(hr)) spdlog::error(\"CODECAPI_AVDecVideoAcceleration_H264: {:#08x}\", hr); if (auto hr = attrs->SetUINT32(CODECAPI_AVLowLatencyMode, TRUE); FAILED(hr)) spdlog::error(\"CODECAPI_AVLowLatencyMode: {:#08x}\", hr); if (auto hr = attrs->SetUINT32(CODECAPI_AVDecNumWorkerThreads, 1); FAILED(hr)) spdlog::error(\"CODECAPI_AVDecNumWorkerThreads: {:#08x}\", hr); return S_OK; } HRESULT configure_video_output_RGB565(IMFMediaType* type) noexcept { if (type == nullptr) return E_INVALIDARG; if (auto hr = type->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video)) return hr; if (auto hr = type->SetUINT32(MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE)) return hr; return type->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_RGB565); } HRESULT make_video_output_RGB565(IMFMediaType** ptr) noexcept { if (ptr == nullptr) return E_INVALIDARG; *ptr = nullptr; com_ptr<IMFMediaType> output_type{}; if (auto hr = MFCreateMediaType(output_type.put())) return hr; if (auto hr = configure_video_output_RGB565(output_type.get())) return hr; output_type->AddRef(); *ptr = output_type.get(); return S_OK; } HRESULT configure_video_output_RGB32(IMFMediaType* type) noexcept { if (type == nullptr) return E_INVALIDARG; if (auto hr = type->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video)) return hr; if (auto hr = type->SetUINT32(MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE)) return hr; if (auto hr = type->SetUINT32(MF_MT_INTERLACE_MODE, MFVideoInterlace_Unknown)) return hr; //if (auto hr = MFSetAttributeRatio(output_type.get(), MF_MT_PIXEL_ASPECT_RATIO, 16, 9)) // return hr; return type->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_RGB32); } HRESULT make_video_output_RGB32(IMFMediaType** ptr) noexcept { if (ptr == nullptr) return E_INVALIDARG; *ptr = nullptr; com_ptr<IMFMediaType> output_type{}; if (auto hr = MFCreateMediaType(output_type.put())) return hr; if (auto hr = configure_video_output_RGB32(output_type.get())) return hr; output_type->AddRef(); *ptr = output_type.get(); return S_OK; } HRESULT try_output_type(com_ptr<IMFTransform> transform, DWORD ostream, const GUID& desired, IMFMediaType** output_type) noexcept { DWORD type_index = 0; for (com_ptr<IMFMediaType> candidate : try_output_available_types(transform, ostream, type_index)) { GUID subtype{}; if (auto hr = candidate->GetGUID(MF_MT_SUBTYPE, &subtype)) return hr; if (subtype != desired) continue; if (auto hr = transform->SetOutputType(ostream, candidate.get(), 0)) return hr; break; } if (type_index == 0) return E_FAIL; return transform->GetOutputCurrentType(ostream, output_type); } auto get_input_available_types(com_ptr<IMFTransform> transform, DWORD num_input, HRESULT& ec) noexcept(false) -> generator<com_ptr<IMFMediaType>> { for (auto stream_id = 0u; stream_id < num_input; ++stream_id) { DWORD type_index = 0; com_ptr<IMFMediaType> media_type{}; for (ec = transform->GetInputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(ec); ec = transform->GetInputAvailableType(stream_id, type_index++, media_type.put())) { co_yield media_type; media_type = nullptr; } } } auto try_output_available_types(com_ptr<IMFTransform> transform, DWORD stream_id, DWORD& type_index) noexcept(false) -> generator<com_ptr<IMFMediaType>> { type_index = 0; com_ptr<IMFMediaType> media_type{}; for (auto hr = transform->GetOutputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(hr); hr = transform->GetOutputAvailableType(stream_id, type_index++, media_type.put())) { co_yield media_type; media_type = nullptr; } } auto get_output_available_types(com_ptr<IMFTransform> transform, DWORD num_output, HRESULT& ec) noexcept(false) -> generator<com_ptr<IMFMediaType>> { for (auto stream_id = 0u; stream_id < num_output; ++stream_id) { DWORD type_index = 0; com_ptr<IMFMediaType> media_type{}; for (ec = transform->GetOutputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(ec); ec = transform->GetOutputAvailableType(stream_id, type_index++, media_type.put())) { co_yield media_type; media_type = nullptr; } } } auto try_input_available_types(com_ptr<IMFTransform> transform, DWORD stream_id, DWORD& type_index) noexcept(false) -> generator<com_ptr<IMFMediaType>> { type_index = 0; com_ptr<IMFMediaType> media_type{}; for (auto hr = transform->GetInputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(hr); hr = transform->GetInputAvailableType(stream_id, type_index++, media_type.put())) { co_yield media_type; media_type = nullptr; } } HRESULT configure_rectangle(gsl::not_null<IMFVideoProcessorControl*> control, gsl::not_null<IMFMediaType*> media_type) noexcept { UINT32 w = 0, h = 0; if (auto hr = MFGetAttributeSize(media_type, MF_MT_FRAME_SIZE, &w, &h); FAILED(hr)) return hr; RECT rect{}; rect.right = w; // LTRB rectangle rect.bottom = h; if (auto hr = control->SetSourceRectangle(&rect); FAILED(hr)) return hr; return control->SetDestinationRectangle(&rect); } HRESULT configure_source_rectangle(gsl::not_null<IPropertyStore*> props, const RECT& rect) noexcept { PROPVARIANT val{}; val.intVal = rect.left; if (auto hr = props->SetValue(MFPKEY_RESIZE_SRC_LEFT, val)) return hr; val.intVal = rect.top; if (auto hr = props->SetValue(MFPKEY_RESIZE_SRC_TOP, val)) return hr; val.intVal = rect.right - rect.left; if (auto hr = props->SetValue(MFPKEY_RESIZE_SRC_WIDTH, val)) return hr; val.intVal = rect.bottom - rect.top; return props->SetValue(MFPKEY_RESIZE_SRC_HEIGHT, val); } HRESULT configure_destination_rectangle(gsl::not_null<IPropertyStore*> props, const RECT& rect) noexcept { PROPVARIANT val{}; val.intVal = rect.left; if (auto hr = props->SetValue(MFPKEY_RESIZE_DST_LEFT, val)) return hr; val.intVal = rect.top; if (auto hr = props->SetValue(MFPKEY_RESIZE_DST_TOP, val)) return hr; val.intVal = rect.right - rect.left; if (auto hr = props->SetValue(MFPKEY_RESIZE_DST_WIDTH, val)) return hr; val.intVal = rect.bottom - rect.top; return props->SetValue(MFPKEY_RESIZE_DST_HEIGHT, val); } HRESULT get_stream_descriptor(IMFPresentationDescriptor* presentation, IMFStreamDescriptor** ptr) { DWORD num_stream = 0; if (auto hr = presentation->GetStreamDescriptorCount(&num_stream); SUCCEEDED(hr) == false) return hr; for (auto i = 0u; i < num_stream; ++i) { BOOL selected = false; if (auto hr = presentation->GetStreamDescriptorByIndex(i, &selected, ptr); FAILED(hr)) return hr; if (selected) break; } return S_OK; } HRESULT configure_video(com_ptr<IMFMediaType> type) { GUID subtype{}; type->GetGUID(MF_MT_SUBTYPE, &subtype); UINT32 interlace = 0; type->GetUINT32(MF_MT_INTERLACE_MODE, &interlace); const auto imode = static_cast<MFVideoInterlaceMode>(interlace); UINT32 stride = 0; type->GetUINT32(MF_MT_DEFAULT_STRIDE, &stride); UINT32 ycbcr2rgb = 0; type->GetUINT32(MF_MT_YUV_MATRIX, &ycbcr2rgb); const auto matrix = static_cast<MFVideoTransferMatrix>(ycbcr2rgb); UINT64 size = 0; type->GetUINT64(MF_MT_FRAME_SIZE, &size); // MFGetAttributeSize UINT32 w = size >> 32, h = size & UINT32_MAX; UINT64 framerate = 0; // framerate >> 32; type->GetUINT64(MF_MT_FRAME_RATE_RANGE_MAX, &framerate); return type->SetUINT64(MF_MT_FRAME_RATE, framerate); } HRESULT configure(com_ptr<IMFStreamDescriptor> stream) noexcept { com_ptr<IMFMediaTypeHandler> handler{}; if (auto hr = stream->GetMediaTypeHandler(handler.put()); SUCCEEDED(hr) == false) return hr; DWORD num_types = 0; if (auto hr = handler->GetMediaTypeCount(&num_types); SUCCEEDED(hr) == false) return hr; com_ptr<IMFMediaType> type{}; for (auto i = 0u; i < num_types; ++i) { com_ptr<IMFMediaType> current{}; if (auto hr = handler->GetMediaTypeByIndex(i, current.put()); FAILED(hr)) return hr; if (type == nullptr) type = current; print(current.get()); } return handler->SetCurrentMediaType(type.get()); } auto read_samples(com_ptr<IMFSourceReader> source_reader, // DWORD& index, DWORD& flags, LONGLONG& timestamp, LONGLONG& duration) noexcept(false) -> generator<com_ptr<IMFSample>> { const auto stream = static_cast<DWORD>(MF_SOURCE_READER_FIRST_VIDEO_STREAM); while (true) { com_ptr<IMFSample> input_sample{}; if (auto hr = source_reader->ReadSample(stream, 0, &index, &flags, &timestamp, input_sample.put())) throw winrt::hresult_error{hr}; if (flags & MF_SOURCE_READERF_ENDOFSTREAM) co_return; if (flags & MF_SOURCE_READERF_STREAMTICK) spdlog::debug(\"MF_SOURCE_READERF_STREAMTICK\"); if (input_sample == nullptr) // probably MF_SOURCE_READERF_STREAMTICK continue; co_yield input_sample; } }; auto decode(com_ptr<IMFTransform> transform, DWORD ostream, com_ptr<IMFMediaType> output_type, HRESULT& ec) noexcept -> generator<com_ptr<IMFSample>> { MFT_OUTPUT_STREAM_INFO output_stream_info{}; if (ec = transform->GetOutputStreamInfo(ostream, &output_stream_info); FAILED(ec)) co_return; while (true) { MFT_OUTPUT_DATA_BUFFER output_buffer{}; com_ptr<IMFSample> output_sample{}; if (output_stream_info.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) { // ... } else { if (ec = create_single_buffer_sample(output_stream_info.cbSize, output_sample.put()); FAILED(ec)) co_return; output_buffer.pSample = output_sample.get(); } DWORD status = 0; // MFT_OUTPUT_STATUS_SAMPLE_READY ec = transform->ProcessOutput(0, 1, &output_buffer, &status); if (ec == MF_E_TRANSFORM_NEED_MORE_INPUT) break; if (ec == MF_E_TRANSFORM_STREAM_CHANGE) { if (output_buffer.dwStatus != MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE) { // todo: add more works for this case co_return; } // the type is changed. update after reset output_type = nullptr; if (ec = transform->GetOutputAvailableType(output_buffer.dwStreamID, 0, output_type.put()); FAILED(ec)) co_return; // specify the format we want ... GUID output_subtype{}; if (ec = output_type->GetGUID(MF_MT_SUBTYPE, &output_subtype); FAILED(ec)) co_return; if (ec = transform->SetOutputType(ostream, output_type.get(), 0); FAILED(ec)) co_return; continue; } if (ec != S_OK) co_return; if (output_stream_info.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) output_sample.attach(output_buffer.pSample); co_yield output_sample; } } auto process(com_ptr<IMFTransform> transform, DWORD istream, DWORD ostream, // com_ptr<IMFSample> input_sample, com_ptr<IMFMediaType> output_type, HRESULT& ec) noexcept -> generator<com_ptr<IMFSample>> { DWORD index{}; DWORD flags{}; LONGLONG timestamp{}; // unit 100-nanosecond LONGLONG duration{}; if (ec = input_sample->SetSampleTime(timestamp); FAILED(ec)) co_return; switch (ec = transform->ProcessInput(istream, input_sample.get(), 0)) { case S_OK: // MF_E_TRANSFORM_TYPE_NOT_SET, MF_E_NO_SAMPLE_DURATION, MF_E_NO_SAMPLE_TIMESTAMP break; case MF_E_UNSUPPORTED_D3D_TYPE: case MF_E_NOTACCEPTING: default: // error co_return; } // fetch output if available for (com_ptr<IMFSample> output_sample : decode(transform, ostream, output_type, ec)) co_yield output_sample; } auto process(com_ptr<IMFTransform> transform, DWORD istream, DWORD ostream, com_ptr<IMFSourceReader> source_reader, HRESULT& ec) -> generator<com_ptr<IMFSample>> { com_ptr<IMFMediaType> output_type{}; if (ec = transform->GetOutputCurrentType(ostream, output_type.put()); FAILED(ec)) co_return; if (ec = transform->ProcessMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, NULL); FAILED(ec)) co_return; if (ec = transform->ProcessMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, NULL); FAILED(ec)) co_return; DWORD index{}; DWORD flags{}; LONGLONG timestamp{}; // unit 100-nanosecond LONGLONG duration{}; for (com_ptr<IMFSample> input_sample : read_samples(source_reader, // index, flags, timestamp, duration)) { input_sample->SetSampleTime(timestamp); for (com_ptr<IMFSample> output_sample : process(transform, istream, ostream, input_sample, output_type, ec)) co_yield output_sample; if (ec) co_return; } if (ec = transform->ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, NULL); FAILED(ec)) co_return; if (ec = transform->ProcessMessage(MFT_MESSAGE_COMMAND_DRAIN, NULL); FAILED(ec)) co_return; for (com_ptr<IMFSample> output_sample : decode(transform, ostream, output_type, ec)) co_yield output_sample; } HRESULT create_single_buffer_sample(DWORD bufsz, IMFSample** sample) { if (auto hr = MFCreateSample(sample)) return hr; com_ptr<IMFMediaBuffer> buffer{}; if (auto hr = MFCreateMemoryBuffer(bufsz, buffer.put())) return hr; return (*sample)->AddBuffer(buffer.get()); } HRESULT create_and_copy_single_buffer_sample(IMFSample* src, IMFSample** dst) { DWORD total{}; if (auto hr = src->GetTotalLength(&total)) return hr; if (auto hr = create_single_buffer_sample(total, dst)) return hr; if (auto hr = src->CopyAllItems(*dst)) return hr; com_ptr<IMFMediaBuffer> buffer{}; if (auto hr = (*dst)->GetBufferByIndex(0, buffer.put())) return hr; return src->CopyToBuffer(buffer.get()); } HRESULT get_transform_output(IMFTransform* transform, IMFSample** sample, BOOL& flushed) { MFT_OUTPUT_STREAM_INFO stream_info{}; if (auto hr = transform->GetOutputStreamInfo(0, &stream_info)) return hr; flushed = FALSE; *sample = nullptr; MFT_OUTPUT_DATA_BUFFER output{}; if ((stream_info.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) == 0) { if (auto hr = create_single_buffer_sample(stream_info.cbSize, sample)) return hr; output.pSample = *sample; } DWORD status = 0; HRESULT const result = transform->ProcessOutput(0, 1, &output, &status); if (result == S_OK) { *sample = output.pSample; return S_OK; } // see https://docs.microsoft.com/en-us/windows/win32/medfound/handling-stream-changes if (result == MF_E_TRANSFORM_STREAM_CHANGE) { com_ptr<IMFMediaType> changed_output_type{}; if (output.dwStatus != MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE) { // todo: add more works for this case return E_NOTIMPL; } if (auto hr = transform->GetOutputAvailableType(0, 0, changed_output_type.put())) return hr; // check new output media type if (auto hr = changed_output_type->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_IYUV)) return hr; if (auto hr = transform->SetOutputType(0, changed_output_type.get(), 0)) return hr; if (auto hr = transform->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL)) return hr; flushed = TRUE; return S_OK; } // MF_E_TRANSFORM_NEED_MORE_INPUT: not an error condition but it means the allocated output sample is empty. return result; }","title":"File media.cpp"},{"location":"media_8cpp_source/#file-mediacpp","text":"File List > src > media.cpp Go to the documentation of this file. #include <winrt/Windows.Foundation.h> #include <winrt/Windows.System.Threading.h> #include <media.hpp> #include <spdlog/spdlog.h> #include <codecapi.h> // for [codec] #include <dshowasf.h> #include <mediaobj.h> // for [dsp] using namespace std; struct critical_section_t final : public CRITICAL_SECTION { public: critical_section_t() noexcept : CRITICAL_SECTION{} { InitializeCriticalSection(this); } ~critical_section_t() noexcept { DeleteCriticalSection(this); } bool try_lock() noexcept { return TryEnterCriticalSection(this); } void lock() noexcept { return EnterCriticalSection(this); } void unlock() noexcept { return LeaveCriticalSection(this); } }; auto media_startup() noexcept(false) -> gsl::final_action<HRESULT(WINAPI*)()> { if (auto hr = MFStartup(MF_VERSION)) throw winrt::hresult_error{hr}; spdlog::info(\"media_foundation:\"); spdlog::info(\"- version: {:x}\", MF_VERSION); return gsl::finally(&MFShutdown); } HRESULT get_devices(std::vector<com_ptr<IMFActivate>>& devices, IMFAttributes* attributes) noexcept { IMFActivate** handles = nullptr; UINT32 count = 0; if (auto hr = MFEnumDeviceSources(attributes, &handles, &count); FAILED(hr)) return hr; auto on_return = gsl::finally([handles]() { CoTaskMemFree(handles); // must be deallocated }); for (auto i = 0u; i < count; ++i) { com_ptr<IMFActivate> activate{}; activate.attach(handles[i]); devices.emplace_back(move(activate)); } return S_OK; } HRESULT get_string(gsl::not_null<IMFAttributes*> attribute, const GUID& uuid, winrt::hstring& name) noexcept { constexpr UINT32 max_size = 240; WCHAR buf[max_size]{}; UINT32 buflen{}; HRESULT hr = attribute->GetString(uuid, buf, max_size, &buflen); if (SUCCEEDED(hr)) name = {buf, buflen}; return hr; } HRESULT get_name(gsl::not_null<IMFActivate*> device, winrt::hstring& name) noexcept { return get_string(device, MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME, name); } HRESULT get_name(gsl::not_null<IMFActivate*> device, std::string& ref) noexcept { winrt::hstring name{}; auto hr = get_name(device, name); if SUCCEEDED (hr) ref = winrt::to_string(name); return hr; } HRESULT get_name(gsl::not_null<IMFActivate*> device, std::wstring& ref) noexcept { winrt::hstring name{}; auto hr = get_name(device, name); if SUCCEEDED (hr) ref = name.c_str(); return hr; } HRESULT get_hardware_url(gsl::not_null<IMFTransform*> transform, winrt::hstring& name) noexcept { com_ptr<IMFAttributes> attrs{}; if (auto hr = transform->GetAttributes(attrs.put())) return hr; constexpr UINT32 max_size = 240; WCHAR buf[max_size]{}; UINT32 buflen{}; HRESULT hr = attrs->GetString(MFT_ENUM_HARDWARE_URL_Attribute, buf, max_size, &buflen); if (SUCCEEDED(hr)) name = {buf, buflen}; return hr; } HRESULT resolve(const fs::path& fpath, IMFMediaSourceEx** source, MF_OBJECT_TYPE& media_object_type) noexcept { com_ptr<IMFSourceResolver> resolver{}; if (auto hr = MFCreateSourceResolver(resolver.put())) return hr; com_ptr<IUnknown> unknown{}; if (auto hr = resolver->CreateObjectFromURL(fpath.c_str(), MF_RESOLUTION_MEDIASOURCE | MF_RESOLUTION_READ, NULL, &media_object_type, unknown.put())) return hr; return unknown->QueryInterface(source); } HRESULT make_transform_H264(IMFTransform** transform) noexcept { com_ptr<IUnknown> unknown{}; if (auto hr = CoCreateInstance(CLSID_CMSH264DecoderMFT, NULL, CLSCTX_INPROC_SERVER, // IID_PPV_ARGS(unknown.put()))) return hr; return unknown->QueryInterface(transform); } HRESULT make_transform_video(IMFTransform** transform, const IID& iid) noexcept { com_ptr<IUnknown> unknown{}; if (auto hr = CoCreateInstance(iid, NULL, CLSCTX_INPROC_SERVER, // IID_PPV_ARGS(unknown.put()))) return hr; return unknown->QueryInterface(transform); } HRESULT make_transform_video(IMFTransform** transform) noexcept { return make_transform_video(transform, CLSID_VideoProcessorMFT); } HRESULT configure_D3D11_DXGI(gsl::not_null<IMFTransform*> transform, IMFDXGIDeviceManager* device_manager) noexcept { com_ptr<IMFAttributes> attrs{}; if (auto hr = transform->GetAttributes(attrs.put())) // return can be E_NOTIMPL return hr; UINT32 supported{}; if (auto hr = attrs->GetUINT32(MF_SA_D3D11_AWARE, &supported); FAILED(hr)) return hr; if (supported == false) return E_FAIL; return transform->ProcessMessage(MFT_MESSAGE_SET_D3D_MANAGER, // reinterpret_cast<ULONG_PTR>(static_cast<IUnknown*>(device_manager))); } // @see https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder#transform-attributes HRESULT configure_acceleration_H264(gsl::not_null<IMFTransform*> transform) noexcept { com_ptr<IMFAttributes> attrs{}; if (auto hr = transform->GetAttributes(attrs.put())) return hr; if (auto hr = attrs->SetUINT32(CODECAPI_AVDecVideoAcceleration_H264, TRUE); FAILED(hr)) spdlog::error(\"CODECAPI_AVDecVideoAcceleration_H264: {:#08x}\", hr); if (auto hr = attrs->SetUINT32(CODECAPI_AVLowLatencyMode, TRUE); FAILED(hr)) spdlog::error(\"CODECAPI_AVLowLatencyMode: {:#08x}\", hr); if (auto hr = attrs->SetUINT32(CODECAPI_AVDecNumWorkerThreads, 1); FAILED(hr)) spdlog::error(\"CODECAPI_AVDecNumWorkerThreads: {:#08x}\", hr); return S_OK; } HRESULT configure_video_output_RGB565(IMFMediaType* type) noexcept { if (type == nullptr) return E_INVALIDARG; if (auto hr = type->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video)) return hr; if (auto hr = type->SetUINT32(MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE)) return hr; return type->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_RGB565); } HRESULT make_video_output_RGB565(IMFMediaType** ptr) noexcept { if (ptr == nullptr) return E_INVALIDARG; *ptr = nullptr; com_ptr<IMFMediaType> output_type{}; if (auto hr = MFCreateMediaType(output_type.put())) return hr; if (auto hr = configure_video_output_RGB565(output_type.get())) return hr; output_type->AddRef(); *ptr = output_type.get(); return S_OK; } HRESULT configure_video_output_RGB32(IMFMediaType* type) noexcept { if (type == nullptr) return E_INVALIDARG; if (auto hr = type->SetGUID(MF_MT_MAJOR_TYPE, MFMediaType_Video)) return hr; if (auto hr = type->SetUINT32(MF_MT_ALL_SAMPLES_INDEPENDENT, TRUE)) return hr; if (auto hr = type->SetUINT32(MF_MT_INTERLACE_MODE, MFVideoInterlace_Unknown)) return hr; //if (auto hr = MFSetAttributeRatio(output_type.get(), MF_MT_PIXEL_ASPECT_RATIO, 16, 9)) // return hr; return type->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_RGB32); } HRESULT make_video_output_RGB32(IMFMediaType** ptr) noexcept { if (ptr == nullptr) return E_INVALIDARG; *ptr = nullptr; com_ptr<IMFMediaType> output_type{}; if (auto hr = MFCreateMediaType(output_type.put())) return hr; if (auto hr = configure_video_output_RGB32(output_type.get())) return hr; output_type->AddRef(); *ptr = output_type.get(); return S_OK; } HRESULT try_output_type(com_ptr<IMFTransform> transform, DWORD ostream, const GUID& desired, IMFMediaType** output_type) noexcept { DWORD type_index = 0; for (com_ptr<IMFMediaType> candidate : try_output_available_types(transform, ostream, type_index)) { GUID subtype{}; if (auto hr = candidate->GetGUID(MF_MT_SUBTYPE, &subtype)) return hr; if (subtype != desired) continue; if (auto hr = transform->SetOutputType(ostream, candidate.get(), 0)) return hr; break; } if (type_index == 0) return E_FAIL; return transform->GetOutputCurrentType(ostream, output_type); } auto get_input_available_types(com_ptr<IMFTransform> transform, DWORD num_input, HRESULT& ec) noexcept(false) -> generator<com_ptr<IMFMediaType>> { for (auto stream_id = 0u; stream_id < num_input; ++stream_id) { DWORD type_index = 0; com_ptr<IMFMediaType> media_type{}; for (ec = transform->GetInputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(ec); ec = transform->GetInputAvailableType(stream_id, type_index++, media_type.put())) { co_yield media_type; media_type = nullptr; } } } auto try_output_available_types(com_ptr<IMFTransform> transform, DWORD stream_id, DWORD& type_index) noexcept(false) -> generator<com_ptr<IMFMediaType>> { type_index = 0; com_ptr<IMFMediaType> media_type{}; for (auto hr = transform->GetOutputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(hr); hr = transform->GetOutputAvailableType(stream_id, type_index++, media_type.put())) { co_yield media_type; media_type = nullptr; } } auto get_output_available_types(com_ptr<IMFTransform> transform, DWORD num_output, HRESULT& ec) noexcept(false) -> generator<com_ptr<IMFMediaType>> { for (auto stream_id = 0u; stream_id < num_output; ++stream_id) { DWORD type_index = 0; com_ptr<IMFMediaType> media_type{}; for (ec = transform->GetOutputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(ec); ec = transform->GetOutputAvailableType(stream_id, type_index++, media_type.put())) { co_yield media_type; media_type = nullptr; } } } auto try_input_available_types(com_ptr<IMFTransform> transform, DWORD stream_id, DWORD& type_index) noexcept(false) -> generator<com_ptr<IMFMediaType>> { type_index = 0; com_ptr<IMFMediaType> media_type{}; for (auto hr = transform->GetInputAvailableType(stream_id, type_index++, media_type.put()); SUCCEEDED(hr); hr = transform->GetInputAvailableType(stream_id, type_index++, media_type.put())) { co_yield media_type; media_type = nullptr; } } HRESULT configure_rectangle(gsl::not_null<IMFVideoProcessorControl*> control, gsl::not_null<IMFMediaType*> media_type) noexcept { UINT32 w = 0, h = 0; if (auto hr = MFGetAttributeSize(media_type, MF_MT_FRAME_SIZE, &w, &h); FAILED(hr)) return hr; RECT rect{}; rect.right = w; // LTRB rectangle rect.bottom = h; if (auto hr = control->SetSourceRectangle(&rect); FAILED(hr)) return hr; return control->SetDestinationRectangle(&rect); } HRESULT configure_source_rectangle(gsl::not_null<IPropertyStore*> props, const RECT& rect) noexcept { PROPVARIANT val{}; val.intVal = rect.left; if (auto hr = props->SetValue(MFPKEY_RESIZE_SRC_LEFT, val)) return hr; val.intVal = rect.top; if (auto hr = props->SetValue(MFPKEY_RESIZE_SRC_TOP, val)) return hr; val.intVal = rect.right - rect.left; if (auto hr = props->SetValue(MFPKEY_RESIZE_SRC_WIDTH, val)) return hr; val.intVal = rect.bottom - rect.top; return props->SetValue(MFPKEY_RESIZE_SRC_HEIGHT, val); } HRESULT configure_destination_rectangle(gsl::not_null<IPropertyStore*> props, const RECT& rect) noexcept { PROPVARIANT val{}; val.intVal = rect.left; if (auto hr = props->SetValue(MFPKEY_RESIZE_DST_LEFT, val)) return hr; val.intVal = rect.top; if (auto hr = props->SetValue(MFPKEY_RESIZE_DST_TOP, val)) return hr; val.intVal = rect.right - rect.left; if (auto hr = props->SetValue(MFPKEY_RESIZE_DST_WIDTH, val)) return hr; val.intVal = rect.bottom - rect.top; return props->SetValue(MFPKEY_RESIZE_DST_HEIGHT, val); } HRESULT get_stream_descriptor(IMFPresentationDescriptor* presentation, IMFStreamDescriptor** ptr) { DWORD num_stream = 0; if (auto hr = presentation->GetStreamDescriptorCount(&num_stream); SUCCEEDED(hr) == false) return hr; for (auto i = 0u; i < num_stream; ++i) { BOOL selected = false; if (auto hr = presentation->GetStreamDescriptorByIndex(i, &selected, ptr); FAILED(hr)) return hr; if (selected) break; } return S_OK; } HRESULT configure_video(com_ptr<IMFMediaType> type) { GUID subtype{}; type->GetGUID(MF_MT_SUBTYPE, &subtype); UINT32 interlace = 0; type->GetUINT32(MF_MT_INTERLACE_MODE, &interlace); const auto imode = static_cast<MFVideoInterlaceMode>(interlace); UINT32 stride = 0; type->GetUINT32(MF_MT_DEFAULT_STRIDE, &stride); UINT32 ycbcr2rgb = 0; type->GetUINT32(MF_MT_YUV_MATRIX, &ycbcr2rgb); const auto matrix = static_cast<MFVideoTransferMatrix>(ycbcr2rgb); UINT64 size = 0; type->GetUINT64(MF_MT_FRAME_SIZE, &size); // MFGetAttributeSize UINT32 w = size >> 32, h = size & UINT32_MAX; UINT64 framerate = 0; // framerate >> 32; type->GetUINT64(MF_MT_FRAME_RATE_RANGE_MAX, &framerate); return type->SetUINT64(MF_MT_FRAME_RATE, framerate); } HRESULT configure(com_ptr<IMFStreamDescriptor> stream) noexcept { com_ptr<IMFMediaTypeHandler> handler{}; if (auto hr = stream->GetMediaTypeHandler(handler.put()); SUCCEEDED(hr) == false) return hr; DWORD num_types = 0; if (auto hr = handler->GetMediaTypeCount(&num_types); SUCCEEDED(hr) == false) return hr; com_ptr<IMFMediaType> type{}; for (auto i = 0u; i < num_types; ++i) { com_ptr<IMFMediaType> current{}; if (auto hr = handler->GetMediaTypeByIndex(i, current.put()); FAILED(hr)) return hr; if (type == nullptr) type = current; print(current.get()); } return handler->SetCurrentMediaType(type.get()); } auto read_samples(com_ptr<IMFSourceReader> source_reader, // DWORD& index, DWORD& flags, LONGLONG& timestamp, LONGLONG& duration) noexcept(false) -> generator<com_ptr<IMFSample>> { const auto stream = static_cast<DWORD>(MF_SOURCE_READER_FIRST_VIDEO_STREAM); while (true) { com_ptr<IMFSample> input_sample{}; if (auto hr = source_reader->ReadSample(stream, 0, &index, &flags, &timestamp, input_sample.put())) throw winrt::hresult_error{hr}; if (flags & MF_SOURCE_READERF_ENDOFSTREAM) co_return; if (flags & MF_SOURCE_READERF_STREAMTICK) spdlog::debug(\"MF_SOURCE_READERF_STREAMTICK\"); if (input_sample == nullptr) // probably MF_SOURCE_READERF_STREAMTICK continue; co_yield input_sample; } }; auto decode(com_ptr<IMFTransform> transform, DWORD ostream, com_ptr<IMFMediaType> output_type, HRESULT& ec) noexcept -> generator<com_ptr<IMFSample>> { MFT_OUTPUT_STREAM_INFO output_stream_info{}; if (ec = transform->GetOutputStreamInfo(ostream, &output_stream_info); FAILED(ec)) co_return; while (true) { MFT_OUTPUT_DATA_BUFFER output_buffer{}; com_ptr<IMFSample> output_sample{}; if (output_stream_info.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) { // ... } else { if (ec = create_single_buffer_sample(output_stream_info.cbSize, output_sample.put()); FAILED(ec)) co_return; output_buffer.pSample = output_sample.get(); } DWORD status = 0; // MFT_OUTPUT_STATUS_SAMPLE_READY ec = transform->ProcessOutput(0, 1, &output_buffer, &status); if (ec == MF_E_TRANSFORM_NEED_MORE_INPUT) break; if (ec == MF_E_TRANSFORM_STREAM_CHANGE) { if (output_buffer.dwStatus != MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE) { // todo: add more works for this case co_return; } // the type is changed. update after reset output_type = nullptr; if (ec = transform->GetOutputAvailableType(output_buffer.dwStreamID, 0, output_type.put()); FAILED(ec)) co_return; // specify the format we want ... GUID output_subtype{}; if (ec = output_type->GetGUID(MF_MT_SUBTYPE, &output_subtype); FAILED(ec)) co_return; if (ec = transform->SetOutputType(ostream, output_type.get(), 0); FAILED(ec)) co_return; continue; } if (ec != S_OK) co_return; if (output_stream_info.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) output_sample.attach(output_buffer.pSample); co_yield output_sample; } } auto process(com_ptr<IMFTransform> transform, DWORD istream, DWORD ostream, // com_ptr<IMFSample> input_sample, com_ptr<IMFMediaType> output_type, HRESULT& ec) noexcept -> generator<com_ptr<IMFSample>> { DWORD index{}; DWORD flags{}; LONGLONG timestamp{}; // unit 100-nanosecond LONGLONG duration{}; if (ec = input_sample->SetSampleTime(timestamp); FAILED(ec)) co_return; switch (ec = transform->ProcessInput(istream, input_sample.get(), 0)) { case S_OK: // MF_E_TRANSFORM_TYPE_NOT_SET, MF_E_NO_SAMPLE_DURATION, MF_E_NO_SAMPLE_TIMESTAMP break; case MF_E_UNSUPPORTED_D3D_TYPE: case MF_E_NOTACCEPTING: default: // error co_return; } // fetch output if available for (com_ptr<IMFSample> output_sample : decode(transform, ostream, output_type, ec)) co_yield output_sample; } auto process(com_ptr<IMFTransform> transform, DWORD istream, DWORD ostream, com_ptr<IMFSourceReader> source_reader, HRESULT& ec) -> generator<com_ptr<IMFSample>> { com_ptr<IMFMediaType> output_type{}; if (ec = transform->GetOutputCurrentType(ostream, output_type.put()); FAILED(ec)) co_return; if (ec = transform->ProcessMessage(MFT_MESSAGE_NOTIFY_START_OF_STREAM, NULL); FAILED(ec)) co_return; if (ec = transform->ProcessMessage(MFT_MESSAGE_NOTIFY_BEGIN_STREAMING, NULL); FAILED(ec)) co_return; DWORD index{}; DWORD flags{}; LONGLONG timestamp{}; // unit 100-nanosecond LONGLONG duration{}; for (com_ptr<IMFSample> input_sample : read_samples(source_reader, // index, flags, timestamp, duration)) { input_sample->SetSampleTime(timestamp); for (com_ptr<IMFSample> output_sample : process(transform, istream, ostream, input_sample, output_type, ec)) co_yield output_sample; if (ec) co_return; } if (ec = transform->ProcessMessage(MFT_MESSAGE_NOTIFY_END_OF_STREAM, NULL); FAILED(ec)) co_return; if (ec = transform->ProcessMessage(MFT_MESSAGE_COMMAND_DRAIN, NULL); FAILED(ec)) co_return; for (com_ptr<IMFSample> output_sample : decode(transform, ostream, output_type, ec)) co_yield output_sample; } HRESULT create_single_buffer_sample(DWORD bufsz, IMFSample** sample) { if (auto hr = MFCreateSample(sample)) return hr; com_ptr<IMFMediaBuffer> buffer{}; if (auto hr = MFCreateMemoryBuffer(bufsz, buffer.put())) return hr; return (*sample)->AddBuffer(buffer.get()); } HRESULT create_and_copy_single_buffer_sample(IMFSample* src, IMFSample** dst) { DWORD total{}; if (auto hr = src->GetTotalLength(&total)) return hr; if (auto hr = create_single_buffer_sample(total, dst)) return hr; if (auto hr = src->CopyAllItems(*dst)) return hr; com_ptr<IMFMediaBuffer> buffer{}; if (auto hr = (*dst)->GetBufferByIndex(0, buffer.put())) return hr; return src->CopyToBuffer(buffer.get()); } HRESULT get_transform_output(IMFTransform* transform, IMFSample** sample, BOOL& flushed) { MFT_OUTPUT_STREAM_INFO stream_info{}; if (auto hr = transform->GetOutputStreamInfo(0, &stream_info)) return hr; flushed = FALSE; *sample = nullptr; MFT_OUTPUT_DATA_BUFFER output{}; if ((stream_info.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) == 0) { if (auto hr = create_single_buffer_sample(stream_info.cbSize, sample)) return hr; output.pSample = *sample; } DWORD status = 0; HRESULT const result = transform->ProcessOutput(0, 1, &output, &status); if (result == S_OK) { *sample = output.pSample; return S_OK; } // see https://docs.microsoft.com/en-us/windows/win32/medfound/handling-stream-changes if (result == MF_E_TRANSFORM_STREAM_CHANGE) { com_ptr<IMFMediaType> changed_output_type{}; if (output.dwStatus != MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE) { // todo: add more works for this case return E_NOTIMPL; } if (auto hr = transform->GetOutputAvailableType(0, 0, changed_output_type.put())) return hr; // check new output media type if (auto hr = changed_output_type->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_IYUV)) return hr; if (auto hr = transform->SetOutputType(0, changed_output_type.get(), 0)) return hr; if (auto hr = transform->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL)) return hr; flushed = TRUE; return S_OK; } // MF_E_TRANSFORM_NEED_MORE_INPUT: not an error condition but it means the allocated output sample is empty. return result; }","title":"File media.cpp"},{"location":"media_8hpp/","text":"File media.hpp File List > src > media.hpp Go to the source code of this file. #include <winrt/base.h> #include <experimental/generator> #include <filesystem> #include <gsl/gsl> #include <mfapi.h> #include <mferror.h> #include <mfidl.h> #include <mfreadwrite.h> #include <wmcodecdsp.h> Classes Type Name class qpc_timer_t Public Functions Type Name HRESULT configure (com_ptr< IMFStreamDescriptor > stream) noexcept HRESULT configure_D3D11_DXGI (gsl::not_null< IMFTransform *> transform, IMFDXGIDeviceManager * device_manager) noexcept configure D3D11 if the transform supports it HRESULT configure_acceleration_H264 (gsl::not_null< IMFTransform *> transform) noexcept HRESULT configure_destination_rectangle (gsl::not_null< IPropertyStore *> props, const RECT & rect) noexcept HRESULT configure_rectangle (gsl::not_null< IMFVideoProcessorControl *> control, gsl::not_null< IMFMediaType *> media_type) noexcept exactly same sized src/dst rectangle; HRESULT configure_source_rectangle (gsl::not_null< IPropertyStore *> props, const RECT & rect) noexcept HRESULT create_and_copy_single_buffer_sample (IMFSample * src, IMFSample ** dst) HRESULT create_single_buffer_sample (DWORD bufsz, IMFSample ** sample) auto decode (com_ptr< IMFTransform > transform, DWORD ostream, com_ptr< IMFMediaType > output_type, HRESULT & ec) noexcept HRESULT get_devices (std::vector< com_ptr< IMFActivate >> & devices, IMFAttributes * attributes) noexcept HRESULT get_hardware_url (gsl::not_null< IMFTransform *> transform, winrt::hstring & name) noexcept auto get_input_available_types (com_ptr< IMFTransform > transform, DWORD num_input, HRESULT & ec) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, winrt::hstring & name) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, std::wstring & name) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, std::string & name) noexcept auto get_output_available_types (com_ptr< IMFTransform > transform, DWORD num_output, HRESULT & ec) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) HRESULT get_string (gsl::not_null< IMFAttributes *> attribute, const GUID & uuid, winrt::hstring & name) noexcept HRESULT get_transform_output (IMFTransform * transform, IMFSample ** sample, BOOL & flushed) HRESULT make_transform_H264 (IMFTransform ** transform) noexcept HRESULT make_transform_video (IMFTransform ** transform, const IID & iid) noexcept HRESULT make_transform_video (IMFTransform ** transform) noexcept HRESULT make_video_output_RGB32 (IMFMediaType ** ptr) noexcept HRESULT make_video_output_RGB565 (IMFMediaType ** ptr) noexcept auto media_startup () noexcept void print (gsl::not_null< IMFActivate *> device) noexcept print description for the media_type with logging void print (gsl::not_null< IMFMediaType *> media_type) noexcept print description for the media_type with logging void print (gsl::not_null< IMFTransform *> transform, const GUID & iid) noexcept print description for the media_type with logging auto process (com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSample > input_sample, com_ptr< IMFMediaType > output_type, HRESULT & ec) noexcept auto process (com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSourceReader > source_reader, HRESULT & ec) auto read_samples (com_ptr< IMFSourceReader > source_reader, DWORD & index, DWORD & flags, LONGLONG & timestamp, LONGLONG & duration) noexcept HRESULT resolve (const fs::path & fpath, IMFMediaSourceEx ** source, MF_OBJECT_TYPE & media_object_type) noexcept winrt::hstring to_hstring (const GUID & guid) noexcept std::string to_readable (const GUID & guid) noexcept std::string to_string (const GUID & guid) noexcept auto try_input_available_types (com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index) noexcept auto try_output_available_types (com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index) noexcept HRESULT try_output_type (com_ptr< IMFTransform > transform, DWORD ostream, const GUID & desired, IMFMediaType ** output_type) noexcept Public Functions Documentation function configure HRESULT configure ( com_ptr< IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video function configure_D3D11_DXGI HRESULT configure_D3D11_DXGI ( gsl::not_null< IMFTransform *> transform, IMFDXGIDeviceManager * device_manager ) noexcept Returns: E_NOTIMPL, E_FAIL ... See also: https://docs.microsoft.com/en-us/windows/win32/medfound/hardware-mfts function configure_acceleration_H264 HRESULT configure_acceleration_H264 ( gsl::not_null< IMFTransform *> transform ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder#transform-attributes function configure_destination_rectangle HRESULT configure_destination_rectangle ( gsl::not_null< IPropertyStore *> props, const RECT & rect ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/videoresizer function configure_rectangle HRESULT configure_rectangle ( gsl::not_null< IMFVideoProcessorControl *> control, gsl::not_null< IMFMediaType *> media_type ) noexcept function configure_source_rectangle HRESULT configure_source_rectangle ( gsl::not_null< IPropertyStore *> props, const RECT & rect ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/videoresizer function create_and_copy_single_buffer_sample HRESULT create_and_copy_single_buffer_sample ( IMFSample * src, IMFSample ** dst ) function create_single_buffer_sample HRESULT create_single_buffer_sample ( DWORD bufsz, IMFSample ** sample ) function decode auto decode ( com_ptr< IMFTransform > transform, DWORD ostream, com_ptr< IMFMediaType > output_type, HRESULT & ec ) noexcept function get_devices HRESULT get_devices ( std::vector< com_ptr< IMFActivate >> & devices, IMFAttributes * attributes ) noexcept See also: MFEnumDeviceSources function get_hardware_url HRESULT get_hardware_url ( gsl::not_null< IMFTransform *> transform, winrt::hstring & name ) noexcept function get_input_available_types auto get_input_available_types ( com_ptr< IMFTransform > transform, DWORD num_input, HRESULT & ec ) noexcept function get_name HRESULT get_name ( gsl::not_null< IMFActivate *> device, winrt::hstring & name ) noexcept See also: MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME function get_name HRESULT get_name ( gsl::not_null< IMFActivate *> device, std::wstring & name ) noexcept function get_name HRESULT get_name ( gsl::not_null< IMFActivate *> device, std::string & name ) noexcept function get_output_available_types auto get_output_available_types ( com_ptr< IMFTransform > transform, DWORD num_output, HRESULT & ec ) noexcept function get_stream_descriptor HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr ) function get_string HRESULT get_string ( gsl::not_null< IMFAttributes *> attribute, const GUID & uuid, winrt::hstring & name ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/api/mfobjects/nf-mfobjects-imfattributes-getstring function get_transform_output HRESULT get_transform_output ( IMFTransform * transform, IMFSample ** sample, BOOL & flushed ) function make_transform_H264 HRESULT make_transform_H264 ( IMFTransform ** transform ) noexcept See also: CoCreateInstance See also: CLSID_CMSH264DecoderMFT See also: https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder function make_transform_video HRESULT make_transform_video ( IMFTransform ** transform, const IID & iid ) noexcept See also: CoCreateInstance See also: Color Converter DSP https://docs.microsoft.com/en-us/windows/win32/medfound/colorconverter Parameters: iid CLSID_CColorConvertDMO Todo test CLSID_OpenCLMFTDx11 function make_transform_video HRESULT make_transform_video ( IMFTransform ** transform ) noexcept See also: CoCreateInstance See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: CLSID_VideoProcessorMFT function make_video_output_RGB32 HRESULT make_video_output_RGB32 ( IMFMediaType ** ptr ) noexcept Todo : configure MF_MT_FRAME_SIZE, MF_MT_FRAME_RATE : configure MF_MT_PIXEL_ASPECT_RATIO function make_video_output_RGB565 HRESULT make_video_output_RGB565 ( IMFMediaType ** ptr ) noexcept function media_startup auto media_startup () noexcept See also: MFStartup See also: MFShutdown Exception: winrt::hresult_error function print void print ( gsl::not_null< IMFActivate *> device ) noexcept Note: the argument is considered immutable See also: https://docs.microsoft.com/en-us/windows/win32/medfound/capture-device-attributes function print void print ( gsl::not_null< IMFMediaType *> media_type ) noexcept Note: the argument is considered immutable See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-subtype-guids See also: https://stackoverflow.com/a/9681384 function print void print ( gsl::not_null< IMFTransform *> transform, const GUID & iid ) noexcept Note: the function may change modify input/output configuration function process auto process ( com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSample > input_sample, com_ptr< IMFMediaType > output_type, HRESULT & ec ) noexcept function process auto process ( com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSourceReader > source_reader, HRESULT & ec ) function read_samples auto read_samples ( com_ptr< IMFSourceReader > source_reader, DWORD & index, DWORD & flags, LONGLONG & timestamp, LONGLONG & duration ) noexcept Todo https://docs.microsoft.com/en-us/windows/win32/medfound/mf-source-reader-enable-advanced-video-processing#remarks function resolve HRESULT resolve ( const fs::path & fpath, IMFMediaSourceEx ** source, MF_OBJECT_TYPE & media_object_type ) noexcept See also: MFCreateSourceResolver function to_hstring winrt::hstring to_hstring ( const GUID & guid ) noexcept function to_readable std::string to_readable ( const GUID & guid ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/wmformat/media-type-identifiers See also: https://docs.microsoft.com/en-us/windows/win32/medfound/media-type-debugging-code function to_string std::string to_string ( const GUID & guid ) noexcept function try_input_available_types auto try_input_available_types ( com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index ) noexcept function try_output_available_types auto try_output_available_types ( com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index ) noexcept function try_output_type HRESULT try_output_type ( com_ptr< IMFTransform > transform, DWORD ostream, const GUID & desired, IMFMediaType ** output_type ) noexcept The documentation for this class was generated from the following file src/media.hpp","title":"File media.hpp"},{"location":"media_8hpp/#file-mediahpp","text":"File List > src > media.hpp Go to the source code of this file. #include <winrt/base.h> #include <experimental/generator> #include <filesystem> #include <gsl/gsl> #include <mfapi.h> #include <mferror.h> #include <mfidl.h> #include <mfreadwrite.h> #include <wmcodecdsp.h>","title":"File media.hpp"},{"location":"media_8hpp/#classes","text":"Type Name class qpc_timer_t","title":"Classes"},{"location":"media_8hpp/#public-functions","text":"Type Name HRESULT configure (com_ptr< IMFStreamDescriptor > stream) noexcept HRESULT configure_D3D11_DXGI (gsl::not_null< IMFTransform *> transform, IMFDXGIDeviceManager * device_manager) noexcept configure D3D11 if the transform supports it HRESULT configure_acceleration_H264 (gsl::not_null< IMFTransform *> transform) noexcept HRESULT configure_destination_rectangle (gsl::not_null< IPropertyStore *> props, const RECT & rect) noexcept HRESULT configure_rectangle (gsl::not_null< IMFVideoProcessorControl *> control, gsl::not_null< IMFMediaType *> media_type) noexcept exactly same sized src/dst rectangle; HRESULT configure_source_rectangle (gsl::not_null< IPropertyStore *> props, const RECT & rect) noexcept HRESULT create_and_copy_single_buffer_sample (IMFSample * src, IMFSample ** dst) HRESULT create_single_buffer_sample (DWORD bufsz, IMFSample ** sample) auto decode (com_ptr< IMFTransform > transform, DWORD ostream, com_ptr< IMFMediaType > output_type, HRESULT & ec) noexcept HRESULT get_devices (std::vector< com_ptr< IMFActivate >> & devices, IMFAttributes * attributes) noexcept HRESULT get_hardware_url (gsl::not_null< IMFTransform *> transform, winrt::hstring & name) noexcept auto get_input_available_types (com_ptr< IMFTransform > transform, DWORD num_input, HRESULT & ec) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, winrt::hstring & name) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, std::wstring & name) noexcept HRESULT get_name (gsl::not_null< IMFActivate *> device, std::string & name) noexcept auto get_output_available_types (com_ptr< IMFTransform > transform, DWORD num_output, HRESULT & ec) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) HRESULT get_string (gsl::not_null< IMFAttributes *> attribute, const GUID & uuid, winrt::hstring & name) noexcept HRESULT get_transform_output (IMFTransform * transform, IMFSample ** sample, BOOL & flushed) HRESULT make_transform_H264 (IMFTransform ** transform) noexcept HRESULT make_transform_video (IMFTransform ** transform, const IID & iid) noexcept HRESULT make_transform_video (IMFTransform ** transform) noexcept HRESULT make_video_output_RGB32 (IMFMediaType ** ptr) noexcept HRESULT make_video_output_RGB565 (IMFMediaType ** ptr) noexcept auto media_startup () noexcept void print (gsl::not_null< IMFActivate *> device) noexcept print description for the media_type with logging void print (gsl::not_null< IMFMediaType *> media_type) noexcept print description for the media_type with logging void print (gsl::not_null< IMFTransform *> transform, const GUID & iid) noexcept print description for the media_type with logging auto process (com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSample > input_sample, com_ptr< IMFMediaType > output_type, HRESULT & ec) noexcept auto process (com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSourceReader > source_reader, HRESULT & ec) auto read_samples (com_ptr< IMFSourceReader > source_reader, DWORD & index, DWORD & flags, LONGLONG & timestamp, LONGLONG & duration) noexcept HRESULT resolve (const fs::path & fpath, IMFMediaSourceEx ** source, MF_OBJECT_TYPE & media_object_type) noexcept winrt::hstring to_hstring (const GUID & guid) noexcept std::string to_readable (const GUID & guid) noexcept std::string to_string (const GUID & guid) noexcept auto try_input_available_types (com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index) noexcept auto try_output_available_types (com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index) noexcept HRESULT try_output_type (com_ptr< IMFTransform > transform, DWORD ostream, const GUID & desired, IMFMediaType ** output_type) noexcept","title":"Public Functions"},{"location":"media_8hpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"media_8hpp/#function-configure","text":"HRESULT configure ( com_ptr< IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video","title":"function configure"},{"location":"media_8hpp/#function-configure_d3d11_dxgi","text":"HRESULT configure_D3D11_DXGI ( gsl::not_null< IMFTransform *> transform, IMFDXGIDeviceManager * device_manager ) noexcept Returns: E_NOTIMPL, E_FAIL ... See also: https://docs.microsoft.com/en-us/windows/win32/medfound/hardware-mfts","title":"function configure_D3D11_DXGI"},{"location":"media_8hpp/#function-configure_acceleration_h264","text":"HRESULT configure_acceleration_H264 ( gsl::not_null< IMFTransform *> transform ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder#transform-attributes","title":"function configure_acceleration_H264"},{"location":"media_8hpp/#function-configure_destination_rectangle","text":"HRESULT configure_destination_rectangle ( gsl::not_null< IPropertyStore *> props, const RECT & rect ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/videoresizer","title":"function configure_destination_rectangle"},{"location":"media_8hpp/#function-configure_rectangle","text":"HRESULT configure_rectangle ( gsl::not_null< IMFVideoProcessorControl *> control, gsl::not_null< IMFMediaType *> media_type ) noexcept","title":"function configure_rectangle"},{"location":"media_8hpp/#function-configure_source_rectangle","text":"HRESULT configure_source_rectangle ( gsl::not_null< IPropertyStore *> props, const RECT & rect ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/videoresizer","title":"function configure_source_rectangle"},{"location":"media_8hpp/#function-create_and_copy_single_buffer_sample","text":"HRESULT create_and_copy_single_buffer_sample ( IMFSample * src, IMFSample ** dst )","title":"function create_and_copy_single_buffer_sample"},{"location":"media_8hpp/#function-create_single_buffer_sample","text":"HRESULT create_single_buffer_sample ( DWORD bufsz, IMFSample ** sample )","title":"function create_single_buffer_sample"},{"location":"media_8hpp/#function-decode","text":"auto decode ( com_ptr< IMFTransform > transform, DWORD ostream, com_ptr< IMFMediaType > output_type, HRESULT & ec ) noexcept","title":"function decode"},{"location":"media_8hpp/#function-get_devices","text":"HRESULT get_devices ( std::vector< com_ptr< IMFActivate >> & devices, IMFAttributes * attributes ) noexcept See also: MFEnumDeviceSources","title":"function get_devices"},{"location":"media_8hpp/#function-get_hardware_url","text":"HRESULT get_hardware_url ( gsl::not_null< IMFTransform *> transform, winrt::hstring & name ) noexcept","title":"function get_hardware_url"},{"location":"media_8hpp/#function-get_input_available_types","text":"auto get_input_available_types ( com_ptr< IMFTransform > transform, DWORD num_input, HRESULT & ec ) noexcept","title":"function get_input_available_types"},{"location":"media_8hpp/#function-get_name","text":"HRESULT get_name ( gsl::not_null< IMFActivate *> device, winrt::hstring & name ) noexcept See also: MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME","title":"function get_name"},{"location":"media_8hpp/#function-get_name_1","text":"HRESULT get_name ( gsl::not_null< IMFActivate *> device, std::wstring & name ) noexcept","title":"function get_name"},{"location":"media_8hpp/#function-get_name_2","text":"HRESULT get_name ( gsl::not_null< IMFActivate *> device, std::string & name ) noexcept","title":"function get_name"},{"location":"media_8hpp/#function-get_output_available_types","text":"auto get_output_available_types ( com_ptr< IMFTransform > transform, DWORD num_output, HRESULT & ec ) noexcept","title":"function get_output_available_types"},{"location":"media_8hpp/#function-get_stream_descriptor","text":"HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr )","title":"function get_stream_descriptor"},{"location":"media_8hpp/#function-get_string","text":"HRESULT get_string ( gsl::not_null< IMFAttributes *> attribute, const GUID & uuid, winrt::hstring & name ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/api/mfobjects/nf-mfobjects-imfattributes-getstring","title":"function get_string"},{"location":"media_8hpp/#function-get_transform_output","text":"HRESULT get_transform_output ( IMFTransform * transform, IMFSample ** sample, BOOL & flushed )","title":"function get_transform_output"},{"location":"media_8hpp/#function-make_transform_h264","text":"HRESULT make_transform_H264 ( IMFTransform ** transform ) noexcept See also: CoCreateInstance See also: CLSID_CMSH264DecoderMFT See also: https://docs.microsoft.com/en-us/windows/win32/medfound/h-264-video-decoder","title":"function make_transform_H264"},{"location":"media_8hpp/#function-make_transform_video","text":"HRESULT make_transform_video ( IMFTransform ** transform, const IID & iid ) noexcept See also: CoCreateInstance See also: Color Converter DSP https://docs.microsoft.com/en-us/windows/win32/medfound/colorconverter Parameters: iid CLSID_CColorConvertDMO Todo test CLSID_OpenCLMFTDx11","title":"function make_transform_video"},{"location":"media_8hpp/#function-make_transform_video_1","text":"HRESULT make_transform_video ( IMFTransform ** transform ) noexcept See also: CoCreateInstance See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: CLSID_VideoProcessorMFT","title":"function make_transform_video"},{"location":"media_8hpp/#function-make_video_output_rgb32","text":"HRESULT make_video_output_RGB32 ( IMFMediaType ** ptr ) noexcept Todo : configure MF_MT_FRAME_SIZE, MF_MT_FRAME_RATE : configure MF_MT_PIXEL_ASPECT_RATIO","title":"function make_video_output_RGB32"},{"location":"media_8hpp/#function-make_video_output_rgb565","text":"HRESULT make_video_output_RGB565 ( IMFMediaType ** ptr ) noexcept","title":"function make_video_output_RGB565"},{"location":"media_8hpp/#function-media_startup","text":"auto media_startup () noexcept See also: MFStartup See also: MFShutdown Exception: winrt::hresult_error","title":"function media_startup"},{"location":"media_8hpp/#function-print","text":"void print ( gsl::not_null< IMFActivate *> device ) noexcept Note: the argument is considered immutable See also: https://docs.microsoft.com/en-us/windows/win32/medfound/capture-device-attributes","title":"function print"},{"location":"media_8hpp/#function-print_1","text":"void print ( gsl::not_null< IMFMediaType *> media_type ) noexcept Note: the argument is considered immutable See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-subtype-guids See also: https://stackoverflow.com/a/9681384","title":"function print"},{"location":"media_8hpp/#function-print_2","text":"void print ( gsl::not_null< IMFTransform *> transform, const GUID & iid ) noexcept Note: the function may change modify input/output configuration","title":"function print"},{"location":"media_8hpp/#function-process","text":"auto process ( com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSample > input_sample, com_ptr< IMFMediaType > output_type, HRESULT & ec ) noexcept","title":"function process"},{"location":"media_8hpp/#function-process_1","text":"auto process ( com_ptr< IMFTransform > transform, DWORD istream, DWORD ostream, com_ptr< IMFSourceReader > source_reader, HRESULT & ec )","title":"function process"},{"location":"media_8hpp/#function-read_samples","text":"auto read_samples ( com_ptr< IMFSourceReader > source_reader, DWORD & index, DWORD & flags, LONGLONG & timestamp, LONGLONG & duration ) noexcept Todo https://docs.microsoft.com/en-us/windows/win32/medfound/mf-source-reader-enable-advanced-video-processing#remarks","title":"function read_samples"},{"location":"media_8hpp/#function-resolve","text":"HRESULT resolve ( const fs::path & fpath, IMFMediaSourceEx ** source, MF_OBJECT_TYPE & media_object_type ) noexcept See also: MFCreateSourceResolver","title":"function resolve"},{"location":"media_8hpp/#function-to_hstring","text":"winrt::hstring to_hstring ( const GUID & guid ) noexcept","title":"function to_hstring"},{"location":"media_8hpp/#function-to_readable","text":"std::string to_readable ( const GUID & guid ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/wmformat/media-type-identifiers See also: https://docs.microsoft.com/en-us/windows/win32/medfound/media-type-debugging-code","title":"function to_readable"},{"location":"media_8hpp/#function-to_string","text":"std::string to_string ( const GUID & guid ) noexcept","title":"function to_string"},{"location":"media_8hpp/#function-try_input_available_types","text":"auto try_input_available_types ( com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index ) noexcept","title":"function try_input_available_types"},{"location":"media_8hpp/#function-try_output_available_types","text":"auto try_output_available_types ( com_ptr< IMFTransform > transform, DWORD stream_id, DWORD & type_index ) noexcept","title":"function try_output_available_types"},{"location":"media_8hpp/#function-try_output_type","text":"HRESULT try_output_type ( com_ptr< IMFTransform > transform, DWORD ostream, const GUID & desired, IMFMediaType ** output_type ) noexcept The documentation for this class was generated from the following file src/media.hpp","title":"function try_output_type"},{"location":"media_8hpp_source/","text":"File media.hpp File List > src > media.hpp Go to the documentation of this file. #pragma once #include <winrt/base.h> #include <experimental/generator> #include <filesystem> #include <gsl/gsl> #include <mfapi.h> #include <mferror.h> #include <mfidl.h> #include <mfreadwrite.h> #include <wmcodecdsp.h> // C++ 17 Coroutines TS using std::experimental::generator; // replaces Microsoft::WRL::ComPtr. see https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/move-to-winrt-from-wrl using winrt::com_ptr; namespace fs = std::filesystem; auto media_startup() noexcept(false) -> gsl::final_action<HRESULT(WINAPI*)()>; HRESULT get_devices(std::vector<com_ptr<IMFActivate>>& devices, IMFAttributes* attributes) noexcept; HRESULT get_string(gsl::not_null<IMFAttributes*> attribute, const GUID& uuid, winrt::hstring& name) noexcept; HRESULT get_name(gsl::not_null<IMFActivate*> device, winrt::hstring& name) noexcept; [[deprecated]] HRESULT get_name(gsl::not_null<IMFActivate*> device, std::wstring& name) noexcept; [[deprecated]] HRESULT get_name(gsl::not_null<IMFActivate*> device, std::string& name) noexcept; HRESULT get_hardware_url(gsl::not_null<IMFTransform*> transform, winrt::hstring& name) noexcept; HRESULT resolve(const fs::path& fpath, IMFMediaSourceEx** source, MF_OBJECT_TYPE& media_object_type) noexcept; HRESULT make_transform_video(IMFTransform** transform, const IID& iid) noexcept; [[deprecated]] HRESULT make_transform_H264(IMFTransform** transform) noexcept; HRESULT configure_acceleration_H264(gsl::not_null<IMFTransform*> transform) noexcept; [[deprecated]] HRESULT make_transform_video(IMFTransform** transform) noexcept; HRESULT configure_D3D11_DXGI(gsl::not_null<IMFTransform*> transform, IMFDXGIDeviceManager* device_manager) noexcept; HRESULT configure_rectangle(gsl::not_null<IMFVideoProcessorControl*> control, gsl::not_null<IMFMediaType*> media_type) noexcept; HRESULT configure_source_rectangle(gsl::not_null<IPropertyStore*> props, const RECT& rect) noexcept; HRESULT configure_destination_rectangle(gsl::not_null<IPropertyStore*> props, const RECT& rect) noexcept; HRESULT make_video_output_RGB32(IMFMediaType** ptr) noexcept; HRESULT make_video_output_RGB565(IMFMediaType** ptr) noexcept; HRESULT try_output_type(com_ptr<IMFTransform> transform, DWORD ostream, const GUID& desired, IMFMediaType** output_type) noexcept; auto get_input_available_types(com_ptr<IMFTransform> transform, DWORD num_input, HRESULT& ec) noexcept(false) -> generator<com_ptr<IMFMediaType>>; auto try_output_available_types(com_ptr<IMFTransform> transform, DWORD stream_id, DWORD& type_index) noexcept(false) -> generator<com_ptr<IMFMediaType>>; auto get_output_available_types(com_ptr<IMFTransform> transform, DWORD num_output, HRESULT& ec) noexcept(false) -> generator<com_ptr<IMFMediaType>>; auto try_input_available_types(com_ptr<IMFTransform> transform, DWORD stream_id, DWORD& type_index) noexcept(false) -> generator<com_ptr<IMFMediaType>>; auto read_samples(com_ptr<IMFSourceReader> source_reader, // DWORD& index, DWORD& flags, LONGLONG& timestamp, LONGLONG& duration) noexcept(false) -> generator<com_ptr<IMFSample>>; auto decode(com_ptr<IMFTransform> transform, DWORD ostream, com_ptr<IMFMediaType> output_type, // HRESULT& ec) noexcept -> generator<com_ptr<IMFSample>>; auto process(com_ptr<IMFTransform> transform, DWORD istream, DWORD ostream, // com_ptr<IMFSample> input_sample, com_ptr<IMFMediaType> output_type, // HRESULT& ec) noexcept -> generator<com_ptr<IMFSample>>; auto process(com_ptr<IMFTransform> transform, DWORD istream, DWORD ostream, // com_ptr<IMFSourceReader> source_reader, // HRESULT& ec) -> generator<com_ptr<IMFSample>>; HRESULT create_single_buffer_sample(DWORD bufsz, IMFSample** sample); HRESULT create_and_copy_single_buffer_sample(IMFSample* src, IMFSample** dst); HRESULT get_transform_output(IMFTransform* transform, IMFSample** sample, BOOL& flushed); HRESULT get_stream_descriptor(IMFPresentationDescriptor* presentation, IMFStreamDescriptor** ptr); HRESULT configure(com_ptr<IMFStreamDescriptor> stream) noexcept; class qpc_timer_t final { LARGE_INTEGER start{}; LARGE_INTEGER frequency{}; public: qpc_timer_t() noexcept { QueryPerformanceFrequency(&frequency); QueryPerformanceCounter(&start); } auto pick() const noexcept { LARGE_INTEGER end{}; QueryPerformanceCounter(&end); const auto elapsed = end.QuadPart - start.QuadPart; return (elapsed * 1'000) / frequency.QuadPart; } auto reset() noexcept { auto d = pick(); QueryPerformanceCounter(&start); return d; } }; std::string to_string(const GUID& guid) noexcept; std::string to_readable(const GUID& guid) noexcept; winrt::hstring to_hstring(const GUID& guid) noexcept; void print(gsl::not_null<IMFActivate*> device) noexcept; void print(gsl::not_null<IMFMediaType*> media_type) noexcept; void print(gsl::not_null<IMFTransform*> transform, const GUID& iid) noexcept;","title":"File media.hpp"},{"location":"media_8hpp_source/#file-mediahpp","text":"File List > src > media.hpp Go to the documentation of this file. #pragma once #include <winrt/base.h> #include <experimental/generator> #include <filesystem> #include <gsl/gsl> #include <mfapi.h> #include <mferror.h> #include <mfidl.h> #include <mfreadwrite.h> #include <wmcodecdsp.h> // C++ 17 Coroutines TS using std::experimental::generator; // replaces Microsoft::WRL::ComPtr. see https://docs.microsoft.com/en-us/windows/uwp/cpp-and-winrt-apis/move-to-winrt-from-wrl using winrt::com_ptr; namespace fs = std::filesystem; auto media_startup() noexcept(false) -> gsl::final_action<HRESULT(WINAPI*)()>; HRESULT get_devices(std::vector<com_ptr<IMFActivate>>& devices, IMFAttributes* attributes) noexcept; HRESULT get_string(gsl::not_null<IMFAttributes*> attribute, const GUID& uuid, winrt::hstring& name) noexcept; HRESULT get_name(gsl::not_null<IMFActivate*> device, winrt::hstring& name) noexcept; [[deprecated]] HRESULT get_name(gsl::not_null<IMFActivate*> device, std::wstring& name) noexcept; [[deprecated]] HRESULT get_name(gsl::not_null<IMFActivate*> device, std::string& name) noexcept; HRESULT get_hardware_url(gsl::not_null<IMFTransform*> transform, winrt::hstring& name) noexcept; HRESULT resolve(const fs::path& fpath, IMFMediaSourceEx** source, MF_OBJECT_TYPE& media_object_type) noexcept; HRESULT make_transform_video(IMFTransform** transform, const IID& iid) noexcept; [[deprecated]] HRESULT make_transform_H264(IMFTransform** transform) noexcept; HRESULT configure_acceleration_H264(gsl::not_null<IMFTransform*> transform) noexcept; [[deprecated]] HRESULT make_transform_video(IMFTransform** transform) noexcept; HRESULT configure_D3D11_DXGI(gsl::not_null<IMFTransform*> transform, IMFDXGIDeviceManager* device_manager) noexcept; HRESULT configure_rectangle(gsl::not_null<IMFVideoProcessorControl*> control, gsl::not_null<IMFMediaType*> media_type) noexcept; HRESULT configure_source_rectangle(gsl::not_null<IPropertyStore*> props, const RECT& rect) noexcept; HRESULT configure_destination_rectangle(gsl::not_null<IPropertyStore*> props, const RECT& rect) noexcept; HRESULT make_video_output_RGB32(IMFMediaType** ptr) noexcept; HRESULT make_video_output_RGB565(IMFMediaType** ptr) noexcept; HRESULT try_output_type(com_ptr<IMFTransform> transform, DWORD ostream, const GUID& desired, IMFMediaType** output_type) noexcept; auto get_input_available_types(com_ptr<IMFTransform> transform, DWORD num_input, HRESULT& ec) noexcept(false) -> generator<com_ptr<IMFMediaType>>; auto try_output_available_types(com_ptr<IMFTransform> transform, DWORD stream_id, DWORD& type_index) noexcept(false) -> generator<com_ptr<IMFMediaType>>; auto get_output_available_types(com_ptr<IMFTransform> transform, DWORD num_output, HRESULT& ec) noexcept(false) -> generator<com_ptr<IMFMediaType>>; auto try_input_available_types(com_ptr<IMFTransform> transform, DWORD stream_id, DWORD& type_index) noexcept(false) -> generator<com_ptr<IMFMediaType>>; auto read_samples(com_ptr<IMFSourceReader> source_reader, // DWORD& index, DWORD& flags, LONGLONG& timestamp, LONGLONG& duration) noexcept(false) -> generator<com_ptr<IMFSample>>; auto decode(com_ptr<IMFTransform> transform, DWORD ostream, com_ptr<IMFMediaType> output_type, // HRESULT& ec) noexcept -> generator<com_ptr<IMFSample>>; auto process(com_ptr<IMFTransform> transform, DWORD istream, DWORD ostream, // com_ptr<IMFSample> input_sample, com_ptr<IMFMediaType> output_type, // HRESULT& ec) noexcept -> generator<com_ptr<IMFSample>>; auto process(com_ptr<IMFTransform> transform, DWORD istream, DWORD ostream, // com_ptr<IMFSourceReader> source_reader, // HRESULT& ec) -> generator<com_ptr<IMFSample>>; HRESULT create_single_buffer_sample(DWORD bufsz, IMFSample** sample); HRESULT create_and_copy_single_buffer_sample(IMFSample* src, IMFSample** dst); HRESULT get_transform_output(IMFTransform* transform, IMFSample** sample, BOOL& flushed); HRESULT get_stream_descriptor(IMFPresentationDescriptor* presentation, IMFStreamDescriptor** ptr); HRESULT configure(com_ptr<IMFStreamDescriptor> stream) noexcept; class qpc_timer_t final { LARGE_INTEGER start{}; LARGE_INTEGER frequency{}; public: qpc_timer_t() noexcept { QueryPerformanceFrequency(&frequency); QueryPerformanceCounter(&start); } auto pick() const noexcept { LARGE_INTEGER end{}; QueryPerformanceCounter(&end); const auto elapsed = end.QuadPart - start.QuadPart; return (elapsed * 1'000) / frequency.QuadPart; } auto reset() noexcept { auto d = pick(); QueryPerformanceCounter(&start); return d; } }; std::string to_string(const GUID& guid) noexcept; std::string to_readable(const GUID& guid) noexcept; winrt::hstring to_hstring(const GUID& guid) noexcept; void print(gsl::not_null<IMFActivate*> device) noexcept; void print(gsl::not_null<IMFMediaType*> media_type) noexcept; void print(gsl::not_null<IMFTransform*> transform, const GUID& iid) noexcept;","title":"File media.hpp"},{"location":"media__print_8cpp/","text":"File media_print.cpp File List > src > media_print.cpp Go to the source code of this file. #include \"media.hpp\" #include <dshowasf.h> #include <fmt/format.h> #include <spdlog/spdlog.h> Public Functions Type Name wstring mb2w (string_view in) noexcept void print (gsl::not_null< IMFActivate *> device) noexcept print description for the media_type with logging void print (gsl::not_null< IMFMediaType *> media_type) noexcept print description for the media_type with logging void print (gsl::not_null< IMFTransform *> transform, const GUID & iid) noexcept print description for the media_type with logging void print_CLSID_CColorConvertDMO (gsl::not_null< IMFTransform *> transform, const GUID & iid) noexcept void print_CLSID_CResizerDMO (gsl::not_null< IMFTransform *> transform, const GUID & iid) noexcept winrt::hstring to_hstring (const GUID & guid) noexcept std::string to_readable (const GUID & guid) noexcept std::string to_string (const GUID & guid) noexcept string w2mb (wstring_view in) noexcept Macros Type Name define IF_EQUAL_RETURN (param, val) define SPDLOG_FMT_EXTERNAL Public Functions Documentation function mb2w wstring mb2w ( string_view in ) noexcept function print void print ( gsl::not_null< IMFActivate *> device ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/capture-device-attributes function print void print ( gsl::not_null< IMFMediaType *> media_type ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-subtype-guids See also: https://stackoverflow.com/a/9681384 function print void print ( gsl::not_null< IMFTransform *> transform, const GUID & iid ) noexcept Note: the function may change modify input/output configuration function print_CLSID_CColorConvertDMO void print_CLSID_CColorConvertDMO ( gsl::not_null< IMFTransform *> transform, const GUID & iid ) noexcept function print_CLSID_CResizerDMO void print_CLSID_CResizerDMO ( gsl::not_null< IMFTransform *> transform, const GUID & iid ) noexcept function to_hstring winrt::hstring to_hstring ( const GUID & guid ) noexcept function to_readable std::string to_readable ( const GUID & guid ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/wmformat/media-type-identifiers See also: https://docs.microsoft.com/en-us/windows/win32/medfound/media-type-debugging-code function to_string std::string to_string ( const GUID & guid ) noexcept function w2mb string w2mb ( wstring_view in ) noexcept Macro Definition Documentation define IF_EQUAL_RETURN #define IF_EQUAL_RETURN ( param, val ) if (val == param) \\ return #val define SPDLOG_FMT_EXTERNAL #define SPDLOG_FMT_EXTERNAL The documentation for this class was generated from the following file src/media_print.cpp","title":"File media\\_print.cpp"},{"location":"media__print_8cpp/#file-media_printcpp","text":"File List > src > media_print.cpp Go to the source code of this file. #include \"media.hpp\" #include <dshowasf.h> #include <fmt/format.h> #include <spdlog/spdlog.h>","title":"File media_print.cpp"},{"location":"media__print_8cpp/#public-functions","text":"Type Name wstring mb2w (string_view in) noexcept void print (gsl::not_null< IMFActivate *> device) noexcept print description for the media_type with logging void print (gsl::not_null< IMFMediaType *> media_type) noexcept print description for the media_type with logging void print (gsl::not_null< IMFTransform *> transform, const GUID & iid) noexcept print description for the media_type with logging void print_CLSID_CColorConvertDMO (gsl::not_null< IMFTransform *> transform, const GUID & iid) noexcept void print_CLSID_CResizerDMO (gsl::not_null< IMFTransform *> transform, const GUID & iid) noexcept winrt::hstring to_hstring (const GUID & guid) noexcept std::string to_readable (const GUID & guid) noexcept std::string to_string (const GUID & guid) noexcept string w2mb (wstring_view in) noexcept","title":"Public Functions"},{"location":"media__print_8cpp/#macros","text":"Type Name define IF_EQUAL_RETURN (param, val) define SPDLOG_FMT_EXTERNAL","title":"Macros"},{"location":"media__print_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"media__print_8cpp/#function-mb2w","text":"wstring mb2w ( string_view in ) noexcept","title":"function mb2w"},{"location":"media__print_8cpp/#function-print","text":"void print ( gsl::not_null< IMFActivate *> device ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/capture-device-attributes","title":"function print"},{"location":"media__print_8cpp/#function-print_1","text":"void print ( gsl::not_null< IMFMediaType *> media_type ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-subtype-guids See also: https://stackoverflow.com/a/9681384","title":"function print"},{"location":"media__print_8cpp/#function-print_2","text":"void print ( gsl::not_null< IMFTransform *> transform, const GUID & iid ) noexcept Note: the function may change modify input/output configuration","title":"function print"},{"location":"media__print_8cpp/#function-print_clsid_ccolorconvertdmo","text":"void print_CLSID_CColorConvertDMO ( gsl::not_null< IMFTransform *> transform, const GUID & iid ) noexcept","title":"function print_CLSID_CColorConvertDMO"},{"location":"media__print_8cpp/#function-print_clsid_cresizerdmo","text":"void print_CLSID_CResizerDMO ( gsl::not_null< IMFTransform *> transform, const GUID & iid ) noexcept","title":"function print_CLSID_CResizerDMO"},{"location":"media__print_8cpp/#function-to_hstring","text":"winrt::hstring to_hstring ( const GUID & guid ) noexcept","title":"function to_hstring"},{"location":"media__print_8cpp/#function-to_readable","text":"std::string to_readable ( const GUID & guid ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/wmformat/media-type-identifiers See also: https://docs.microsoft.com/en-us/windows/win32/medfound/media-type-debugging-code","title":"function to_readable"},{"location":"media__print_8cpp/#function-to_string","text":"std::string to_string ( const GUID & guid ) noexcept","title":"function to_string"},{"location":"media__print_8cpp/#function-w2mb","text":"string w2mb ( wstring_view in ) noexcept","title":"function w2mb"},{"location":"media__print_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"media__print_8cpp/#define-if_equal_return","text":"#define IF_EQUAL_RETURN ( param, val ) if (val == param) \\ return #val","title":"define IF_EQUAL_RETURN"},{"location":"media__print_8cpp/#define-spdlog_fmt_external","text":"#define SPDLOG_FMT_EXTERNAL The documentation for this class was generated from the following file src/media_print.cpp","title":"define SPDLOG_FMT_EXTERNAL"},{"location":"media__print_8cpp_source/","text":"File media_print.cpp File List > src > media_print.cpp Go to the documentation of this file. #include \"media.hpp\" #include <dshowasf.h> #include <fmt/format.h> #ifndef SPDLOG_FMT_EXTERNAL #define SPDLOG_FMT_EXTERNAL #endif #include <spdlog/spdlog.h> using namespace std; string w2mb(wstring_view in) noexcept(false) { string out{}; out.reserve(MB_CUR_MAX * in.length()); mbstate_t state{}; for (wchar_t wc : in) { char mb[8]{}; // ensure null-terminated for UTF-8 (maximum 4 byte) const auto len = wcrtomb(mb, wc, &state); out += string_view{mb, len}; } return out; } wstring mb2w(string_view in) noexcept(false) { wstring out{}; out.reserve(in.length()); const char* ptr = in.data(); const char* const end = in.data() + in.length(); mbstate_t state{}; wchar_t wc; while (size_t len = mbrtowc(&wc, ptr, end - ptr, &state)) { if (len == static_cast<size_t>(-1)) // bad encoding throw system_error{errno, system_category(), \"mbrtowc\"}; if (len == static_cast<size_t>(-2)) // valid but incomplete break; // nothing to do more out.push_back(wc); ptr += len; // advance [1...n] } return out; } std::string to_string(const GUID& guid) noexcept { constexpr auto bufsz = 40; wchar_t buf[bufsz]{}; size_t buflen = StringFromGUID2(guid, buf, bufsz); return w2mb({buf + 1, buflen - 3}); // GUID requires 36 characters } winrt::hstring to_hstring(const GUID& guid) noexcept { constexpr auto bufsz = 40; wchar_t buf[bufsz]{}; uint32_t buflen = StringFromGUID2(guid, buf, bufsz); return {buf + 1, buflen - 3}; // GUID requires 36 characters } std::string to_readable(const GUID& guid) noexcept { #ifndef IF_EQUAL_RETURN #define IF_EQUAL_RETURN(param, val) \\ if (val == param) \\ return #val #endif IF_EQUAL_RETURN(guid, MF_MT_MAJOR_TYPE); IF_EQUAL_RETURN(guid, MF_MT_MAJOR_TYPE); IF_EQUAL_RETURN(guid, MF_MT_SUBTYPE); IF_EQUAL_RETURN(guid, MF_MT_ALL_SAMPLES_INDEPENDENT); IF_EQUAL_RETURN(guid, MF_MT_FIXED_SIZE_SAMPLES); IF_EQUAL_RETURN(guid, MF_MT_COMPRESSED); IF_EQUAL_RETURN(guid, MF_MT_SAMPLE_SIZE); IF_EQUAL_RETURN(guid, MF_MT_WRAPPED_TYPE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_NUM_CHANNELS); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_SAMPLES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_AVG_BYTES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_BLOCK_ALIGNMENT); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_BITS_PER_SAMPLE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_VALID_BITS_PER_SAMPLE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_SAMPLES_PER_BLOCK); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_CHANNEL_MASK); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_FOLDDOWN_MATRIX); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_PEAKREF); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_PEAKTARGET); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_AVGREF); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_AVGTARGET); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_PREFER_WAVEFORMATEX); IF_EQUAL_RETURN(guid, MF_MT_AAC_PAYLOAD_TYPE); IF_EQUAL_RETURN(guid, MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION); IF_EQUAL_RETURN(guid, MF_MT_FRAME_SIZE); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE_RANGE_MAX); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE_RANGE_MIN); IF_EQUAL_RETURN(guid, MF_MT_PIXEL_ASPECT_RATIO); IF_EQUAL_RETURN(guid, MF_MT_DRM_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_PAD_CONTROL_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_SOURCE_CONTENT_HINT); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_CHROMA_SITING); IF_EQUAL_RETURN(guid, MF_MT_INTERLACE_MODE); IF_EQUAL_RETURN(guid, MF_MT_TRANSFER_FUNCTION); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_PRIMARIES); IF_EQUAL_RETURN(guid, MF_MT_CUSTOM_VIDEO_PRIMARIES); IF_EQUAL_RETURN(guid, MF_MT_YUV_MATRIX); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_LIGHTING); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_NOMINAL_RANGE); IF_EQUAL_RETURN(guid, MF_MT_GEOMETRIC_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_MINIMUM_DISPLAY_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_PAN_SCAN_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_PAN_SCAN_ENABLED); IF_EQUAL_RETURN(guid, MF_MT_AVG_BITRATE); IF_EQUAL_RETURN(guid, MF_MT_AVG_BIT_ERROR_RATE); IF_EQUAL_RETURN(guid, MF_MT_MAX_KEYFRAME_SPACING); IF_EQUAL_RETURN(guid, MF_MT_DEFAULT_STRIDE); IF_EQUAL_RETURN(guid, MF_MT_PALETTE); IF_EQUAL_RETURN(guid, MF_MT_USER_DATA); IF_EQUAL_RETURN(guid, MF_MT_AM_FORMAT_TYPE); IF_EQUAL_RETURN(guid, MF_MT_MPEG_START_TIME_CODE); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_PROFILE); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_LEVEL); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_MPEG_SEQUENCE_HEADER); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_SRC_PACK_0); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_CTRL_PACK_0); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_SRC_PACK_1); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_CTRL_PACK_1); IF_EQUAL_RETURN(guid, MF_MT_DV_VAUX_SRC_PACK); IF_EQUAL_RETURN(guid, MF_MT_DV_VAUX_CTRL_PACK); IF_EQUAL_RETURN(guid, MF_MT_ARBITRARY_HEADER); IF_EQUAL_RETURN(guid, MF_MT_ARBITRARY_FORMAT); IF_EQUAL_RETURN(guid, MF_MT_IMAGE_LOSS_TOLERANT); IF_EQUAL_RETURN(guid, MF_MT_MPEG4_SAMPLE_DESCRIPTION); IF_EQUAL_RETURN(guid, MF_MT_MPEG4_CURRENT_SAMPLE_ENTRY); IF_EQUAL_RETURN(guid, MF_MT_ORIGINAL_4CC); IF_EQUAL_RETURN(guid, MF_MT_ORIGINAL_WAVE_FORMAT_TAG); // MF_MT_MAJOR_TYPE IF_EQUAL_RETURN(guid, MFMediaType_Audio); IF_EQUAL_RETURN(guid, MFMediaType_Video); IF_EQUAL_RETURN(guid, MFMediaType_Protected); IF_EQUAL_RETURN(guid, MFMediaType_SAMI); IF_EQUAL_RETURN(guid, MFMediaType_Script); IF_EQUAL_RETURN(guid, MFMediaType_Image); IF_EQUAL_RETURN(guid, MFMediaType_HTML); IF_EQUAL_RETURN(guid, MFMediaType_Binary); IF_EQUAL_RETURN(guid, MFMediaType_FileTransfer); // subtype IF_EQUAL_RETURN(guid, MFVideoFormat_AI44); // FCC('AI44') IF_EQUAL_RETURN(guid, MFVideoFormat_ARGB32); // D3DFMT_A8R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_AYUV); // FCC('AYUV') IF_EQUAL_RETURN(guid, MFVideoFormat_DV25); // FCC('dv25') IF_EQUAL_RETURN(guid, MFVideoFormat_DV50); // FCC('dv50') IF_EQUAL_RETURN(guid, MFVideoFormat_DVH1); // FCC('dvh1') IF_EQUAL_RETURN(guid, MFVideoFormat_DVSD); // FCC('dvsd') IF_EQUAL_RETURN(guid, MFVideoFormat_DVSL); // FCC('dvsl') IF_EQUAL_RETURN(guid, MFVideoFormat_H264); // FCC('H264') IF_EQUAL_RETURN(guid, MFVideoFormat_H264_ES); // IF_EQUAL_RETURN(guid, MFVideoFormat_I420); // FCC('I420') IF_EQUAL_RETURN(guid, MFVideoFormat_IYUV); // FCC('IYUV') IF_EQUAL_RETURN(guid, MFVideoFormat_M4S2); // FCC('M4S2') IF_EQUAL_RETURN(guid, MFVideoFormat_MJPG); IF_EQUAL_RETURN(guid, MFVideoFormat_MP43); // FCC('MP43') IF_EQUAL_RETURN(guid, MFVideoFormat_MP4S); // FCC('MP4S') IF_EQUAL_RETURN(guid, MFVideoFormat_MP4V); // FCC('MP4V') IF_EQUAL_RETURN(guid, MFVideoFormat_MPG1); // FCC('MPG1') IF_EQUAL_RETURN(guid, MFVideoFormat_MSS1); // FCC('MSS1') IF_EQUAL_RETURN(guid, MFVideoFormat_MSS2); // FCC('MSS2') IF_EQUAL_RETURN(guid, MFVideoFormat_NV11); // FCC('NV11') IF_EQUAL_RETURN(guid, MFVideoFormat_NV12); // FCC('NV12') IF_EQUAL_RETURN(guid, MFVideoFormat_P010); // FCC('P010') IF_EQUAL_RETURN(guid, MFVideoFormat_P016); // FCC('P016') IF_EQUAL_RETURN(guid, MFVideoFormat_P210); // FCC('P210') IF_EQUAL_RETURN(guid, MFVideoFormat_P216); // FCC('P216') IF_EQUAL_RETURN(guid, MFVideoFormat_RGB24); // D3DFMT_R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB32); // D3DFMT_X8R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB555); // D3DFMT_X1R5G5B5 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB565); // D3DFMT_R5G6B5 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB8); IF_EQUAL_RETURN(guid, MFVideoFormat_UYVY); // FCC('UYVY') IF_EQUAL_RETURN(guid, MFVideoFormat_v210); // FCC('v210') IF_EQUAL_RETURN(guid, MFVideoFormat_v410); // FCC('v410') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV1); // FCC('WMV1') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV2); // FCC('WMV2') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV3); // FCC('WMV3') IF_EQUAL_RETURN(guid, MFVideoFormat_WVC1); // FCC('WVC1') IF_EQUAL_RETURN(guid, MFVideoFormat_Y210); // FCC('Y210') IF_EQUAL_RETURN(guid, MFVideoFormat_Y216); // FCC('Y216') IF_EQUAL_RETURN(guid, MFVideoFormat_Y410); // FCC('Y410') IF_EQUAL_RETURN(guid, MFVideoFormat_Y416); // FCC('Y416') IF_EQUAL_RETURN(guid, MFVideoFormat_Y41P); IF_EQUAL_RETURN(guid, MFVideoFormat_Y41T); IF_EQUAL_RETURN(guid, MFVideoFormat_YUY2); // FCC('YUY2') IF_EQUAL_RETURN(guid, MFVideoFormat_YV12); // FCC('YV12') IF_EQUAL_RETURN(guid, MFVideoFormat_YVYU); IF_EQUAL_RETURN(guid, MFAudioFormat_PCM); // WAVE_FORMAT_PCM IF_EQUAL_RETURN(guid, MFAudioFormat_Float); // WAVE_FORMAT_IEEE_FLOAT IF_EQUAL_RETURN(guid, MFAudioFormat_DTS); // WAVE_FORMAT_DTS IF_EQUAL_RETURN(guid, MFAudioFormat_Dolby_AC3_SPDIF); // WAVE_FORMAT_DOLBY_AC3_SPDIF IF_EQUAL_RETURN(guid, MFAudioFormat_DRM); // WAVE_FORMAT_DRM IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudioV8); // WAVE_FORMAT_WMAUDIO2 IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudioV9); // WAVE_FORMAT_WMAUDIO3 IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudio_Lossless); // WAVE_FORMAT_WMAUDIO_LOSSLESS IF_EQUAL_RETURN(guid, MFAudioFormat_WMASPDIF); // WAVE_FORMAT_WMASPDIF IF_EQUAL_RETURN(guid, MFAudioFormat_MSP1); // WAVE_FORMAT_WMAVOICE9 IF_EQUAL_RETURN(guid, MFAudioFormat_MP3); // WAVE_FORMAT_MPEGLAYER3 IF_EQUAL_RETURN(guid, MFAudioFormat_MPEG); // WAVE_FORMAT_MPEG IF_EQUAL_RETURN(guid, MFAudioFormat_AAC); // WAVE_FORMAT_MPEG_HEAAC IF_EQUAL_RETURN(guid, MFAudioFormat_ADTS); // WAVE_FORMAT_MPEG_ADTS_AAC #undef IF_EQUAL_RETURN return to_string(guid); // MFVideoFormat_RGB32 // 444 (32 bpp) // MFVideoFormat_ARGB32 // MFVideoFormat_RGB24 // MFVideoFormat_I420 // 420 (16 bpp) // MFVideoFormat_NV12 // 420 (12 bpp) // MFVideoFormat_UYVY // 422 (12 bpp) // MFVideoFormat_MJPG // MFVideoFormat_AI44 // 4:4:4 Packed P // MFVideoFormat_AYUV // 4:4:4 Packed 8 // MFVideoFormat_I420 // 4:2:0 Planar 8 // MFVideoFormat_IYUV // 4:2:0 Planar 8 // MFVideoFormat_NV11 // 4:1:1 Planar 8 // MFVideoFormat_NV12 // 4:2:0 Planar 8 // MFVideoFormat_UYVY // 4:2:2 Packed 8 // MFVideoFormat_Y41P // 4:1:1 Packed 8 // MFVideoFormat_Y41T // 4:1:1 Packed 8 // MFVideoFormat_Y42T // 4:2:2 Packed 8 // MFVideoFormat_YUY2 // 4:2:2 Packed 8 // MFVideoFormat_YVU9 // 8:4:4 Planar 9 // MFVideoFormat_YV12 // 4:2:0 Planar 8 // MFVideoFormat_YVYU // 4:2:2 Packed 8 } void print(gsl::not_null<IMFActivate*> device) noexcept { spdlog::info(\"- device:\"); winrt::hstring txt{}; if SUCCEEDED (get_name(device, txt)) spdlog::info(\" name: {}\", winrt::to_string(txt)); if SUCCEEDED (get_string(device, MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK, txt)) spdlog::debug(\" symlink: '{}'\", winrt::to_string(txt)); UINT32 is_hardware = FALSE; if SUCCEEDED (device->GetUINT32(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_HW_SOURCE, &is_hardware)) spdlog::info(\" hardware: {}\", static_cast<bool>(is_hardware)); UINT32 max_buffers = 0; if SUCCEEDED (device->GetUINT32(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_MAX_BUFFERS, &max_buffers)) spdlog::debug(\" max_buffers: {}\", max_buffers); //UINT32 count = 0; //if SUCCEEDED (device->GetBlobSize(MF_DEVSOURCE_ATTRIBUTE_MEDIA_TYPE, &count)) { // auto types = std::make_unique<MFT_REGISTER_TYPE_INFO[]>(count); // if FAILED (device->GetBlob(MF_DEVSOURCE_ATTRIBUTE_MEDIA_TYPE, reinterpret_cast<UINT8*>(types.get()), count, // &count)) // return; // spdlog::info(\" type_info:\"); // for (auto i = 0u; i < count; ++i) // spdlog::info(\" - {}\", to_readable(types[i].guidSubtype)); // MF_MT_SUBTYPE //} } void print(gsl::not_null<IMFMediaType*> media_type) noexcept { spdlog::info(\"- media_type:\"); GUID major{}; if (auto hr = media_type->GetGUID(MF_MT_MAJOR_TYPE, &major); FAILED(hr)) return spdlog::error(\"type->GetGUID(MF_MT_MAJOR_TYPE): {:#08x}\", hr); if (major == MFMediaType_Video) { GUID subtype{}; if SUCCEEDED (media_type->GetGUID(MF_MT_SUBTYPE, &subtype)) { spdlog::info(\" subtype: {}\", to_readable(subtype)); } UINT32 w = 0, h = 0; if SUCCEEDED (MFGetAttributeSize(media_type, MF_MT_FRAME_SIZE, &w, &h)) { spdlog::info(\" width: {}\", w); spdlog::info(\" height: {}\", h); } UINT32 num = 0, denom = 1; if SUCCEEDED (MFGetAttributeRatio(media_type, MF_MT_FRAME_RATE, &num, &denom)) { spdlog::info(\" fps: {}\", static_cast<float>(num) / denom); } } } void print_CLSID_CResizerDMO(gsl::not_null<IMFTransform*> transform, const GUID& iid) noexcept { spdlog::info(\"- transform:\"); spdlog::info(\" - iid: {}\", to_readable(iid)); DWORD num_input = 0, num_output = 0; if (auto hr = transform->GetStreamCount(&num_input, &num_output); FAILED(hr)) return spdlog::error(\"transform->GetStreamCount: {:#08x}\", hr); DWORD istream = 0, ostream = 0; switch (auto hr = transform->GetStreamIDs(1, &istream, 1, &ostream)) { case E_NOTIMPL: istream = num_input - 1; ostream = num_output - 1; case S_OK: break; default: return spdlog::error(\"transform->GetStreamIDs: {:#08x}\", hr); } auto print = [](IMFMediaType* media_type) { GUID subtype{}; media_type->GetGUID(MF_MT_SUBTYPE, &subtype); spdlog::info(\" subtype: {}\", to_readable(subtype)); UINT32 w = 0, h = 0; if SUCCEEDED (MFGetAttributeSize(media_type, MF_MT_FRAME_SIZE, &w, &h)) { spdlog::info(\" width: {}\", w); spdlog::info(\" height: {}\", h); } UINT32 num = 0, denom = 1; if SUCCEEDED (MFGetAttributeRatio(media_type, MF_MT_FRAME_RATE, &num, &denom)) { spdlog::info(\" fps: {}\", static_cast<float>(num) / denom); } }; com_ptr<IMFMediaType> input{}; if (auto hr = transform->GetInputCurrentType(istream, input.put())) spdlog::error(\"transform->GetInputCurrentType: {:#08x}\", hr); else { spdlog::info(\" - input_type:\"); print(input.get()); } com_ptr<IMFMediaType> output{}; if (auto hr = transform->GetOutputCurrentType(ostream, output.put())) spdlog::error(\"transform->GetOutputCurrentType: {:#08x}\", hr); else { spdlog::info(\" - output_type:\"); print(input.get()); } } void print_CLSID_CColorConvertDMO(gsl::not_null<IMFTransform*> transform, const GUID& iid) noexcept { spdlog::info(\"- transform:\"); spdlog::info(\" - iid: {}\", to_readable(iid)); DWORD num_input = 0; DWORD num_output = 0; if (auto hr = transform->GetStreamCount(&num_input, &num_output); FAILED(hr)) return spdlog::error(\"transform->GetStreamCount: {:#08x}\", hr); auto istreams = std::make_unique<DWORD[]>(num_input); auto ostreams = std::make_unique<DWORD[]>(num_output); if (auto hr = transform->GetStreamIDs(num_input, istreams.get(), num_output, ostreams.get()); FAILED(hr)) spdlog::warn(\"transform->GetStreamCount: {:#08x}\", hr); if (num_input) { spdlog::info(\" - num_input: {}\", num_input); for (auto i = 0u; i < num_input; ++i) { const auto istream = istreams[i]; MFT_INPUT_STREAM_INFO info{}; if (auto hr = transform->GetInputStreamInfo(istream, &info)) { spdlog::error(\"transform->GetInputStreamInfo: {:#08x}\", hr); } else { spdlog::info(\" - input_stream:\"); spdlog::info(\" size: {}\", info.cbSize); spdlog::info(\" alignment: {}\", info.cbAlignment); spdlog::info(\" flags: {}\", info.dwFlags); spdlog::debug(\" max_latency: {}\", info.hnsMaxLatency); } DWORD ostream = ostreams[0]; DWORD output_index = 0; com_ptr<IMFMediaType> output_type{}; for (auto hr = transform->GetOutputAvailableType(ostream, output_index++, output_type.put()); SUCCEEDED(hr); hr = transform->GetOutputAvailableType(ostream, output_index++, output_type.put())) { if (output_index == 1) spdlog::debug(\" output_available_type:\"); GUID subtype{}; output_type->GetGUID(MF_MT_SUBTYPE, &subtype); spdlog::debug(\" - {}\", to_readable(subtype)); output_type = nullptr; } } } if (num_output) { spdlog::info(\" - num_output: {}\", num_output); for (auto i = 0u; i < num_output; ++i) { const auto ostream = ostreams[i]; MFT_OUTPUT_STREAM_INFO info{}; if (auto hr = transform->GetOutputStreamInfo(ostream, &info)) { spdlog::error(\"transform->GetOutputStreamInfo: {:#08x}\", hr); } else { spdlog::info(\" - output_stream:\"); spdlog::info(\" size: {}\", info.cbSize); spdlog::info(\" alignment: {}\", info.cbAlignment); spdlog::info(\" flags: {}\", info.dwFlags); } } } } void print(gsl::not_null<IMFTransform*> transform, const GUID& iid) noexcept { if (iid == CLSID_CColorConvertDMO) return print_CLSID_CColorConvertDMO(transform, iid); if (iid == CLSID_VideoProcessorMFT) return; if (iid == CLSID_CMSH264DecoderMFT) return; if (iid == CLSID_CResizerDMO) return print_CLSID_CResizerDMO(transform, iid); }","title":"File media\\_print.cpp"},{"location":"media__print_8cpp_source/#file-media_printcpp","text":"File List > src > media_print.cpp Go to the documentation of this file. #include \"media.hpp\" #include <dshowasf.h> #include <fmt/format.h> #ifndef SPDLOG_FMT_EXTERNAL #define SPDLOG_FMT_EXTERNAL #endif #include <spdlog/spdlog.h> using namespace std; string w2mb(wstring_view in) noexcept(false) { string out{}; out.reserve(MB_CUR_MAX * in.length()); mbstate_t state{}; for (wchar_t wc : in) { char mb[8]{}; // ensure null-terminated for UTF-8 (maximum 4 byte) const auto len = wcrtomb(mb, wc, &state); out += string_view{mb, len}; } return out; } wstring mb2w(string_view in) noexcept(false) { wstring out{}; out.reserve(in.length()); const char* ptr = in.data(); const char* const end = in.data() + in.length(); mbstate_t state{}; wchar_t wc; while (size_t len = mbrtowc(&wc, ptr, end - ptr, &state)) { if (len == static_cast<size_t>(-1)) // bad encoding throw system_error{errno, system_category(), \"mbrtowc\"}; if (len == static_cast<size_t>(-2)) // valid but incomplete break; // nothing to do more out.push_back(wc); ptr += len; // advance [1...n] } return out; } std::string to_string(const GUID& guid) noexcept { constexpr auto bufsz = 40; wchar_t buf[bufsz]{}; size_t buflen = StringFromGUID2(guid, buf, bufsz); return w2mb({buf + 1, buflen - 3}); // GUID requires 36 characters } winrt::hstring to_hstring(const GUID& guid) noexcept { constexpr auto bufsz = 40; wchar_t buf[bufsz]{}; uint32_t buflen = StringFromGUID2(guid, buf, bufsz); return {buf + 1, buflen - 3}; // GUID requires 36 characters } std::string to_readable(const GUID& guid) noexcept { #ifndef IF_EQUAL_RETURN #define IF_EQUAL_RETURN(param, val) \\ if (val == param) \\ return #val #endif IF_EQUAL_RETURN(guid, MF_MT_MAJOR_TYPE); IF_EQUAL_RETURN(guid, MF_MT_MAJOR_TYPE); IF_EQUAL_RETURN(guid, MF_MT_SUBTYPE); IF_EQUAL_RETURN(guid, MF_MT_ALL_SAMPLES_INDEPENDENT); IF_EQUAL_RETURN(guid, MF_MT_FIXED_SIZE_SAMPLES); IF_EQUAL_RETURN(guid, MF_MT_COMPRESSED); IF_EQUAL_RETURN(guid, MF_MT_SAMPLE_SIZE); IF_EQUAL_RETURN(guid, MF_MT_WRAPPED_TYPE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_NUM_CHANNELS); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_SAMPLES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_AVG_BYTES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_BLOCK_ALIGNMENT); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_BITS_PER_SAMPLE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_VALID_BITS_PER_SAMPLE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_SAMPLES_PER_BLOCK); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_CHANNEL_MASK); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_FOLDDOWN_MATRIX); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_PEAKREF); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_PEAKTARGET); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_AVGREF); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_AVGTARGET); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_PREFER_WAVEFORMATEX); IF_EQUAL_RETURN(guid, MF_MT_AAC_PAYLOAD_TYPE); IF_EQUAL_RETURN(guid, MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION); IF_EQUAL_RETURN(guid, MF_MT_FRAME_SIZE); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE_RANGE_MAX); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE_RANGE_MIN); IF_EQUAL_RETURN(guid, MF_MT_PIXEL_ASPECT_RATIO); IF_EQUAL_RETURN(guid, MF_MT_DRM_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_PAD_CONTROL_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_SOURCE_CONTENT_HINT); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_CHROMA_SITING); IF_EQUAL_RETURN(guid, MF_MT_INTERLACE_MODE); IF_EQUAL_RETURN(guid, MF_MT_TRANSFER_FUNCTION); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_PRIMARIES); IF_EQUAL_RETURN(guid, MF_MT_CUSTOM_VIDEO_PRIMARIES); IF_EQUAL_RETURN(guid, MF_MT_YUV_MATRIX); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_LIGHTING); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_NOMINAL_RANGE); IF_EQUAL_RETURN(guid, MF_MT_GEOMETRIC_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_MINIMUM_DISPLAY_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_PAN_SCAN_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_PAN_SCAN_ENABLED); IF_EQUAL_RETURN(guid, MF_MT_AVG_BITRATE); IF_EQUAL_RETURN(guid, MF_MT_AVG_BIT_ERROR_RATE); IF_EQUAL_RETURN(guid, MF_MT_MAX_KEYFRAME_SPACING); IF_EQUAL_RETURN(guid, MF_MT_DEFAULT_STRIDE); IF_EQUAL_RETURN(guid, MF_MT_PALETTE); IF_EQUAL_RETURN(guid, MF_MT_USER_DATA); IF_EQUAL_RETURN(guid, MF_MT_AM_FORMAT_TYPE); IF_EQUAL_RETURN(guid, MF_MT_MPEG_START_TIME_CODE); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_PROFILE); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_LEVEL); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_MPEG_SEQUENCE_HEADER); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_SRC_PACK_0); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_CTRL_PACK_0); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_SRC_PACK_1); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_CTRL_PACK_1); IF_EQUAL_RETURN(guid, MF_MT_DV_VAUX_SRC_PACK); IF_EQUAL_RETURN(guid, MF_MT_DV_VAUX_CTRL_PACK); IF_EQUAL_RETURN(guid, MF_MT_ARBITRARY_HEADER); IF_EQUAL_RETURN(guid, MF_MT_ARBITRARY_FORMAT); IF_EQUAL_RETURN(guid, MF_MT_IMAGE_LOSS_TOLERANT); IF_EQUAL_RETURN(guid, MF_MT_MPEG4_SAMPLE_DESCRIPTION); IF_EQUAL_RETURN(guid, MF_MT_MPEG4_CURRENT_SAMPLE_ENTRY); IF_EQUAL_RETURN(guid, MF_MT_ORIGINAL_4CC); IF_EQUAL_RETURN(guid, MF_MT_ORIGINAL_WAVE_FORMAT_TAG); // MF_MT_MAJOR_TYPE IF_EQUAL_RETURN(guid, MFMediaType_Audio); IF_EQUAL_RETURN(guid, MFMediaType_Video); IF_EQUAL_RETURN(guid, MFMediaType_Protected); IF_EQUAL_RETURN(guid, MFMediaType_SAMI); IF_EQUAL_RETURN(guid, MFMediaType_Script); IF_EQUAL_RETURN(guid, MFMediaType_Image); IF_EQUAL_RETURN(guid, MFMediaType_HTML); IF_EQUAL_RETURN(guid, MFMediaType_Binary); IF_EQUAL_RETURN(guid, MFMediaType_FileTransfer); // subtype IF_EQUAL_RETURN(guid, MFVideoFormat_AI44); // FCC('AI44') IF_EQUAL_RETURN(guid, MFVideoFormat_ARGB32); // D3DFMT_A8R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_AYUV); // FCC('AYUV') IF_EQUAL_RETURN(guid, MFVideoFormat_DV25); // FCC('dv25') IF_EQUAL_RETURN(guid, MFVideoFormat_DV50); // FCC('dv50') IF_EQUAL_RETURN(guid, MFVideoFormat_DVH1); // FCC('dvh1') IF_EQUAL_RETURN(guid, MFVideoFormat_DVSD); // FCC('dvsd') IF_EQUAL_RETURN(guid, MFVideoFormat_DVSL); // FCC('dvsl') IF_EQUAL_RETURN(guid, MFVideoFormat_H264); // FCC('H264') IF_EQUAL_RETURN(guid, MFVideoFormat_H264_ES); // IF_EQUAL_RETURN(guid, MFVideoFormat_I420); // FCC('I420') IF_EQUAL_RETURN(guid, MFVideoFormat_IYUV); // FCC('IYUV') IF_EQUAL_RETURN(guid, MFVideoFormat_M4S2); // FCC('M4S2') IF_EQUAL_RETURN(guid, MFVideoFormat_MJPG); IF_EQUAL_RETURN(guid, MFVideoFormat_MP43); // FCC('MP43') IF_EQUAL_RETURN(guid, MFVideoFormat_MP4S); // FCC('MP4S') IF_EQUAL_RETURN(guid, MFVideoFormat_MP4V); // FCC('MP4V') IF_EQUAL_RETURN(guid, MFVideoFormat_MPG1); // FCC('MPG1') IF_EQUAL_RETURN(guid, MFVideoFormat_MSS1); // FCC('MSS1') IF_EQUAL_RETURN(guid, MFVideoFormat_MSS2); // FCC('MSS2') IF_EQUAL_RETURN(guid, MFVideoFormat_NV11); // FCC('NV11') IF_EQUAL_RETURN(guid, MFVideoFormat_NV12); // FCC('NV12') IF_EQUAL_RETURN(guid, MFVideoFormat_P010); // FCC('P010') IF_EQUAL_RETURN(guid, MFVideoFormat_P016); // FCC('P016') IF_EQUAL_RETURN(guid, MFVideoFormat_P210); // FCC('P210') IF_EQUAL_RETURN(guid, MFVideoFormat_P216); // FCC('P216') IF_EQUAL_RETURN(guid, MFVideoFormat_RGB24); // D3DFMT_R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB32); // D3DFMT_X8R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB555); // D3DFMT_X1R5G5B5 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB565); // D3DFMT_R5G6B5 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB8); IF_EQUAL_RETURN(guid, MFVideoFormat_UYVY); // FCC('UYVY') IF_EQUAL_RETURN(guid, MFVideoFormat_v210); // FCC('v210') IF_EQUAL_RETURN(guid, MFVideoFormat_v410); // FCC('v410') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV1); // FCC('WMV1') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV2); // FCC('WMV2') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV3); // FCC('WMV3') IF_EQUAL_RETURN(guid, MFVideoFormat_WVC1); // FCC('WVC1') IF_EQUAL_RETURN(guid, MFVideoFormat_Y210); // FCC('Y210') IF_EQUAL_RETURN(guid, MFVideoFormat_Y216); // FCC('Y216') IF_EQUAL_RETURN(guid, MFVideoFormat_Y410); // FCC('Y410') IF_EQUAL_RETURN(guid, MFVideoFormat_Y416); // FCC('Y416') IF_EQUAL_RETURN(guid, MFVideoFormat_Y41P); IF_EQUAL_RETURN(guid, MFVideoFormat_Y41T); IF_EQUAL_RETURN(guid, MFVideoFormat_YUY2); // FCC('YUY2') IF_EQUAL_RETURN(guid, MFVideoFormat_YV12); // FCC('YV12') IF_EQUAL_RETURN(guid, MFVideoFormat_YVYU); IF_EQUAL_RETURN(guid, MFAudioFormat_PCM); // WAVE_FORMAT_PCM IF_EQUAL_RETURN(guid, MFAudioFormat_Float); // WAVE_FORMAT_IEEE_FLOAT IF_EQUAL_RETURN(guid, MFAudioFormat_DTS); // WAVE_FORMAT_DTS IF_EQUAL_RETURN(guid, MFAudioFormat_Dolby_AC3_SPDIF); // WAVE_FORMAT_DOLBY_AC3_SPDIF IF_EQUAL_RETURN(guid, MFAudioFormat_DRM); // WAVE_FORMAT_DRM IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudioV8); // WAVE_FORMAT_WMAUDIO2 IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudioV9); // WAVE_FORMAT_WMAUDIO3 IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudio_Lossless); // WAVE_FORMAT_WMAUDIO_LOSSLESS IF_EQUAL_RETURN(guid, MFAudioFormat_WMASPDIF); // WAVE_FORMAT_WMASPDIF IF_EQUAL_RETURN(guid, MFAudioFormat_MSP1); // WAVE_FORMAT_WMAVOICE9 IF_EQUAL_RETURN(guid, MFAudioFormat_MP3); // WAVE_FORMAT_MPEGLAYER3 IF_EQUAL_RETURN(guid, MFAudioFormat_MPEG); // WAVE_FORMAT_MPEG IF_EQUAL_RETURN(guid, MFAudioFormat_AAC); // WAVE_FORMAT_MPEG_HEAAC IF_EQUAL_RETURN(guid, MFAudioFormat_ADTS); // WAVE_FORMAT_MPEG_ADTS_AAC #undef IF_EQUAL_RETURN return to_string(guid); // MFVideoFormat_RGB32 // 444 (32 bpp) // MFVideoFormat_ARGB32 // MFVideoFormat_RGB24 // MFVideoFormat_I420 // 420 (16 bpp) // MFVideoFormat_NV12 // 420 (12 bpp) // MFVideoFormat_UYVY // 422 (12 bpp) // MFVideoFormat_MJPG // MFVideoFormat_AI44 // 4:4:4 Packed P // MFVideoFormat_AYUV // 4:4:4 Packed 8 // MFVideoFormat_I420 // 4:2:0 Planar 8 // MFVideoFormat_IYUV // 4:2:0 Planar 8 // MFVideoFormat_NV11 // 4:1:1 Planar 8 // MFVideoFormat_NV12 // 4:2:0 Planar 8 // MFVideoFormat_UYVY // 4:2:2 Packed 8 // MFVideoFormat_Y41P // 4:1:1 Packed 8 // MFVideoFormat_Y41T // 4:1:1 Packed 8 // MFVideoFormat_Y42T // 4:2:2 Packed 8 // MFVideoFormat_YUY2 // 4:2:2 Packed 8 // MFVideoFormat_YVU9 // 8:4:4 Planar 9 // MFVideoFormat_YV12 // 4:2:0 Planar 8 // MFVideoFormat_YVYU // 4:2:2 Packed 8 } void print(gsl::not_null<IMFActivate*> device) noexcept { spdlog::info(\"- device:\"); winrt::hstring txt{}; if SUCCEEDED (get_name(device, txt)) spdlog::info(\" name: {}\", winrt::to_string(txt)); if SUCCEEDED (get_string(device, MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_SYMBOLIC_LINK, txt)) spdlog::debug(\" symlink: '{}'\", winrt::to_string(txt)); UINT32 is_hardware = FALSE; if SUCCEEDED (device->GetUINT32(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_HW_SOURCE, &is_hardware)) spdlog::info(\" hardware: {}\", static_cast<bool>(is_hardware)); UINT32 max_buffers = 0; if SUCCEEDED (device->GetUINT32(MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_MAX_BUFFERS, &max_buffers)) spdlog::debug(\" max_buffers: {}\", max_buffers); //UINT32 count = 0; //if SUCCEEDED (device->GetBlobSize(MF_DEVSOURCE_ATTRIBUTE_MEDIA_TYPE, &count)) { // auto types = std::make_unique<MFT_REGISTER_TYPE_INFO[]>(count); // if FAILED (device->GetBlob(MF_DEVSOURCE_ATTRIBUTE_MEDIA_TYPE, reinterpret_cast<UINT8*>(types.get()), count, // &count)) // return; // spdlog::info(\" type_info:\"); // for (auto i = 0u; i < count; ++i) // spdlog::info(\" - {}\", to_readable(types[i].guidSubtype)); // MF_MT_SUBTYPE //} } void print(gsl::not_null<IMFMediaType*> media_type) noexcept { spdlog::info(\"- media_type:\"); GUID major{}; if (auto hr = media_type->GetGUID(MF_MT_MAJOR_TYPE, &major); FAILED(hr)) return spdlog::error(\"type->GetGUID(MF_MT_MAJOR_TYPE): {:#08x}\", hr); if (major == MFMediaType_Video) { GUID subtype{}; if SUCCEEDED (media_type->GetGUID(MF_MT_SUBTYPE, &subtype)) { spdlog::info(\" subtype: {}\", to_readable(subtype)); } UINT32 w = 0, h = 0; if SUCCEEDED (MFGetAttributeSize(media_type, MF_MT_FRAME_SIZE, &w, &h)) { spdlog::info(\" width: {}\", w); spdlog::info(\" height: {}\", h); } UINT32 num = 0, denom = 1; if SUCCEEDED (MFGetAttributeRatio(media_type, MF_MT_FRAME_RATE, &num, &denom)) { spdlog::info(\" fps: {}\", static_cast<float>(num) / denom); } } } void print_CLSID_CResizerDMO(gsl::not_null<IMFTransform*> transform, const GUID& iid) noexcept { spdlog::info(\"- transform:\"); spdlog::info(\" - iid: {}\", to_readable(iid)); DWORD num_input = 0, num_output = 0; if (auto hr = transform->GetStreamCount(&num_input, &num_output); FAILED(hr)) return spdlog::error(\"transform->GetStreamCount: {:#08x}\", hr); DWORD istream = 0, ostream = 0; switch (auto hr = transform->GetStreamIDs(1, &istream, 1, &ostream)) { case E_NOTIMPL: istream = num_input - 1; ostream = num_output - 1; case S_OK: break; default: return spdlog::error(\"transform->GetStreamIDs: {:#08x}\", hr); } auto print = [](IMFMediaType* media_type) { GUID subtype{}; media_type->GetGUID(MF_MT_SUBTYPE, &subtype); spdlog::info(\" subtype: {}\", to_readable(subtype)); UINT32 w = 0, h = 0; if SUCCEEDED (MFGetAttributeSize(media_type, MF_MT_FRAME_SIZE, &w, &h)) { spdlog::info(\" width: {}\", w); spdlog::info(\" height: {}\", h); } UINT32 num = 0, denom = 1; if SUCCEEDED (MFGetAttributeRatio(media_type, MF_MT_FRAME_RATE, &num, &denom)) { spdlog::info(\" fps: {}\", static_cast<float>(num) / denom); } }; com_ptr<IMFMediaType> input{}; if (auto hr = transform->GetInputCurrentType(istream, input.put())) spdlog::error(\"transform->GetInputCurrentType: {:#08x}\", hr); else { spdlog::info(\" - input_type:\"); print(input.get()); } com_ptr<IMFMediaType> output{}; if (auto hr = transform->GetOutputCurrentType(ostream, output.put())) spdlog::error(\"transform->GetOutputCurrentType: {:#08x}\", hr); else { spdlog::info(\" - output_type:\"); print(input.get()); } } void print_CLSID_CColorConvertDMO(gsl::not_null<IMFTransform*> transform, const GUID& iid) noexcept { spdlog::info(\"- transform:\"); spdlog::info(\" - iid: {}\", to_readable(iid)); DWORD num_input = 0; DWORD num_output = 0; if (auto hr = transform->GetStreamCount(&num_input, &num_output); FAILED(hr)) return spdlog::error(\"transform->GetStreamCount: {:#08x}\", hr); auto istreams = std::make_unique<DWORD[]>(num_input); auto ostreams = std::make_unique<DWORD[]>(num_output); if (auto hr = transform->GetStreamIDs(num_input, istreams.get(), num_output, ostreams.get()); FAILED(hr)) spdlog::warn(\"transform->GetStreamCount: {:#08x}\", hr); if (num_input) { spdlog::info(\" - num_input: {}\", num_input); for (auto i = 0u; i < num_input; ++i) { const auto istream = istreams[i]; MFT_INPUT_STREAM_INFO info{}; if (auto hr = transform->GetInputStreamInfo(istream, &info)) { spdlog::error(\"transform->GetInputStreamInfo: {:#08x}\", hr); } else { spdlog::info(\" - input_stream:\"); spdlog::info(\" size: {}\", info.cbSize); spdlog::info(\" alignment: {}\", info.cbAlignment); spdlog::info(\" flags: {}\", info.dwFlags); spdlog::debug(\" max_latency: {}\", info.hnsMaxLatency); } DWORD ostream = ostreams[0]; DWORD output_index = 0; com_ptr<IMFMediaType> output_type{}; for (auto hr = transform->GetOutputAvailableType(ostream, output_index++, output_type.put()); SUCCEEDED(hr); hr = transform->GetOutputAvailableType(ostream, output_index++, output_type.put())) { if (output_index == 1) spdlog::debug(\" output_available_type:\"); GUID subtype{}; output_type->GetGUID(MF_MT_SUBTYPE, &subtype); spdlog::debug(\" - {}\", to_readable(subtype)); output_type = nullptr; } } } if (num_output) { spdlog::info(\" - num_output: {}\", num_output); for (auto i = 0u; i < num_output; ++i) { const auto ostream = ostreams[i]; MFT_OUTPUT_STREAM_INFO info{}; if (auto hr = transform->GetOutputStreamInfo(ostream, &info)) { spdlog::error(\"transform->GetOutputStreamInfo: {:#08x}\", hr); } else { spdlog::info(\" - output_stream:\"); spdlog::info(\" size: {}\", info.cbSize); spdlog::info(\" alignment: {}\", info.cbAlignment); spdlog::info(\" flags: {}\", info.dwFlags); } } } } void print(gsl::not_null<IMFTransform*> transform, const GUID& iid) noexcept { if (iid == CLSID_CColorConvertDMO) return print_CLSID_CColorConvertDMO(transform, iid); if (iid == CLSID_VideoProcessorMFT) return; if (iid == CLSID_CMSH264DecoderMFT) return; if (iid == CLSID_CResizerDMO) return print_CLSID_CResizerDMO(transform, iid); }","title":"File media_print.cpp"},{"location":"modules/","text":"Modules Here is a list of all modules:","title":"Modules"},{"location":"modules/#modules","text":"Here is a list of all modules:","title":"Modules"},{"location":"namespace_member_enums/","text":"Namespace Member Enums","title":"Namespace Member Enums"},{"location":"namespace_member_enums/#namespace-member-enums","text":"","title":"Namespace Member Enums"},{"location":"namespace_member_functions/","text":"Namespace Member Functions","title":"Namespace Member Functions"},{"location":"namespace_member_functions/#namespace-member-functions","text":"","title":"Namespace Member Functions"},{"location":"namespace_member_typedefs/","text":"Namespace Member Typedefs","title":"Namespace Member Typedefs"},{"location":"namespace_member_typedefs/#namespace-member-typedefs","text":"","title":"Namespace Member Typedefs"},{"location":"namespace_member_variables/","text":"Namespace Member Variables","title":"Namespace Member Variables"},{"location":"namespace_member_variables/#namespace-member-variables","text":"","title":"Namespace Member Variables"},{"location":"namespace_members/","text":"Namespace Members","title":"Namespace Members"},{"location":"namespace_members/#namespace-members","text":"","title":"Namespace Members"},{"location":"namespaces/","text":"Namespace List Here is a list of all namespaces with brief descriptions: namespace std","title":"Namespace List"},{"location":"namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace std","title":"Namespace List"},{"location":"namespacestd/","text":"Namespace std Class List > std The documentation for this class was generated from the following file src/media.cpp","title":"Namespace std"},{"location":"namespacestd/#namespace-std","text":"Class List > std The documentation for this class was generated from the following file src/media.cpp","title":"Namespace std"},{"location":"pages/","text":"Related Pages Here is a list of all related documentation pages: Todo List","title":"Related Pages"},{"location":"pages/#related-pages","text":"Here is a list of all related documentation pages: Todo List","title":"Related Pages"},{"location":"structcritical__section__t/","text":"Struct critical_section_t Class List > critical_section_t Inherits the following classes: CRITICAL_SECTION Public Functions Type Name critical_section_t () noexcept void lock () noexcept bool try_lock () noexcept void unlock () noexcept ~critical_section_t () noexcept Public Functions Documentation function critical_section_t inline critical_section_t::critical_section_t () noexcept function lock inline void critical_section_t::lock () noexcept function try_lock inline bool critical_section_t::try_lock () noexcept function unlock inline void critical_section_t::unlock () noexcept function ~critical_section_t inline critical_section_t::~critical_section_t () noexcept The documentation for this class was generated from the following file src/media.cpp","title":"Struct critical\\_section\\_t"},{"location":"structcritical__section__t/#struct-critical_section_t","text":"Class List > critical_section_t Inherits the following classes: CRITICAL_SECTION","title":"Struct critical_section_t"},{"location":"structcritical__section__t/#public-functions","text":"Type Name critical_section_t () noexcept void lock () noexcept bool try_lock () noexcept void unlock () noexcept ~critical_section_t () noexcept","title":"Public Functions"},{"location":"structcritical__section__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"structcritical__section__t/#function-critical_section_t","text":"inline critical_section_t::critical_section_t () noexcept","title":"function critical_section_t"},{"location":"structcritical__section__t/#function-lock","text":"inline void critical_section_t::lock () noexcept","title":"function lock"},{"location":"structcritical__section__t/#function-try_lock","text":"inline bool critical_section_t::try_lock () noexcept","title":"function try_lock"},{"location":"structcritical__section__t/#function-unlock","text":"inline void critical_section_t::unlock () noexcept","title":"function unlock"},{"location":"structcritical__section__t/#function-critical_section_t_1","text":"inline critical_section_t::~critical_section_t () noexcept The documentation for this class was generated from the following file src/media.cpp","title":"function ~critical_section_t"},{"location":"todo/","text":"Todo List Class qpc_timer_t use static_assert for Windows SDK","title":"Todo List"},{"location":"todo/#todo-list","text":"","title":"Todo List"},{"location":"todo/#class-qpc_timer_t","text":"use static_assert for Windows SDK","title":"Class qpc_timer_t"},{"location":"variables/","text":"Variables","title":"Variables"},{"location":"variables/#variables","text":"","title":"Variables"}]}