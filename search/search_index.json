{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"../readme.md","title":"Home"},{"location":"annotated/","text":"Class List Here are the classes, structs, unions and interfaces with brief descriptions: namespace WRL struct critical_section_t class qpc_timer_t namespace std","title":"Class List"},{"location":"annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: namespace WRL struct critical_section_t class qpc_timer_t namespace std","title":"Class List"},{"location":"class_member_enums/","text":"Class Member Enums","title":"Class Member Enums"},{"location":"class_member_enums/#class-member-enums","text":"","title":"Class Member Enums"},{"location":"class_member_functions/","text":"Class Member Functions c critical_section_t ( critical_section_t ) l lock ( critical_section_t ) p pick ( qpc_timer_t ) q qpc_timer_t ( qpc_timer_t ) r reset ( qpc_timer_t ) t try_lock ( critical_section_t ) u unlock ( critical_section_t ) ~ ~critical_section_t ( critical_section_t )","title":"Class Member Functions"},{"location":"class_member_functions/#class-member-functions","text":"","title":"Class Member Functions"},{"location":"class_member_functions/#c","text":"critical_section_t ( critical_section_t )","title":"c"},{"location":"class_member_functions/#l","text":"lock ( critical_section_t )","title":"l"},{"location":"class_member_functions/#p","text":"pick ( qpc_timer_t )","title":"p"},{"location":"class_member_functions/#q","text":"qpc_timer_t ( qpc_timer_t )","title":"q"},{"location":"class_member_functions/#r","text":"reset ( qpc_timer_t )","title":"r"},{"location":"class_member_functions/#t","text":"try_lock ( critical_section_t )","title":"t"},{"location":"class_member_functions/#u","text":"unlock ( critical_section_t )","title":"u"},{"location":"class_member_functions/#_1","text":"~critical_section_t ( critical_section_t )","title":"~"},{"location":"class_member_typedefs/","text":"Class Member Typedefs","title":"Class Member Typedefs"},{"location":"class_member_typedefs/#class-member-typedefs","text":"","title":"Class Member Typedefs"},{"location":"class_member_variables/","text":"Class Member Variables f frequency ( qpc_timer_t ) s start ( qpc_timer_t )","title":"Class Member Variables"},{"location":"class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"class_member_variables/#f","text":"frequency ( qpc_timer_t )","title":"f"},{"location":"class_member_variables/#s","text":"start ( qpc_timer_t )","title":"s"},{"location":"class_members/","text":"Class Members c critical_section_t ( critical_section_t ) f frequency ( qpc_timer_t ) l lock ( critical_section_t ) p pick ( qpc_timer_t ) q qpc_timer_t ( qpc_timer_t ) r reset ( qpc_timer_t ) s start ( qpc_timer_t ) t try_lock ( critical_section_t ) u unlock ( critical_section_t ) ~ ~critical_section_t ( critical_section_t )","title":"Class Members"},{"location":"class_members/#class-members","text":"","title":"Class Members"},{"location":"class_members/#c","text":"critical_section_t ( critical_section_t )","title":"c"},{"location":"class_members/#f","text":"frequency ( qpc_timer_t )","title":"f"},{"location":"class_members/#l","text":"lock ( critical_section_t )","title":"l"},{"location":"class_members/#p","text":"pick ( qpc_timer_t )","title":"p"},{"location":"class_members/#q","text":"qpc_timer_t ( qpc_timer_t )","title":"q"},{"location":"class_members/#r","text":"reset ( qpc_timer_t )","title":"r"},{"location":"class_members/#s","text":"start ( qpc_timer_t )","title":"s"},{"location":"class_members/#t","text":"try_lock ( critical_section_t )","title":"t"},{"location":"class_members/#u","text":"unlock ( critical_section_t )","title":"u"},{"location":"class_members/#_1","text":"~critical_section_t ( critical_section_t )","title":"~"},{"location":"classes/","text":"Class Index c critical_section_t q qpc_timer_t","title":"Class Index"},{"location":"classes/#class-index","text":"","title":"Class Index"},{"location":"classes/#c","text":"critical_section_t","title":"c"},{"location":"classes/#q","text":"qpc_timer_t","title":"q"},{"location":"classqpc__timer__t/","text":"Class qpc_timer_t Class List > qpc_timer_t More... #include <media.hpp> Public Functions Type Name auto pick () noexcept const qpc_timer_t () noexcept auto reset () noexcept Detailed Description Todo use static_assert for Windows SDK Public Functions Documentation function pick inline auto qpc_timer_t::pick () noexcept const Returns: elapsed time in millisecond unit function qpc_timer_t inline qpc_timer_t::qpc_timer_t () noexcept function reset inline auto qpc_timer_t::reset () noexcept The documentation for this class was generated from the following file src/media.hpp","title":"Class qpc\\_timer\\_t"},{"location":"classqpc__timer__t/#class-qpc_timer_t","text":"Class List > qpc_timer_t More... #include <media.hpp>","title":"Class qpc_timer_t"},{"location":"classqpc__timer__t/#public-functions","text":"Type Name auto pick () noexcept const qpc_timer_t () noexcept auto reset () noexcept","title":"Public Functions"},{"location":"classqpc__timer__t/#detailed-description","text":"Todo use static_assert for Windows SDK","title":"Detailed Description"},{"location":"classqpc__timer__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classqpc__timer__t/#function-pick","text":"inline auto qpc_timer_t::pick () noexcept const Returns: elapsed time in millisecond unit","title":"function pick"},{"location":"classqpc__timer__t/#function-qpc_timer_t","text":"inline qpc_timer_t::qpc_timer_t () noexcept","title":"function qpc_timer_t"},{"location":"classqpc__timer__t/#function-reset","text":"inline auto qpc_timer_t::reset () noexcept The documentation for this class was generated from the following file src/media.hpp","title":"function reset"},{"location":"dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"Dir src File List > src Files Type Name file media.cpp file media.hpp The documentation for this class was generated from the following file src/","title":"Dir src"},{"location":"dir_68267d1309a1af8e8297ef4c3efbcdba/#dir-src","text":"File List > src","title":"Dir src"},{"location":"dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Type Name file media.cpp file media.hpp The documentation for this class was generated from the following file src/","title":"Files"},{"location":"files/","text":"File List Here is a list of all files with brief descriptions: dir src file media.cpp file media.hpp","title":"File List"},{"location":"files/#file-list","text":"Here is a list of all files with brief descriptions: dir src file media.cpp file media.hpp","title":"File List"},{"location":"functions/","text":"Functions c configure ( media.cpp , media.hpp ) configure_video ( media.cpp ) create_and_copy_single_buffer_sample ( media.cpp , media.hpp ) create_single_buffer_sample ( media.cpp , media.hpp ) d decode ( media.cpp , media.hpp ) g get_devices ( media.cpp , media.hpp ) get_name ( media.cpp , media.hpp ) get_stream_descriptor ( media.cpp , media.hpp ) get_transform_output ( media.cpp , media.hpp ) m media_startup ( media.cpp , media.hpp ) p print ( media.cpp ) print_video ( media.cpp )","title":"Functions"},{"location":"functions/#functions","text":"","title":"Functions"},{"location":"functions/#c","text":"configure ( media.cpp , media.hpp ) configure_video ( media.cpp ) create_and_copy_single_buffer_sample ( media.cpp , media.hpp ) create_single_buffer_sample ( media.cpp , media.hpp )","title":"c"},{"location":"functions/#d","text":"decode ( media.cpp , media.hpp )","title":"d"},{"location":"functions/#g","text":"get_devices ( media.cpp , media.hpp ) get_name ( media.cpp , media.hpp ) get_stream_descriptor ( media.cpp , media.hpp ) get_transform_output ( media.cpp , media.hpp )","title":"g"},{"location":"functions/#m","text":"media_startup ( media.cpp , media.hpp )","title":"m"},{"location":"functions/#p","text":"print ( media.cpp ) print_video ( media.cpp )","title":"p"},{"location":"hierarchy/","text":"Class Hierarchy This inheritance list is sorted roughly, but not completely, alphabetically: class qpc_timer_t class CRITICAL_SECTION struct critical_section_t","title":"Class Hierarchy"},{"location":"hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: class qpc_timer_t class CRITICAL_SECTION struct critical_section_t","title":"Class Hierarchy"},{"location":"macros/","text":"Macros i IF_EQUAL_RETURN ( media.cpp )","title":"Macros"},{"location":"macros/#macros","text":"","title":"Macros"},{"location":"macros/#i","text":"IF_EQUAL_RETURN ( media.cpp )","title":"i"},{"location":"media_8cpp/","text":"File media.cpp File List > src > media.cpp Go to the source code of this file. #include \"media.hpp\" #include <spdlog/spdlog.h> #include <spdlog/sinks/wincolor_sink.h> #include <spdlog/sinks/basic_file_sink.h> #include <dshowasf.h> Namespaces Type Name namespace WRL namespace std Classes Type Name struct critical_section_t Public Functions Type Name HRESULT configure (ComPtr< IMFStreamDescriptor > stream) noexcept HRESULT configure_video (ComPtr< IMFMediaType > type) HRESULT create_and_copy_single_buffer_sample (IMFSample * src, IMFSample ** dst) HRESULT create_single_buffer_sample (DWORD bufsz, IMFSample ** sample) auto decode (ComPtr< IMFSourceReader > source_reader, ComPtr< IMFTransform > decoding_transform) HRESULT get_devices (IMFAttributes * attrs, vector< ComPtr< IMFActivate >> & devices) noexcept HRESULT get_name (IMFActivate * device, wstring & name) noexcept gsl::czstring get_name (const GUID & guid) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) HRESULT get_transform_output (IMFTransform * transform, IMFSample ** sample, BOOL & flushed) auto media_startup () noexcept void print (IMFMediaType * media) noexcept void print_video (FILE * fout, IMFMediaType * media) noexcept Macros Type Name define IF_EQUAL_RETURN (param, val) Public Functions Documentation function configure HRESULT configure ( ComPtr< IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video function configure_video HRESULT configure_video ( ComPtr< IMFMediaType > type ) function create_and_copy_single_buffer_sample HRESULT create_and_copy_single_buffer_sample ( IMFSample * src, IMFSample ** dst ) function create_single_buffer_sample HRESULT create_single_buffer_sample ( DWORD bufsz, IMFSample ** sample ) function decode auto decode ( ComPtr< IMFSourceReader > source_reader, ComPtr< IMFTransform > decoding_transform ) function get_devices HRESULT get_devices ( IMFAttributes * attrs, vector< ComPtr< IMFActivate >> & devices ) noexcept function get_name HRESULT get_name ( IMFActivate * device, wstring & name ) noexcept function get_name gsl::czstring get_name ( const GUID & guid ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/media-type-debugging-code function get_stream_descriptor HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr ) function get_transform_output HRESULT get_transform_output ( IMFTransform * transform, IMFSample ** sample, BOOL & flushed ) function media_startup auto media_startup () noexcept See also: MFStartup See also: MFShutdown Exception: winrt::hresult_error function print void print ( IMFMediaType * media ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-subtype-guids See also: https://stackoverflow.com/a/9681384 function print_video void print_video ( FILE * fout, IMFMediaType * media ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/wmformat/media-type-identifiers Macro Definition Documentation define IF_EQUAL_RETURN #define IF_EQUAL_RETURN ( param, val ) if (val == param) \\ return #val The documentation for this class was generated from the following file src/media.cpp","title":"File media.cpp"},{"location":"media_8cpp/#file-mediacpp","text":"File List > src > media.cpp Go to the source code of this file. #include \"media.hpp\" #include <spdlog/spdlog.h> #include <spdlog/sinks/wincolor_sink.h> #include <spdlog/sinks/basic_file_sink.h> #include <dshowasf.h>","title":"File media.cpp"},{"location":"media_8cpp/#namespaces","text":"Type Name namespace WRL namespace std","title":"Namespaces"},{"location":"media_8cpp/#classes","text":"Type Name struct critical_section_t","title":"Classes"},{"location":"media_8cpp/#public-functions","text":"Type Name HRESULT configure (ComPtr< IMFStreamDescriptor > stream) noexcept HRESULT configure_video (ComPtr< IMFMediaType > type) HRESULT create_and_copy_single_buffer_sample (IMFSample * src, IMFSample ** dst) HRESULT create_single_buffer_sample (DWORD bufsz, IMFSample ** sample) auto decode (ComPtr< IMFSourceReader > source_reader, ComPtr< IMFTransform > decoding_transform) HRESULT get_devices (IMFAttributes * attrs, vector< ComPtr< IMFActivate >> & devices) noexcept HRESULT get_name (IMFActivate * device, wstring & name) noexcept gsl::czstring get_name (const GUID & guid) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) HRESULT get_transform_output (IMFTransform * transform, IMFSample ** sample, BOOL & flushed) auto media_startup () noexcept void print (IMFMediaType * media) noexcept void print_video (FILE * fout, IMFMediaType * media) noexcept","title":"Public Functions"},{"location":"media_8cpp/#macros","text":"Type Name define IF_EQUAL_RETURN (param, val)","title":"Macros"},{"location":"media_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"media_8cpp/#function-configure","text":"HRESULT configure ( ComPtr< IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video","title":"function configure"},{"location":"media_8cpp/#function-configure_video","text":"HRESULT configure_video ( ComPtr< IMFMediaType > type )","title":"function configure_video"},{"location":"media_8cpp/#function-create_and_copy_single_buffer_sample","text":"HRESULT create_and_copy_single_buffer_sample ( IMFSample * src, IMFSample ** dst )","title":"function create_and_copy_single_buffer_sample"},{"location":"media_8cpp/#function-create_single_buffer_sample","text":"HRESULT create_single_buffer_sample ( DWORD bufsz, IMFSample ** sample )","title":"function create_single_buffer_sample"},{"location":"media_8cpp/#function-decode","text":"auto decode ( ComPtr< IMFSourceReader > source_reader, ComPtr< IMFTransform > decoding_transform )","title":"function decode"},{"location":"media_8cpp/#function-get_devices","text":"HRESULT get_devices ( IMFAttributes * attrs, vector< ComPtr< IMFActivate >> & devices ) noexcept","title":"function get_devices"},{"location":"media_8cpp/#function-get_name","text":"HRESULT get_name ( IMFActivate * device, wstring & name ) noexcept","title":"function get_name"},{"location":"media_8cpp/#function-get_name_1","text":"gsl::czstring get_name ( const GUID & guid ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/media-type-debugging-code","title":"function get_name"},{"location":"media_8cpp/#function-get_stream_descriptor","text":"HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr )","title":"function get_stream_descriptor"},{"location":"media_8cpp/#function-get_transform_output","text":"HRESULT get_transform_output ( IMFTransform * transform, IMFSample ** sample, BOOL & flushed )","title":"function get_transform_output"},{"location":"media_8cpp/#function-media_startup","text":"auto media_startup () noexcept See also: MFStartup See also: MFShutdown Exception: winrt::hresult_error","title":"function media_startup"},{"location":"media_8cpp/#function-print","text":"void print ( IMFMediaType * media ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-subtype-guids See also: https://stackoverflow.com/a/9681384","title":"function print"},{"location":"media_8cpp/#function-print_video","text":"void print_video ( FILE * fout, IMFMediaType * media ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/wmformat/media-type-identifiers","title":"function print_video"},{"location":"media_8cpp/#macro-definition-documentation","text":"","title":"Macro Definition Documentation"},{"location":"media_8cpp/#define-if_equal_return","text":"#define IF_EQUAL_RETURN ( param, val ) if (val == param) \\ return #val The documentation for this class was generated from the following file src/media.cpp","title":"define IF_EQUAL_RETURN"},{"location":"media_8cpp_source/","text":"File media.cpp File List > src > media.cpp Go to the documentation of this file. #include \"media.hpp\" #include <spdlog/spdlog.h> #include <spdlog/sinks/wincolor_sink.h> #include <spdlog/sinks/basic_file_sink.h> #include <dshowasf.h> using namespace std; using namespace Microsoft::WRL; struct critical_section_t final : public CRITICAL_SECTION { public: critical_section_t() noexcept : CRITICAL_SECTION{} { InitializeCriticalSection(this); } ~critical_section_t() noexcept { DeleteCriticalSection(this); } bool try_lock() noexcept { return TryEnterCriticalSection(this); } void lock() noexcept { return EnterCriticalSection(this); } void unlock() noexcept { return LeaveCriticalSection(this); } }; auto media_startup() noexcept(false) -> gsl::final_action<HRESULT(WINAPI*)()> { if (auto hr = MFStartup(MF_VERSION)) throw winrt::hresult_error{hr}; return gsl::finally(&MFShutdown); } HRESULT get_devices(IMFAttributes* attrs, vector<ComPtr<IMFActivate>>& devices) noexcept { IMFActivate** handles = nullptr; UINT32 count = 0; HRESULT hr = MFEnumDeviceSources(attrs, &handles, &count); if FAILED (hr) return hr; auto on_return = gsl::finally([handles]() { CoTaskMemFree(handles); }); for (auto i = 0u; i < count; ++i) devices.emplace_back(move(handles[i])); return S_OK; } HRESULT get_name(IMFActivate* device, wstring& name) noexcept { constexpr UINT32 max_size = 255; WCHAR buf[max_size]{}; UINT32 buflen{}; HRESULT hr = device->GetString(MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME, buf, max_size, &buflen); if (SUCCEEDED(hr)) name = {buf, buflen}; return hr; } HRESULT get_stream_descriptor(IMFPresentationDescriptor* presentation, IMFStreamDescriptor** ptr) { DWORD num_stream = 0; if (auto hr = presentation->GetStreamDescriptorCount(&num_stream); SUCCEEDED(hr) == false) return hr; for (auto i = 0u; i < num_stream; ++i) { BOOL selected = false; if (auto hr = presentation->GetStreamDescriptorByIndex(i, &selected, ptr); FAILED(hr)) return hr; if (selected) break; } return S_OK; } HRESULT configure_video(ComPtr<IMFMediaType> type) { GUID subtype{}; type->GetGUID(MF_MT_SUBTYPE, &subtype); UINT32 interlace = 0; type->GetUINT32(MF_MT_INTERLACE_MODE, &interlace); const auto imode = static_cast<MFVideoInterlaceMode>(interlace); UINT32 stride = 0; type->GetUINT32(MF_MT_DEFAULT_STRIDE, &stride); UINT32 ycbcr2rgb = 0; type->GetUINT32(MF_MT_YUV_MATRIX, &ycbcr2rgb); const auto matrix = static_cast<MFVideoTransferMatrix>(ycbcr2rgb); UINT64 size = 0; type->GetUINT64(MF_MT_FRAME_SIZE, &size); // MFGetAttributeSize UINT32 w = size >> 32, h = size & UINT32_MAX; UINT64 framerate = 0; // framerate >> 32; type->GetUINT64(MF_MT_FRAME_RATE_RANGE_MAX, &framerate); return type->SetUINT64(MF_MT_FRAME_RATE, framerate); } void print(IMFMediaType* media) noexcept; HRESULT configure(ComPtr<IMFStreamDescriptor> stream) noexcept { ComPtr<IMFMediaTypeHandler> handler{}; if (auto hr = stream->GetMediaTypeHandler(handler.GetAddressOf()); SUCCEEDED(hr) == false) return hr; DWORD num_types = 0; if (auto hr = handler->GetMediaTypeCount(&num_types); SUCCEEDED(hr) == false) return hr; ComPtr<IMFMediaType> type{}; for (auto i = 0u; i < num_types; ++i) { ComPtr<IMFMediaType> current{}; if (auto hr = handler->GetMediaTypeByIndex(i, current.GetAddressOf()); FAILED(hr)) return hr; if (type == nullptr) type = current; print(current.Get()); } return handler->SetCurrentMediaType(type.Get()); } void print_video(FILE* fout, IMFMediaType* media) noexcept { fprintf(fout, \" - video:\\n\"); GUID subtype{}; media->GetGUID(MF_MT_SUBTYPE, &subtype); gsl::czstring<> name = get_name(subtype); if (name == nullptr) name = \"Unknown\"; // MFVideoFormat_RGB32 // 444 (32 bpp) // MFVideoFormat_ARGB32 // MFVideoFormat_RGB24 // MFVideoFormat_I420 // 420 (16 bpp) // MFVideoFormat_NV12 // 420 (12 bpp) // MFVideoFormat_UYVY // 422 (12 bpp) // MFVideoFormat_MJPG // MFVideoFormat_AI44 // 4:4:4 Packed P // MFVideoFormat_AYUV // 4:4:4 Packed 8 // MFVideoFormat_I420 // 4:2:0 Planar 8 // MFVideoFormat_IYUV // 4:2:0 Planar 8 // MFVideoFormat_NV11 // 4:1:1 Planar 8 // MFVideoFormat_NV12 // 4:2:0 Planar 8 // MFVideoFormat_UYVY // 4:2:2 Packed 8 // MFVideoFormat_Y41P // 4:1:1 Packed 8 // MFVideoFormat_Y41T // 4:1:1 Packed 8 // MFVideoFormat_Y42T // 4:2:2 Packed 8 // MFVideoFormat_YUY2 // 4:2:2 Packed 8 // MFVideoFormat_YVU9 // 8:4:4 Planar 9 // MFVideoFormat_YV12 // 4:2:0 Planar 8 // MFVideoFormat_YVYU // 4:2:2 Packed 8 fprintf(fout, \" - format: %s\\n\", name); UINT64 value = 0; if (auto hr = media->GetUINT64(MF_MT_FRAME_SIZE, &value); SUCCEEDED(hr)) { UINT32 w = value >> 32, h = value & UINT32_MAX; fprintf(fout, \" - width: %u\\n\", w); fprintf(fout, \" - height: %u\\n\", h); } if (auto hr = media->GetUINT64(MF_MT_FRAME_RATE_RANGE_MAX, &value); SUCCEEDED(hr)) { UINT32 framerate = value >> 32; fprintf(fout, \" - fps: %u\\n\", framerate); } } void print(IMFMediaType* media) noexcept { GUID major{}; media->GetGUID(MF_MT_MAJOR_TYPE, &major); if (major == MFMediaType_Default) fprintf(stdout, \" - default\\n\"); else if (major == MFMediaType_Audio) fprintf(stdout, \" - audio\\n\"); else if (major == MFMediaType_Stream) fprintf(stdout, \" - stream\\n\"); else if (major == MFMediaType_Video) print_video(stdout, media); else fprintf(stdout, \" - unknown\\n\"); } auto decode(ComPtr<IMFSourceReader> source_reader, ComPtr<IMFTransform> decoding_transform) -> std::experimental::generator<ComPtr<IMFSample>> { while (true) { ComPtr<IMFSample> video_sample{}; DWORD stream_index{}; DWORD flags{}; LONGLONG sample_timestamp = 0; // unit 100-nanosecond LONGLONG sample_duration = 0; if (auto hr = source_reader->ReadSample(MF_SOURCE_READER_FIRST_VIDEO_STREAM, 0, &stream_index, &flags, &sample_timestamp, video_sample.GetAddressOf())) throw winrt::hresult_error{hr}; if (flags & MF_SOURCE_READERF_STREAMTICK) { // INFO(\"MF_SOURCE_READERF_STREAMTICK\"); } if (flags & MF_SOURCE_READERF_ENDOFSTREAM) { // INFO(\"MF_SOURCE_READERF_ENDOFSTREAM\"); break; } if (flags & MF_SOURCE_READERF_NEWSTREAM) { // INFO(\"MF_SOURCE_READERF_NEWSTREAM\"); break; } if (flags & MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED) { // INFO(\"MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED\"); break; } if (flags & MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED) { // INFO(\"MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED\"); break; } if (video_sample) { if (auto hr = video_sample->SetSampleTime(sample_timestamp)) throw winrt::hresult_error{hr}; if (auto hr = video_sample->GetSampleDuration(&sample_duration)) throw winrt::hresult_error{hr}; DWORD flags = 0; if (auto hr = video_sample->GetSampleFlags(&flags)) throw winrt::hresult_error{hr}; // Replicate transmitting the sample across the network and reconstructing. ComPtr<IMFSample> copied_sample{}; if (auto hr = create_and_copy_single_buffer_sample(video_sample.Get(), copied_sample.GetAddressOf())) throw winrt::hresult_error{hr}; // Apply the H264 decoder transform if (auto hr = decoding_transform->ProcessInput(0, copied_sample.Get(), 0)) throw winrt::hresult_error{hr}; HRESULT result = S_OK; while (result == S_OK) { ComPtr<IMFSample> decoded_sample{}; BOOL flushed = FALSE; result = get_transform_output(decoding_transform.Get(), decoded_sample.GetAddressOf(), flushed); if (result != S_OK && result != MF_E_TRANSFORM_NEED_MORE_INPUT) throw winrt::hresult_error{result}; if (flushed) { // decoder format changed } else if (decoded_sample) { // Write decoded sample to capture file. co_yield decoded_sample; } } } } } HRESULT create_single_buffer_sample(DWORD bufsz, IMFSample** sample) { if (auto hr = MFCreateSample(sample)) return hr; ComPtr<IMFMediaBuffer> buffer{}; if (auto hr = MFCreateMemoryBuffer(bufsz, buffer.GetAddressOf())) return hr; return (*sample)->AddBuffer(buffer.Get()); } HRESULT create_and_copy_single_buffer_sample(IMFSample* src, IMFSample** dst) { DWORD total{}; if (auto hr = src->GetTotalLength(&total)) return hr; if (auto hr = create_single_buffer_sample(total, dst)) return hr; if (auto hr = src->CopyAllItems(*dst)) return hr; ComPtr<IMFMediaBuffer> buffer{}; if (auto hr = (*dst)->GetBufferByIndex(0, buffer.GetAddressOf())) return hr; return src->CopyToBuffer(buffer.Get()); } HRESULT get_transform_output(IMFTransform* transform, IMFSample** sample, BOOL& flushed) { MFT_OUTPUT_STREAM_INFO stream_info{}; if (auto hr = transform->GetOutputStreamInfo(0, &stream_info)) return hr; flushed = FALSE; *sample = nullptr; MFT_OUTPUT_DATA_BUFFER output{}; if ((stream_info.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) == 0) { if (auto hr = create_single_buffer_sample(stream_info.cbSize, sample)) return hr; output.pSample = *sample; } DWORD status = 0; HRESULT const result = transform->ProcessOutput(0, 1, &output, &status); if (result == S_OK) { *sample = output.pSample; return S_OK; } // see https://docs.microsoft.com/en-us/windows/win32/medfound/handling-stream-changes if (result == MF_E_TRANSFORM_STREAM_CHANGE) { ComPtr<IMFMediaType> changed_output_type{}; if (output.dwStatus != MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE) { // todo: add more works for this case return E_NOTIMPL; } if (auto hr = transform->GetOutputAvailableType(0, 0, changed_output_type.GetAddressOf())) return hr; // check new output media type if (auto hr = changed_output_type->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_IYUV)) return hr; if (auto hr = transform->SetOutputType(0, changed_output_type.Get(), 0)) return hr; if (auto hr = transform->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL)) return hr; flushed = TRUE; return S_OK; } // MF_E_TRANSFORM_NEED_MORE_INPUT: not an error condition but it means the allocated output sample is empty. return result; } gsl::czstring<> get_name(const GUID& guid) noexcept { #ifndef IF_EQUAL_RETURN #define IF_EQUAL_RETURN(param, val) \\ if (val == param) \\ return #val #endif IF_EQUAL_RETURN(guid, MF_MT_MAJOR_TYPE); IF_EQUAL_RETURN(guid, MF_MT_MAJOR_TYPE); IF_EQUAL_RETURN(guid, MF_MT_SUBTYPE); IF_EQUAL_RETURN(guid, MF_MT_ALL_SAMPLES_INDEPENDENT); IF_EQUAL_RETURN(guid, MF_MT_FIXED_SIZE_SAMPLES); IF_EQUAL_RETURN(guid, MF_MT_COMPRESSED); IF_EQUAL_RETURN(guid, MF_MT_SAMPLE_SIZE); IF_EQUAL_RETURN(guid, MF_MT_WRAPPED_TYPE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_NUM_CHANNELS); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_SAMPLES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_AVG_BYTES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_BLOCK_ALIGNMENT); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_BITS_PER_SAMPLE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_VALID_BITS_PER_SAMPLE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_SAMPLES_PER_BLOCK); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_CHANNEL_MASK); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_FOLDDOWN_MATRIX); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_PEAKREF); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_PEAKTARGET); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_AVGREF); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_AVGTARGET); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_PREFER_WAVEFORMATEX); IF_EQUAL_RETURN(guid, MF_MT_AAC_PAYLOAD_TYPE); IF_EQUAL_RETURN(guid, MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION); IF_EQUAL_RETURN(guid, MF_MT_FRAME_SIZE); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE_RANGE_MAX); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE_RANGE_MIN); IF_EQUAL_RETURN(guid, MF_MT_PIXEL_ASPECT_RATIO); IF_EQUAL_RETURN(guid, MF_MT_DRM_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_PAD_CONTROL_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_SOURCE_CONTENT_HINT); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_CHROMA_SITING); IF_EQUAL_RETURN(guid, MF_MT_INTERLACE_MODE); IF_EQUAL_RETURN(guid, MF_MT_TRANSFER_FUNCTION); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_PRIMARIES); IF_EQUAL_RETURN(guid, MF_MT_CUSTOM_VIDEO_PRIMARIES); IF_EQUAL_RETURN(guid, MF_MT_YUV_MATRIX); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_LIGHTING); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_NOMINAL_RANGE); IF_EQUAL_RETURN(guid, MF_MT_GEOMETRIC_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_MINIMUM_DISPLAY_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_PAN_SCAN_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_PAN_SCAN_ENABLED); IF_EQUAL_RETURN(guid, MF_MT_AVG_BITRATE); IF_EQUAL_RETURN(guid, MF_MT_AVG_BIT_ERROR_RATE); IF_EQUAL_RETURN(guid, MF_MT_MAX_KEYFRAME_SPACING); IF_EQUAL_RETURN(guid, MF_MT_DEFAULT_STRIDE); IF_EQUAL_RETURN(guid, MF_MT_PALETTE); IF_EQUAL_RETURN(guid, MF_MT_USER_DATA); IF_EQUAL_RETURN(guid, MF_MT_AM_FORMAT_TYPE); IF_EQUAL_RETURN(guid, MF_MT_MPEG_START_TIME_CODE); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_PROFILE); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_LEVEL); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_MPEG_SEQUENCE_HEADER); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_SRC_PACK_0); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_CTRL_PACK_0); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_SRC_PACK_1); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_CTRL_PACK_1); IF_EQUAL_RETURN(guid, MF_MT_DV_VAUX_SRC_PACK); IF_EQUAL_RETURN(guid, MF_MT_DV_VAUX_CTRL_PACK); IF_EQUAL_RETURN(guid, MF_MT_ARBITRARY_HEADER); IF_EQUAL_RETURN(guid, MF_MT_ARBITRARY_FORMAT); IF_EQUAL_RETURN(guid, MF_MT_IMAGE_LOSS_TOLERANT); IF_EQUAL_RETURN(guid, MF_MT_MPEG4_SAMPLE_DESCRIPTION); IF_EQUAL_RETURN(guid, MF_MT_MPEG4_CURRENT_SAMPLE_ENTRY); IF_EQUAL_RETURN(guid, MF_MT_ORIGINAL_4CC); IF_EQUAL_RETURN(guid, MF_MT_ORIGINAL_WAVE_FORMAT_TAG); // Media types IF_EQUAL_RETURN(guid, MFMediaType_Audio); IF_EQUAL_RETURN(guid, MFMediaType_Video); IF_EQUAL_RETURN(guid, MFMediaType_Protected); IF_EQUAL_RETURN(guid, MFMediaType_SAMI); IF_EQUAL_RETURN(guid, MFMediaType_Script); IF_EQUAL_RETURN(guid, MFMediaType_Image); IF_EQUAL_RETURN(guid, MFMediaType_HTML); IF_EQUAL_RETURN(guid, MFMediaType_Binary); IF_EQUAL_RETURN(guid, MFMediaType_FileTransfer); IF_EQUAL_RETURN(guid, MFVideoFormat_AI44); // FCC('AI44') IF_EQUAL_RETURN(guid, MFVideoFormat_ARGB32); // D3DFMT_A8R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_AYUV); // FCC('AYUV') IF_EQUAL_RETURN(guid, MFVideoFormat_DV25); // FCC('dv25') IF_EQUAL_RETURN(guid, MFVideoFormat_DV50); // FCC('dv50') IF_EQUAL_RETURN(guid, MFVideoFormat_DVH1); // FCC('dvh1') IF_EQUAL_RETURN(guid, MFVideoFormat_DVSD); // FCC('dvsd') IF_EQUAL_RETURN(guid, MFVideoFormat_DVSL); // FCC('dvsl') IF_EQUAL_RETURN(guid, MFVideoFormat_H264); // FCC('H264') IF_EQUAL_RETURN(guid, MFVideoFormat_H264_ES); // IF_EQUAL_RETURN(guid, MFVideoFormat_I420); // FCC('I420') IF_EQUAL_RETURN(guid, MFVideoFormat_IYUV); // FCC('IYUV') IF_EQUAL_RETURN(guid, MFVideoFormat_M4S2); // FCC('M4S2') IF_EQUAL_RETURN(guid, MFVideoFormat_MJPG); IF_EQUAL_RETURN(guid, MFVideoFormat_MP43); // FCC('MP43') IF_EQUAL_RETURN(guid, MFVideoFormat_MP4S); // FCC('MP4S') IF_EQUAL_RETURN(guid, MFVideoFormat_MP4V); // FCC('MP4V') IF_EQUAL_RETURN(guid, MFVideoFormat_MPG1); // FCC('MPG1') IF_EQUAL_RETURN(guid, MFVideoFormat_MSS1); // FCC('MSS1') IF_EQUAL_RETURN(guid, MFVideoFormat_MSS2); // FCC('MSS2') IF_EQUAL_RETURN(guid, MFVideoFormat_NV11); // FCC('NV11') IF_EQUAL_RETURN(guid, MFVideoFormat_NV12); // FCC('NV12') IF_EQUAL_RETURN(guid, MFVideoFormat_P010); // FCC('P010') IF_EQUAL_RETURN(guid, MFVideoFormat_P016); // FCC('P016') IF_EQUAL_RETURN(guid, MFVideoFormat_P210); // FCC('P210') IF_EQUAL_RETURN(guid, MFVideoFormat_P216); // FCC('P216') IF_EQUAL_RETURN(guid, MFVideoFormat_RGB24); // D3DFMT_R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB32); // D3DFMT_X8R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB555); // D3DFMT_X1R5G5B5 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB565); // D3DFMT_R5G6B5 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB8); IF_EQUAL_RETURN(guid, MFVideoFormat_UYVY); // FCC('UYVY') IF_EQUAL_RETURN(guid, MFVideoFormat_v210); // FCC('v210') IF_EQUAL_RETURN(guid, MFVideoFormat_v410); // FCC('v410') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV1); // FCC('WMV1') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV2); // FCC('WMV2') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV3); // FCC('WMV3') IF_EQUAL_RETURN(guid, MFVideoFormat_WVC1); // FCC('WVC1') IF_EQUAL_RETURN(guid, MFVideoFormat_Y210); // FCC('Y210') IF_EQUAL_RETURN(guid, MFVideoFormat_Y216); // FCC('Y216') IF_EQUAL_RETURN(guid, MFVideoFormat_Y410); // FCC('Y410') IF_EQUAL_RETURN(guid, MFVideoFormat_Y416); // FCC('Y416') IF_EQUAL_RETURN(guid, MFVideoFormat_Y41P); IF_EQUAL_RETURN(guid, MFVideoFormat_Y41T); IF_EQUAL_RETURN(guid, MFVideoFormat_YUY2); // FCC('YUY2') IF_EQUAL_RETURN(guid, MFVideoFormat_YV12); // FCC('YV12') IF_EQUAL_RETURN(guid, MFVideoFormat_YVYU); IF_EQUAL_RETURN(guid, MFAudioFormat_PCM); // WAVE_FORMAT_PCM IF_EQUAL_RETURN(guid, MFAudioFormat_Float); // WAVE_FORMAT_IEEE_FLOAT IF_EQUAL_RETURN(guid, MFAudioFormat_DTS); // WAVE_FORMAT_DTS IF_EQUAL_RETURN(guid, MFAudioFormat_Dolby_AC3_SPDIF); // WAVE_FORMAT_DOLBY_AC3_SPDIF IF_EQUAL_RETURN(guid, MFAudioFormat_DRM); // WAVE_FORMAT_DRM IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudioV8); // WAVE_FORMAT_WMAUDIO2 IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudioV9); // WAVE_FORMAT_WMAUDIO3 IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudio_Lossless); // WAVE_FORMAT_WMAUDIO_LOSSLESS IF_EQUAL_RETURN(guid, MFAudioFormat_WMASPDIF); // WAVE_FORMAT_WMASPDIF IF_EQUAL_RETURN(guid, MFAudioFormat_MSP1); // WAVE_FORMAT_WMAVOICE9 IF_EQUAL_RETURN(guid, MFAudioFormat_MP3); // WAVE_FORMAT_MPEGLAYER3 IF_EQUAL_RETURN(guid, MFAudioFormat_MPEG); // WAVE_FORMAT_MPEG IF_EQUAL_RETURN(guid, MFAudioFormat_AAC); // WAVE_FORMAT_MPEG_HEAAC IF_EQUAL_RETURN(guid, MFAudioFormat_ADTS); // WAVE_FORMAT_MPEG_ADTS_AAC #undef IF_EQUAL_RETURN return NULL; }","title":"File media.cpp"},{"location":"media_8cpp_source/#file-mediacpp","text":"File List > src > media.cpp Go to the documentation of this file. #include \"media.hpp\" #include <spdlog/spdlog.h> #include <spdlog/sinks/wincolor_sink.h> #include <spdlog/sinks/basic_file_sink.h> #include <dshowasf.h> using namespace std; using namespace Microsoft::WRL; struct critical_section_t final : public CRITICAL_SECTION { public: critical_section_t() noexcept : CRITICAL_SECTION{} { InitializeCriticalSection(this); } ~critical_section_t() noexcept { DeleteCriticalSection(this); } bool try_lock() noexcept { return TryEnterCriticalSection(this); } void lock() noexcept { return EnterCriticalSection(this); } void unlock() noexcept { return LeaveCriticalSection(this); } }; auto media_startup() noexcept(false) -> gsl::final_action<HRESULT(WINAPI*)()> { if (auto hr = MFStartup(MF_VERSION)) throw winrt::hresult_error{hr}; return gsl::finally(&MFShutdown); } HRESULT get_devices(IMFAttributes* attrs, vector<ComPtr<IMFActivate>>& devices) noexcept { IMFActivate** handles = nullptr; UINT32 count = 0; HRESULT hr = MFEnumDeviceSources(attrs, &handles, &count); if FAILED (hr) return hr; auto on_return = gsl::finally([handles]() { CoTaskMemFree(handles); }); for (auto i = 0u; i < count; ++i) devices.emplace_back(move(handles[i])); return S_OK; } HRESULT get_name(IMFActivate* device, wstring& name) noexcept { constexpr UINT32 max_size = 255; WCHAR buf[max_size]{}; UINT32 buflen{}; HRESULT hr = device->GetString(MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME, buf, max_size, &buflen); if (SUCCEEDED(hr)) name = {buf, buflen}; return hr; } HRESULT get_stream_descriptor(IMFPresentationDescriptor* presentation, IMFStreamDescriptor** ptr) { DWORD num_stream = 0; if (auto hr = presentation->GetStreamDescriptorCount(&num_stream); SUCCEEDED(hr) == false) return hr; for (auto i = 0u; i < num_stream; ++i) { BOOL selected = false; if (auto hr = presentation->GetStreamDescriptorByIndex(i, &selected, ptr); FAILED(hr)) return hr; if (selected) break; } return S_OK; } HRESULT configure_video(ComPtr<IMFMediaType> type) { GUID subtype{}; type->GetGUID(MF_MT_SUBTYPE, &subtype); UINT32 interlace = 0; type->GetUINT32(MF_MT_INTERLACE_MODE, &interlace); const auto imode = static_cast<MFVideoInterlaceMode>(interlace); UINT32 stride = 0; type->GetUINT32(MF_MT_DEFAULT_STRIDE, &stride); UINT32 ycbcr2rgb = 0; type->GetUINT32(MF_MT_YUV_MATRIX, &ycbcr2rgb); const auto matrix = static_cast<MFVideoTransferMatrix>(ycbcr2rgb); UINT64 size = 0; type->GetUINT64(MF_MT_FRAME_SIZE, &size); // MFGetAttributeSize UINT32 w = size >> 32, h = size & UINT32_MAX; UINT64 framerate = 0; // framerate >> 32; type->GetUINT64(MF_MT_FRAME_RATE_RANGE_MAX, &framerate); return type->SetUINT64(MF_MT_FRAME_RATE, framerate); } void print(IMFMediaType* media) noexcept; HRESULT configure(ComPtr<IMFStreamDescriptor> stream) noexcept { ComPtr<IMFMediaTypeHandler> handler{}; if (auto hr = stream->GetMediaTypeHandler(handler.GetAddressOf()); SUCCEEDED(hr) == false) return hr; DWORD num_types = 0; if (auto hr = handler->GetMediaTypeCount(&num_types); SUCCEEDED(hr) == false) return hr; ComPtr<IMFMediaType> type{}; for (auto i = 0u; i < num_types; ++i) { ComPtr<IMFMediaType> current{}; if (auto hr = handler->GetMediaTypeByIndex(i, current.GetAddressOf()); FAILED(hr)) return hr; if (type == nullptr) type = current; print(current.Get()); } return handler->SetCurrentMediaType(type.Get()); } void print_video(FILE* fout, IMFMediaType* media) noexcept { fprintf(fout, \" - video:\\n\"); GUID subtype{}; media->GetGUID(MF_MT_SUBTYPE, &subtype); gsl::czstring<> name = get_name(subtype); if (name == nullptr) name = \"Unknown\"; // MFVideoFormat_RGB32 // 444 (32 bpp) // MFVideoFormat_ARGB32 // MFVideoFormat_RGB24 // MFVideoFormat_I420 // 420 (16 bpp) // MFVideoFormat_NV12 // 420 (12 bpp) // MFVideoFormat_UYVY // 422 (12 bpp) // MFVideoFormat_MJPG // MFVideoFormat_AI44 // 4:4:4 Packed P // MFVideoFormat_AYUV // 4:4:4 Packed 8 // MFVideoFormat_I420 // 4:2:0 Planar 8 // MFVideoFormat_IYUV // 4:2:0 Planar 8 // MFVideoFormat_NV11 // 4:1:1 Planar 8 // MFVideoFormat_NV12 // 4:2:0 Planar 8 // MFVideoFormat_UYVY // 4:2:2 Packed 8 // MFVideoFormat_Y41P // 4:1:1 Packed 8 // MFVideoFormat_Y41T // 4:1:1 Packed 8 // MFVideoFormat_Y42T // 4:2:2 Packed 8 // MFVideoFormat_YUY2 // 4:2:2 Packed 8 // MFVideoFormat_YVU9 // 8:4:4 Planar 9 // MFVideoFormat_YV12 // 4:2:0 Planar 8 // MFVideoFormat_YVYU // 4:2:2 Packed 8 fprintf(fout, \" - format: %s\\n\", name); UINT64 value = 0; if (auto hr = media->GetUINT64(MF_MT_FRAME_SIZE, &value); SUCCEEDED(hr)) { UINT32 w = value >> 32, h = value & UINT32_MAX; fprintf(fout, \" - width: %u\\n\", w); fprintf(fout, \" - height: %u\\n\", h); } if (auto hr = media->GetUINT64(MF_MT_FRAME_RATE_RANGE_MAX, &value); SUCCEEDED(hr)) { UINT32 framerate = value >> 32; fprintf(fout, \" - fps: %u\\n\", framerate); } } void print(IMFMediaType* media) noexcept { GUID major{}; media->GetGUID(MF_MT_MAJOR_TYPE, &major); if (major == MFMediaType_Default) fprintf(stdout, \" - default\\n\"); else if (major == MFMediaType_Audio) fprintf(stdout, \" - audio\\n\"); else if (major == MFMediaType_Stream) fprintf(stdout, \" - stream\\n\"); else if (major == MFMediaType_Video) print_video(stdout, media); else fprintf(stdout, \" - unknown\\n\"); } auto decode(ComPtr<IMFSourceReader> source_reader, ComPtr<IMFTransform> decoding_transform) -> std::experimental::generator<ComPtr<IMFSample>> { while (true) { ComPtr<IMFSample> video_sample{}; DWORD stream_index{}; DWORD flags{}; LONGLONG sample_timestamp = 0; // unit 100-nanosecond LONGLONG sample_duration = 0; if (auto hr = source_reader->ReadSample(MF_SOURCE_READER_FIRST_VIDEO_STREAM, 0, &stream_index, &flags, &sample_timestamp, video_sample.GetAddressOf())) throw winrt::hresult_error{hr}; if (flags & MF_SOURCE_READERF_STREAMTICK) { // INFO(\"MF_SOURCE_READERF_STREAMTICK\"); } if (flags & MF_SOURCE_READERF_ENDOFSTREAM) { // INFO(\"MF_SOURCE_READERF_ENDOFSTREAM\"); break; } if (flags & MF_SOURCE_READERF_NEWSTREAM) { // INFO(\"MF_SOURCE_READERF_NEWSTREAM\"); break; } if (flags & MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED) { // INFO(\"MF_SOURCE_READERF_NATIVEMEDIATYPECHANGED\"); break; } if (flags & MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED) { // INFO(\"MF_SOURCE_READERF_CURRENTMEDIATYPECHANGED\"); break; } if (video_sample) { if (auto hr = video_sample->SetSampleTime(sample_timestamp)) throw winrt::hresult_error{hr}; if (auto hr = video_sample->GetSampleDuration(&sample_duration)) throw winrt::hresult_error{hr}; DWORD flags = 0; if (auto hr = video_sample->GetSampleFlags(&flags)) throw winrt::hresult_error{hr}; // Replicate transmitting the sample across the network and reconstructing. ComPtr<IMFSample> copied_sample{}; if (auto hr = create_and_copy_single_buffer_sample(video_sample.Get(), copied_sample.GetAddressOf())) throw winrt::hresult_error{hr}; // Apply the H264 decoder transform if (auto hr = decoding_transform->ProcessInput(0, copied_sample.Get(), 0)) throw winrt::hresult_error{hr}; HRESULT result = S_OK; while (result == S_OK) { ComPtr<IMFSample> decoded_sample{}; BOOL flushed = FALSE; result = get_transform_output(decoding_transform.Get(), decoded_sample.GetAddressOf(), flushed); if (result != S_OK && result != MF_E_TRANSFORM_NEED_MORE_INPUT) throw winrt::hresult_error{result}; if (flushed) { // decoder format changed } else if (decoded_sample) { // Write decoded sample to capture file. co_yield decoded_sample; } } } } } HRESULT create_single_buffer_sample(DWORD bufsz, IMFSample** sample) { if (auto hr = MFCreateSample(sample)) return hr; ComPtr<IMFMediaBuffer> buffer{}; if (auto hr = MFCreateMemoryBuffer(bufsz, buffer.GetAddressOf())) return hr; return (*sample)->AddBuffer(buffer.Get()); } HRESULT create_and_copy_single_buffer_sample(IMFSample* src, IMFSample** dst) { DWORD total{}; if (auto hr = src->GetTotalLength(&total)) return hr; if (auto hr = create_single_buffer_sample(total, dst)) return hr; if (auto hr = src->CopyAllItems(*dst)) return hr; ComPtr<IMFMediaBuffer> buffer{}; if (auto hr = (*dst)->GetBufferByIndex(0, buffer.GetAddressOf())) return hr; return src->CopyToBuffer(buffer.Get()); } HRESULT get_transform_output(IMFTransform* transform, IMFSample** sample, BOOL& flushed) { MFT_OUTPUT_STREAM_INFO stream_info{}; if (auto hr = transform->GetOutputStreamInfo(0, &stream_info)) return hr; flushed = FALSE; *sample = nullptr; MFT_OUTPUT_DATA_BUFFER output{}; if ((stream_info.dwFlags & MFT_OUTPUT_STREAM_PROVIDES_SAMPLES) == 0) { if (auto hr = create_single_buffer_sample(stream_info.cbSize, sample)) return hr; output.pSample = *sample; } DWORD status = 0; HRESULT const result = transform->ProcessOutput(0, 1, &output, &status); if (result == S_OK) { *sample = output.pSample; return S_OK; } // see https://docs.microsoft.com/en-us/windows/win32/medfound/handling-stream-changes if (result == MF_E_TRANSFORM_STREAM_CHANGE) { ComPtr<IMFMediaType> changed_output_type{}; if (output.dwStatus != MFT_OUTPUT_DATA_BUFFER_FORMAT_CHANGE) { // todo: add more works for this case return E_NOTIMPL; } if (auto hr = transform->GetOutputAvailableType(0, 0, changed_output_type.GetAddressOf())) return hr; // check new output media type if (auto hr = changed_output_type->SetGUID(MF_MT_SUBTYPE, MFVideoFormat_IYUV)) return hr; if (auto hr = transform->SetOutputType(0, changed_output_type.Get(), 0)) return hr; if (auto hr = transform->ProcessMessage(MFT_MESSAGE_COMMAND_FLUSH, NULL)) return hr; flushed = TRUE; return S_OK; } // MF_E_TRANSFORM_NEED_MORE_INPUT: not an error condition but it means the allocated output sample is empty. return result; } gsl::czstring<> get_name(const GUID& guid) noexcept { #ifndef IF_EQUAL_RETURN #define IF_EQUAL_RETURN(param, val) \\ if (val == param) \\ return #val #endif IF_EQUAL_RETURN(guid, MF_MT_MAJOR_TYPE); IF_EQUAL_RETURN(guid, MF_MT_MAJOR_TYPE); IF_EQUAL_RETURN(guid, MF_MT_SUBTYPE); IF_EQUAL_RETURN(guid, MF_MT_ALL_SAMPLES_INDEPENDENT); IF_EQUAL_RETURN(guid, MF_MT_FIXED_SIZE_SAMPLES); IF_EQUAL_RETURN(guid, MF_MT_COMPRESSED); IF_EQUAL_RETURN(guid, MF_MT_SAMPLE_SIZE); IF_EQUAL_RETURN(guid, MF_MT_WRAPPED_TYPE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_NUM_CHANNELS); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_SAMPLES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_FLOAT_SAMPLES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_AVG_BYTES_PER_SECOND); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_BLOCK_ALIGNMENT); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_BITS_PER_SAMPLE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_VALID_BITS_PER_SAMPLE); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_SAMPLES_PER_BLOCK); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_CHANNEL_MASK); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_FOLDDOWN_MATRIX); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_PEAKREF); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_PEAKTARGET); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_AVGREF); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_WMADRC_AVGTARGET); IF_EQUAL_RETURN(guid, MF_MT_AUDIO_PREFER_WAVEFORMATEX); IF_EQUAL_RETURN(guid, MF_MT_AAC_PAYLOAD_TYPE); IF_EQUAL_RETURN(guid, MF_MT_AAC_AUDIO_PROFILE_LEVEL_INDICATION); IF_EQUAL_RETURN(guid, MF_MT_FRAME_SIZE); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE_RANGE_MAX); IF_EQUAL_RETURN(guid, MF_MT_FRAME_RATE_RANGE_MIN); IF_EQUAL_RETURN(guid, MF_MT_PIXEL_ASPECT_RATIO); IF_EQUAL_RETURN(guid, MF_MT_DRM_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_PAD_CONTROL_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_SOURCE_CONTENT_HINT); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_CHROMA_SITING); IF_EQUAL_RETURN(guid, MF_MT_INTERLACE_MODE); IF_EQUAL_RETURN(guid, MF_MT_TRANSFER_FUNCTION); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_PRIMARIES); IF_EQUAL_RETURN(guid, MF_MT_CUSTOM_VIDEO_PRIMARIES); IF_EQUAL_RETURN(guid, MF_MT_YUV_MATRIX); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_LIGHTING); IF_EQUAL_RETURN(guid, MF_MT_VIDEO_NOMINAL_RANGE); IF_EQUAL_RETURN(guid, MF_MT_GEOMETRIC_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_MINIMUM_DISPLAY_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_PAN_SCAN_APERTURE); IF_EQUAL_RETURN(guid, MF_MT_PAN_SCAN_ENABLED); IF_EQUAL_RETURN(guid, MF_MT_AVG_BITRATE); IF_EQUAL_RETURN(guid, MF_MT_AVG_BIT_ERROR_RATE); IF_EQUAL_RETURN(guid, MF_MT_MAX_KEYFRAME_SPACING); IF_EQUAL_RETURN(guid, MF_MT_DEFAULT_STRIDE); IF_EQUAL_RETURN(guid, MF_MT_PALETTE); IF_EQUAL_RETURN(guid, MF_MT_USER_DATA); IF_EQUAL_RETURN(guid, MF_MT_AM_FORMAT_TYPE); IF_EQUAL_RETURN(guid, MF_MT_MPEG_START_TIME_CODE); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_PROFILE); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_LEVEL); IF_EQUAL_RETURN(guid, MF_MT_MPEG2_FLAGS); IF_EQUAL_RETURN(guid, MF_MT_MPEG_SEQUENCE_HEADER); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_SRC_PACK_0); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_CTRL_PACK_0); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_SRC_PACK_1); IF_EQUAL_RETURN(guid, MF_MT_DV_AAUX_CTRL_PACK_1); IF_EQUAL_RETURN(guid, MF_MT_DV_VAUX_SRC_PACK); IF_EQUAL_RETURN(guid, MF_MT_DV_VAUX_CTRL_PACK); IF_EQUAL_RETURN(guid, MF_MT_ARBITRARY_HEADER); IF_EQUAL_RETURN(guid, MF_MT_ARBITRARY_FORMAT); IF_EQUAL_RETURN(guid, MF_MT_IMAGE_LOSS_TOLERANT); IF_EQUAL_RETURN(guid, MF_MT_MPEG4_SAMPLE_DESCRIPTION); IF_EQUAL_RETURN(guid, MF_MT_MPEG4_CURRENT_SAMPLE_ENTRY); IF_EQUAL_RETURN(guid, MF_MT_ORIGINAL_4CC); IF_EQUAL_RETURN(guid, MF_MT_ORIGINAL_WAVE_FORMAT_TAG); // Media types IF_EQUAL_RETURN(guid, MFMediaType_Audio); IF_EQUAL_RETURN(guid, MFMediaType_Video); IF_EQUAL_RETURN(guid, MFMediaType_Protected); IF_EQUAL_RETURN(guid, MFMediaType_SAMI); IF_EQUAL_RETURN(guid, MFMediaType_Script); IF_EQUAL_RETURN(guid, MFMediaType_Image); IF_EQUAL_RETURN(guid, MFMediaType_HTML); IF_EQUAL_RETURN(guid, MFMediaType_Binary); IF_EQUAL_RETURN(guid, MFMediaType_FileTransfer); IF_EQUAL_RETURN(guid, MFVideoFormat_AI44); // FCC('AI44') IF_EQUAL_RETURN(guid, MFVideoFormat_ARGB32); // D3DFMT_A8R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_AYUV); // FCC('AYUV') IF_EQUAL_RETURN(guid, MFVideoFormat_DV25); // FCC('dv25') IF_EQUAL_RETURN(guid, MFVideoFormat_DV50); // FCC('dv50') IF_EQUAL_RETURN(guid, MFVideoFormat_DVH1); // FCC('dvh1') IF_EQUAL_RETURN(guid, MFVideoFormat_DVSD); // FCC('dvsd') IF_EQUAL_RETURN(guid, MFVideoFormat_DVSL); // FCC('dvsl') IF_EQUAL_RETURN(guid, MFVideoFormat_H264); // FCC('H264') IF_EQUAL_RETURN(guid, MFVideoFormat_H264_ES); // IF_EQUAL_RETURN(guid, MFVideoFormat_I420); // FCC('I420') IF_EQUAL_RETURN(guid, MFVideoFormat_IYUV); // FCC('IYUV') IF_EQUAL_RETURN(guid, MFVideoFormat_M4S2); // FCC('M4S2') IF_EQUAL_RETURN(guid, MFVideoFormat_MJPG); IF_EQUAL_RETURN(guid, MFVideoFormat_MP43); // FCC('MP43') IF_EQUAL_RETURN(guid, MFVideoFormat_MP4S); // FCC('MP4S') IF_EQUAL_RETURN(guid, MFVideoFormat_MP4V); // FCC('MP4V') IF_EQUAL_RETURN(guid, MFVideoFormat_MPG1); // FCC('MPG1') IF_EQUAL_RETURN(guid, MFVideoFormat_MSS1); // FCC('MSS1') IF_EQUAL_RETURN(guid, MFVideoFormat_MSS2); // FCC('MSS2') IF_EQUAL_RETURN(guid, MFVideoFormat_NV11); // FCC('NV11') IF_EQUAL_RETURN(guid, MFVideoFormat_NV12); // FCC('NV12') IF_EQUAL_RETURN(guid, MFVideoFormat_P010); // FCC('P010') IF_EQUAL_RETURN(guid, MFVideoFormat_P016); // FCC('P016') IF_EQUAL_RETURN(guid, MFVideoFormat_P210); // FCC('P210') IF_EQUAL_RETURN(guid, MFVideoFormat_P216); // FCC('P216') IF_EQUAL_RETURN(guid, MFVideoFormat_RGB24); // D3DFMT_R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB32); // D3DFMT_X8R8G8B8 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB555); // D3DFMT_X1R5G5B5 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB565); // D3DFMT_R5G6B5 IF_EQUAL_RETURN(guid, MFVideoFormat_RGB8); IF_EQUAL_RETURN(guid, MFVideoFormat_UYVY); // FCC('UYVY') IF_EQUAL_RETURN(guid, MFVideoFormat_v210); // FCC('v210') IF_EQUAL_RETURN(guid, MFVideoFormat_v410); // FCC('v410') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV1); // FCC('WMV1') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV2); // FCC('WMV2') IF_EQUAL_RETURN(guid, MFVideoFormat_WMV3); // FCC('WMV3') IF_EQUAL_RETURN(guid, MFVideoFormat_WVC1); // FCC('WVC1') IF_EQUAL_RETURN(guid, MFVideoFormat_Y210); // FCC('Y210') IF_EQUAL_RETURN(guid, MFVideoFormat_Y216); // FCC('Y216') IF_EQUAL_RETURN(guid, MFVideoFormat_Y410); // FCC('Y410') IF_EQUAL_RETURN(guid, MFVideoFormat_Y416); // FCC('Y416') IF_EQUAL_RETURN(guid, MFVideoFormat_Y41P); IF_EQUAL_RETURN(guid, MFVideoFormat_Y41T); IF_EQUAL_RETURN(guid, MFVideoFormat_YUY2); // FCC('YUY2') IF_EQUAL_RETURN(guid, MFVideoFormat_YV12); // FCC('YV12') IF_EQUAL_RETURN(guid, MFVideoFormat_YVYU); IF_EQUAL_RETURN(guid, MFAudioFormat_PCM); // WAVE_FORMAT_PCM IF_EQUAL_RETURN(guid, MFAudioFormat_Float); // WAVE_FORMAT_IEEE_FLOAT IF_EQUAL_RETURN(guid, MFAudioFormat_DTS); // WAVE_FORMAT_DTS IF_EQUAL_RETURN(guid, MFAudioFormat_Dolby_AC3_SPDIF); // WAVE_FORMAT_DOLBY_AC3_SPDIF IF_EQUAL_RETURN(guid, MFAudioFormat_DRM); // WAVE_FORMAT_DRM IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudioV8); // WAVE_FORMAT_WMAUDIO2 IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudioV9); // WAVE_FORMAT_WMAUDIO3 IF_EQUAL_RETURN(guid, MFAudioFormat_WMAudio_Lossless); // WAVE_FORMAT_WMAUDIO_LOSSLESS IF_EQUAL_RETURN(guid, MFAudioFormat_WMASPDIF); // WAVE_FORMAT_WMASPDIF IF_EQUAL_RETURN(guid, MFAudioFormat_MSP1); // WAVE_FORMAT_WMAVOICE9 IF_EQUAL_RETURN(guid, MFAudioFormat_MP3); // WAVE_FORMAT_MPEGLAYER3 IF_EQUAL_RETURN(guid, MFAudioFormat_MPEG); // WAVE_FORMAT_MPEG IF_EQUAL_RETURN(guid, MFAudioFormat_AAC); // WAVE_FORMAT_MPEG_HEAAC IF_EQUAL_RETURN(guid, MFAudioFormat_ADTS); // WAVE_FORMAT_MPEG_ADTS_AAC #undef IF_EQUAL_RETURN return NULL; }","title":"File media.cpp"},{"location":"media_8hpp/","text":"File media.hpp File List > src > media.hpp Go to the source code of this file. #include <winrt/Windows.Foundation.h> #include <winrt/Windows.System.Threading.h> #include <experimental/generator> #include <gsl/gsl> #include <comdef.h> #include <mfapi.h> #include <mferror.h> #include <mfidl.h> #include <mfreadwrite.h> #include <shlwapi.h> #include <wmcodecdsp.h> #include <wrl/client.h> Classes Type Name class qpc_timer_t Public Functions Type Name HRESULT configure (ComPtr< IMFStreamDescriptor > stream) noexcept HRESULT create_and_copy_single_buffer_sample (IMFSample * src, IMFSample ** dst) HRESULT create_single_buffer_sample (DWORD bufsz, IMFSample ** sample) auto decode (ComPtr< IMFSourceReader > source_reader, ComPtr< IMFTransform > decoding_transform) noexcept HRESULT get_devices (IMFAttributes * attrs, std::vector< ComPtr< IMFActivate >> & devices) noexcept HRESULT get_name (IMFActivate * device, std::wstring & name) noexcept gsl::czstring get_name (const GUID & guid) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) HRESULT get_transform_output (IMFTransform * transform, IMFSample ** sample, BOOL & flushed) auto media_startup () noexcept Public Functions Documentation function configure HRESULT configure ( ComPtr< IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video function create_and_copy_single_buffer_sample HRESULT create_and_copy_single_buffer_sample ( IMFSample * src, IMFSample ** dst ) function create_single_buffer_sample HRESULT create_single_buffer_sample ( DWORD bufsz, IMFSample ** sample ) function decode auto decode ( ComPtr< IMFSourceReader > source_reader, ComPtr< IMFTransform > decoding_transform ) noexcept function get_devices HRESULT get_devices ( IMFAttributes * attrs, std::vector< ComPtr< IMFActivate >> & devices ) noexcept See also: MFEnumDeviceSources function get_name HRESULT get_name ( IMFActivate * device, std::wstring & name ) noexcept function get_name gsl::czstring get_name ( const GUID & guid ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/media-type-debugging-code function get_stream_descriptor HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr ) function get_transform_output HRESULT get_transform_output ( IMFTransform * transform, IMFSample ** sample, BOOL & flushed ) function media_startup auto media_startup () noexcept See also: MFStartup See also: MFShutdown Exception: winrt::hresult_error The documentation for this class was generated from the following file src/media.hpp","title":"File media.hpp"},{"location":"media_8hpp/#file-mediahpp","text":"File List > src > media.hpp Go to the source code of this file. #include <winrt/Windows.Foundation.h> #include <winrt/Windows.System.Threading.h> #include <experimental/generator> #include <gsl/gsl> #include <comdef.h> #include <mfapi.h> #include <mferror.h> #include <mfidl.h> #include <mfreadwrite.h> #include <shlwapi.h> #include <wmcodecdsp.h> #include <wrl/client.h>","title":"File media.hpp"},{"location":"media_8hpp/#classes","text":"Type Name class qpc_timer_t","title":"Classes"},{"location":"media_8hpp/#public-functions","text":"Type Name HRESULT configure (ComPtr< IMFStreamDescriptor > stream) noexcept HRESULT create_and_copy_single_buffer_sample (IMFSample * src, IMFSample ** dst) HRESULT create_single_buffer_sample (DWORD bufsz, IMFSample ** sample) auto decode (ComPtr< IMFSourceReader > source_reader, ComPtr< IMFTransform > decoding_transform) noexcept HRESULT get_devices (IMFAttributes * attrs, std::vector< ComPtr< IMFActivate >> & devices) noexcept HRESULT get_name (IMFActivate * device, std::wstring & name) noexcept gsl::czstring get_name (const GUID & guid) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) HRESULT get_transform_output (IMFTransform * transform, IMFSample ** sample, BOOL & flushed) auto media_startup () noexcept","title":"Public Functions"},{"location":"media_8hpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"media_8hpp/#function-configure","text":"HRESULT configure ( ComPtr< IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video","title":"function configure"},{"location":"media_8hpp/#function-create_and_copy_single_buffer_sample","text":"HRESULT create_and_copy_single_buffer_sample ( IMFSample * src, IMFSample ** dst )","title":"function create_and_copy_single_buffer_sample"},{"location":"media_8hpp/#function-create_single_buffer_sample","text":"HRESULT create_single_buffer_sample ( DWORD bufsz, IMFSample ** sample )","title":"function create_single_buffer_sample"},{"location":"media_8hpp/#function-decode","text":"auto decode ( ComPtr< IMFSourceReader > source_reader, ComPtr< IMFTransform > decoding_transform ) noexcept","title":"function decode"},{"location":"media_8hpp/#function-get_devices","text":"HRESULT get_devices ( IMFAttributes * attrs, std::vector< ComPtr< IMFActivate >> & devices ) noexcept See also: MFEnumDeviceSources","title":"function get_devices"},{"location":"media_8hpp/#function-get_name","text":"HRESULT get_name ( IMFActivate * device, std::wstring & name ) noexcept","title":"function get_name"},{"location":"media_8hpp/#function-get_name_1","text":"gsl::czstring get_name ( const GUID & guid ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/media-type-debugging-code","title":"function get_name"},{"location":"media_8hpp/#function-get_stream_descriptor","text":"HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr )","title":"function get_stream_descriptor"},{"location":"media_8hpp/#function-get_transform_output","text":"HRESULT get_transform_output ( IMFTransform * transform, IMFSample ** sample, BOOL & flushed )","title":"function get_transform_output"},{"location":"media_8hpp/#function-media_startup","text":"auto media_startup () noexcept See also: MFStartup See also: MFShutdown Exception: winrt::hresult_error The documentation for this class was generated from the following file src/media.hpp","title":"function media_startup"},{"location":"media_8hpp_source/","text":"File media.hpp File List > src > media.hpp Go to the documentation of this file. #pragma once #include <winrt/Windows.Foundation.h> #include <winrt/Windows.System.Threading.h> #include <experimental/generator> #include <gsl/gsl> #include <comdef.h> #include <mfapi.h> #include <mferror.h> #include <mfidl.h> #include <mfreadwrite.h> #include <shlwapi.h> #include <wmcodecdsp.h> #include <wrl/client.h> using Microsoft::WRL::ComPtr; auto media_startup() noexcept(false) -> gsl::final_action<HRESULT(WINAPI*)()>; HRESULT get_devices(IMFAttributes* attrs, std::vector<ComPtr<IMFActivate>>& devices) noexcept; HRESULT get_name(IMFActivate* device, std::wstring& name) noexcept; gsl::czstring<> get_name(const GUID& guid) noexcept; HRESULT get_stream_descriptor(IMFPresentationDescriptor* presentation, IMFStreamDescriptor** ptr); HRESULT configure(ComPtr<IMFStreamDescriptor> stream) noexcept; class qpc_timer_t final { LARGE_INTEGER start{}, const frequency{}; public: qpc_timer_t() noexcept { QueryPerformanceFrequency(&frequency); QueryPerformanceCounter(&start); } auto pick() const noexcept { LARGE_INTEGER end{}; QueryPerformanceCounter(&end); const auto elapsed = end.QuadPart - start.QuadPart; return (elapsed * 1'000) / frequency.QuadPart; } auto reset() noexcept { auto d = pick(); QueryPerformanceCounter(&start); return d; } }; auto decode(ComPtr<IMFSourceReader> source_reader, ComPtr<IMFTransform> decoding_transform) noexcept(false) -> std::experimental::generator<ComPtr<IMFSample>>; HRESULT create_single_buffer_sample(DWORD bufsz, IMFSample** sample); HRESULT create_and_copy_single_buffer_sample(IMFSample* src, IMFSample** dst); HRESULT get_transform_output(IMFTransform* transform, IMFSample** sample, BOOL& flushed);","title":"File media.hpp"},{"location":"media_8hpp_source/#file-mediahpp","text":"File List > src > media.hpp Go to the documentation of this file. #pragma once #include <winrt/Windows.Foundation.h> #include <winrt/Windows.System.Threading.h> #include <experimental/generator> #include <gsl/gsl> #include <comdef.h> #include <mfapi.h> #include <mferror.h> #include <mfidl.h> #include <mfreadwrite.h> #include <shlwapi.h> #include <wmcodecdsp.h> #include <wrl/client.h> using Microsoft::WRL::ComPtr; auto media_startup() noexcept(false) -> gsl::final_action<HRESULT(WINAPI*)()>; HRESULT get_devices(IMFAttributes* attrs, std::vector<ComPtr<IMFActivate>>& devices) noexcept; HRESULT get_name(IMFActivate* device, std::wstring& name) noexcept; gsl::czstring<> get_name(const GUID& guid) noexcept; HRESULT get_stream_descriptor(IMFPresentationDescriptor* presentation, IMFStreamDescriptor** ptr); HRESULT configure(ComPtr<IMFStreamDescriptor> stream) noexcept; class qpc_timer_t final { LARGE_INTEGER start{}, const frequency{}; public: qpc_timer_t() noexcept { QueryPerformanceFrequency(&frequency); QueryPerformanceCounter(&start); } auto pick() const noexcept { LARGE_INTEGER end{}; QueryPerformanceCounter(&end); const auto elapsed = end.QuadPart - start.QuadPart; return (elapsed * 1'000) / frequency.QuadPart; } auto reset() noexcept { auto d = pick(); QueryPerformanceCounter(&start); return d; } }; auto decode(ComPtr<IMFSourceReader> source_reader, ComPtr<IMFTransform> decoding_transform) noexcept(false) -> std::experimental::generator<ComPtr<IMFSample>>; HRESULT create_single_buffer_sample(DWORD bufsz, IMFSample** sample); HRESULT create_and_copy_single_buffer_sample(IMFSample* src, IMFSample** dst); HRESULT get_transform_output(IMFTransform* transform, IMFSample** sample, BOOL& flushed);","title":"File media.hpp"},{"location":"modules/","text":"Modules Here is a list of all modules:","title":"Modules"},{"location":"modules/#modules","text":"Here is a list of all modules:","title":"Modules"},{"location":"namespaceMicrosoft_1_1WRL/","text":"Namespace Microsoft::WRL Class List > WRL The documentation for this class was generated from the following file src/media.cpp","title":"Namespace Microsoft::WRL"},{"location":"namespaceMicrosoft_1_1WRL/#namespace-microsoftwrl","text":"Class List > WRL The documentation for this class was generated from the following file src/media.cpp","title":"Namespace Microsoft::WRL"},{"location":"namespace_member_enums/","text":"Namespace Member Enums","title":"Namespace Member Enums"},{"location":"namespace_member_enums/#namespace-member-enums","text":"","title":"Namespace Member Enums"},{"location":"namespace_member_functions/","text":"Namespace Member Functions","title":"Namespace Member Functions"},{"location":"namespace_member_functions/#namespace-member-functions","text":"","title":"Namespace Member Functions"},{"location":"namespace_member_typedefs/","text":"Namespace Member Typedefs","title":"Namespace Member Typedefs"},{"location":"namespace_member_typedefs/#namespace-member-typedefs","text":"","title":"Namespace Member Typedefs"},{"location":"namespace_member_variables/","text":"Namespace Member Variables","title":"Namespace Member Variables"},{"location":"namespace_member_variables/#namespace-member-variables","text":"","title":"Namespace Member Variables"},{"location":"namespace_members/","text":"Namespace Members","title":"Namespace Members"},{"location":"namespace_members/#namespace-members","text":"","title":"Namespace Members"},{"location":"namespaces/","text":"Namespace List Here is a list of all namespaces with brief descriptions: namespace WRL namespace std","title":"Namespace List"},{"location":"namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace WRL namespace std","title":"Namespace List"},{"location":"namespacestd/","text":"Namespace std Class List > std The documentation for this class was generated from the following file src/media.cpp","title":"Namespace std"},{"location":"namespacestd/#namespace-std","text":"Class List > std The documentation for this class was generated from the following file src/media.cpp","title":"Namespace std"},{"location":"pages/","text":"Related Pages Here is a list of all related documentation pages: Todo List","title":"Related Pages"},{"location":"pages/#related-pages","text":"Here is a list of all related documentation pages: Todo List","title":"Related Pages"},{"location":"structcritical__section__t/","text":"Struct critical_section_t Class List > critical_section_t Inherits the following classes: CRITICAL_SECTION Public Functions Type Name critical_section_t () noexcept void lock () noexcept bool try_lock () noexcept void unlock () noexcept ~critical_section_t () noexcept Public Functions Documentation function critical_section_t inline critical_section_t::critical_section_t () noexcept function lock inline void critical_section_t::lock () noexcept function try_lock inline bool critical_section_t::try_lock () noexcept function unlock inline void critical_section_t::unlock () noexcept function ~critical_section_t inline critical_section_t::~critical_section_t () noexcept The documentation for this class was generated from the following file src/media.cpp","title":"Struct critical\\_section\\_t"},{"location":"structcritical__section__t/#struct-critical_section_t","text":"Class List > critical_section_t Inherits the following classes: CRITICAL_SECTION","title":"Struct critical_section_t"},{"location":"structcritical__section__t/#public-functions","text":"Type Name critical_section_t () noexcept void lock () noexcept bool try_lock () noexcept void unlock () noexcept ~critical_section_t () noexcept","title":"Public Functions"},{"location":"structcritical__section__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"structcritical__section__t/#function-critical_section_t","text":"inline critical_section_t::critical_section_t () noexcept","title":"function critical_section_t"},{"location":"structcritical__section__t/#function-lock","text":"inline void critical_section_t::lock () noexcept","title":"function lock"},{"location":"structcritical__section__t/#function-try_lock","text":"inline bool critical_section_t::try_lock () noexcept","title":"function try_lock"},{"location":"structcritical__section__t/#function-unlock","text":"inline void critical_section_t::unlock () noexcept","title":"function unlock"},{"location":"structcritical__section__t/#function-critical_section_t_1","text":"inline critical_section_t::~critical_section_t () noexcept The documentation for this class was generated from the following file src/media.cpp","title":"function ~critical_section_t"},{"location":"todo/","text":"Todo List Class qpc_timer_t use static_assert for Windows SDK","title":"Todo List"},{"location":"todo/#todo-list","text":"","title":"Todo List"},{"location":"todo/#class-qpc_timer_t","text":"use static_assert for Windows SDK","title":"Class qpc_timer_t"},{"location":"variables/","text":"Variables","title":"Variables"},{"location":"variables/#variables","text":"","title":"Variables"}]}