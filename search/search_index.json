{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"annotated/","text":"Class List \u00b6 Here are the classes, structs, unions and interfaces with brief descriptions: namespace WRL struct critical_section_t class device_group_t class process_timer_t struct read_item_t namespace std","title":"Class List"},{"location":"annotated/#class-list","text":"Here are the classes, structs, unions and interfaces with brief descriptions: namespace WRL struct critical_section_t class device_group_t class process_timer_t struct read_item_t namespace std","title":"Class List"},{"location":"class_member_enums/","text":"Class Member Enums \u00b6","title":"Class Member Enums"},{"location":"class_member_enums/#class-member-enums","text":"","title":"Class Member Enums"},{"location":"class_member_functions/","text":"Class Member Functions \u00b6 c \u00b6 critical_section_t ( critical_section_t ) d \u00b6 device_group_t ( device_group_t ) l \u00b6 lock ( critical_section_t ) p \u00b6 pick ( process_timer_t ) r \u00b6 reset ( process_timer_t ) t \u00b6 try_lock ( critical_section_t ) u \u00b6 unlock ( critical_section_t ) ~ \u00b6 ~critical_section_t ( critical_section_t )","title":"Class Member Functions"},{"location":"class_member_functions/#class-member-functions","text":"","title":"Class Member Functions"},{"location":"class_member_functions/#c","text":"critical_section_t ( critical_section_t )","title":"c"},{"location":"class_member_functions/#d","text":"device_group_t ( device_group_t )","title":"d"},{"location":"class_member_functions/#l","text":"lock ( critical_section_t )","title":"l"},{"location":"class_member_functions/#p","text":"pick ( process_timer_t )","title":"p"},{"location":"class_member_functions/#r","text":"reset ( process_timer_t )","title":"r"},{"location":"class_member_functions/#t","text":"try_lock ( critical_section_t )","title":"t"},{"location":"class_member_functions/#u","text":"unlock ( critical_section_t )","title":"u"},{"location":"class_member_functions/#_1","text":"~critical_section_t ( critical_section_t )","title":"~"},{"location":"class_member_typedefs/","text":"Class Member Typedefs \u00b6","title":"Class Member Typedefs"},{"location":"class_member_typedefs/#class-member-typedefs","text":"","title":"Class Member Typedefs"},{"location":"class_member_variables/","text":"Class Member Variables \u00b6 a \u00b6 attrs ( device_group_t ) d \u00b6 devices ( device_group_t ) f \u00b6 flags ( read_item_t ) i \u00b6 index ( read_item_t ) s \u00b6 start ( process_timer_t ) sample ( read_item_t ) status ( read_item_t ) t \u00b6 timestamp ( read_item_t )","title":"Class Member Variables"},{"location":"class_member_variables/#class-member-variables","text":"","title":"Class Member Variables"},{"location":"class_member_variables/#a","text":"attrs ( device_group_t )","title":"a"},{"location":"class_member_variables/#d","text":"devices ( device_group_t )","title":"d"},{"location":"class_member_variables/#f","text":"flags ( read_item_t )","title":"f"},{"location":"class_member_variables/#i","text":"index ( read_item_t )","title":"i"},{"location":"class_member_variables/#s","text":"start ( process_timer_t ) sample ( read_item_t ) status ( read_item_t )","title":"s"},{"location":"class_member_variables/#t","text":"timestamp ( read_item_t )","title":"t"},{"location":"class_members/","text":"Class Members \u00b6 a \u00b6 attrs ( device_group_t ) c \u00b6 critical_section_t ( critical_section_t ) d \u00b6 device_group_t ( device_group_t ) devices ( device_group_t ) f \u00b6 flags ( read_item_t ) i \u00b6 index ( read_item_t ) l \u00b6 lock ( critical_section_t ) p \u00b6 pick ( process_timer_t ) r \u00b6 reset ( process_timer_t ) s \u00b6 start ( process_timer_t ) sample ( read_item_t ) status ( read_item_t ) t \u00b6 try_lock ( critical_section_t ) timestamp ( read_item_t ) u \u00b6 unlock ( critical_section_t ) ~ \u00b6 ~critical_section_t ( critical_section_t )","title":"Class Members"},{"location":"class_members/#class-members","text":"","title":"Class Members"},{"location":"class_members/#a","text":"attrs ( device_group_t )","title":"a"},{"location":"class_members/#c","text":"critical_section_t ( critical_section_t )","title":"c"},{"location":"class_members/#d","text":"device_group_t ( device_group_t ) devices ( device_group_t )","title":"d"},{"location":"class_members/#f","text":"flags ( read_item_t )","title":"f"},{"location":"class_members/#i","text":"index ( read_item_t )","title":"i"},{"location":"class_members/#l","text":"lock ( critical_section_t )","title":"l"},{"location":"class_members/#p","text":"pick ( process_timer_t )","title":"p"},{"location":"class_members/#r","text":"reset ( process_timer_t )","title":"r"},{"location":"class_members/#s","text":"start ( process_timer_t ) sample ( read_item_t ) status ( read_item_t )","title":"s"},{"location":"class_members/#t","text":"try_lock ( critical_section_t ) timestamp ( read_item_t )","title":"t"},{"location":"class_members/#u","text":"unlock ( critical_section_t )","title":"u"},{"location":"class_members/#_1","text":"~critical_section_t ( critical_section_t )","title":"~"},{"location":"classdevice__group__t/","text":"Class device_group_t \u00b6 Class List > device_group_t Public Attributes \u00b6 Type Name ComPtr< IMFAttributes > attrs = {} std::vector< ComPtr< IMFActivate > > devices = {} Public Functions \u00b6 Type Name device_group_t () noexcept Public Attributes Documentation \u00b6 variable attrs \u00b6 ComPtr < IMFAttributes > device_group_t :: attrs ; variable devices \u00b6 std :: vector < ComPtr < IMFActivate > > device_group_t :: devices ; Public Functions Documentation \u00b6 function device_group_t \u00b6 device_group_t :: device_group_t () noexcept Exception: _com_error The documentation for this class was generated from the following file src/media.hpp","title":"Class device\\_group\\_t"},{"location":"classdevice__group__t/#class-device_group_t","text":"Class List > device_group_t","title":"Class device_group_t"},{"location":"classdevice__group__t/#public-attributes","text":"Type Name ComPtr< IMFAttributes > attrs = {} std::vector< ComPtr< IMFActivate > > devices = {}","title":"Public Attributes"},{"location":"classdevice__group__t/#public-functions","text":"Type Name device_group_t () noexcept","title":"Public Functions"},{"location":"classdevice__group__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"classdevice__group__t/#variable-attrs","text":"ComPtr < IMFAttributes > device_group_t :: attrs ;","title":"variable attrs"},{"location":"classdevice__group__t/#variable-devices","text":"std :: vector < ComPtr < IMFActivate > > device_group_t :: devices ;","title":"variable devices"},{"location":"classdevice__group__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classdevice__group__t/#function-device_group_t","text":"device_group_t :: device_group_t () noexcept Exception: _com_error The documentation for this class was generated from the following file src/media.hpp","title":"function device_group_t"},{"location":"classes/","text":"Class Index \u00b6 c \u00b6 critical_section_t d \u00b6 device_group_t p \u00b6 process_timer_t r \u00b6 read_item_t","title":"Classes"},{"location":"classes/#class-index","text":"","title":"Class Index"},{"location":"classes/#c","text":"critical_section_t","title":"c"},{"location":"classes/#d","text":"device_group_t","title":"d"},{"location":"classes/#p","text":"process_timer_t","title":"p"},{"location":"classes/#r","text":"read_item_t","title":"r"},{"location":"classprocess__timer__t/","text":"Class process_timer_t \u00b6 Class List > process_timer_t More... #include <media.hpp> Public Functions \u00b6 Type Name float pick () noexcept const float reset () noexcept Detailed Description \u00b6 See also: clock_gettime, CLOCKS_PER_SEC Public Functions Documentation \u00b6 function pick \u00b6 inline float process_timer_t :: pick () noexcept const Returns: float elapsed second function reset \u00b6 inline float process_timer_t :: reset () noexcept The documentation for this class was generated from the following file src/media.hpp","title":"Class process\\_timer\\_t"},{"location":"classprocess__timer__t/#class-process_timer_t","text":"Class List > process_timer_t More... #include <media.hpp>","title":"Class process_timer_t"},{"location":"classprocess__timer__t/#public-functions","text":"Type Name float pick () noexcept const float reset () noexcept","title":"Public Functions"},{"location":"classprocess__timer__t/#detailed-description","text":"See also: clock_gettime, CLOCKS_PER_SEC","title":"Detailed Description"},{"location":"classprocess__timer__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"classprocess__timer__t/#function-pick","text":"inline float process_timer_t :: pick () noexcept const Returns: float elapsed second","title":"function pick"},{"location":"classprocess__timer__t/#function-reset","text":"inline float process_timer_t :: reset () noexcept The documentation for this class was generated from the following file src/media.hpp","title":"function reset"},{"location":"dir_68267d1309a1af8e8297ef4c3efbcdba/","text":"Dir src \u00b6 File List > src Files \u00b6 Type Name file media.cpp file media.hpp The documentation for this class was generated from the following file src/","title":"Dir src"},{"location":"dir_68267d1309a1af8e8297ef4c3efbcdba/#dir-src","text":"File List > src","title":"Dir src"},{"location":"dir_68267d1309a1af8e8297ef4c3efbcdba/#files","text":"Type Name file media.cpp file media.hpp The documentation for this class was generated from the following file src/","title":"Files"},{"location":"files/","text":"File List \u00b6 Here is a list of all files with brief descriptions: dir src file media.cpp file media.hpp","title":"File List"},{"location":"files/#file-list","text":"Here is a list of all files with brief descriptions: dir src file media.cpp file media.hpp","title":"File List"},{"location":"functions/","text":"Functions \u00b6 c \u00b6 configure ( media.cpp , media.hpp ) g \u00b6 get_devices ( media.cpp , media.hpp ) get_name ( media.cpp , media.hpp ) get_stream_descriptor ( media.cpp , media.hpp ) p \u00b6 print ( media.cpp ) s \u00b6 startup ( media.cpp , media.hpp )","title":"Functions"},{"location":"functions/#functions","text":"","title":"Functions"},{"location":"functions/#c","text":"configure ( media.cpp , media.hpp )","title":"c"},{"location":"functions/#g","text":"get_devices ( media.cpp , media.hpp ) get_name ( media.cpp , media.hpp ) get_stream_descriptor ( media.cpp , media.hpp )","title":"g"},{"location":"functions/#p","text":"print ( media.cpp )","title":"p"},{"location":"functions/#s","text":"startup ( media.cpp , media.hpp )","title":"s"},{"location":"hierarchy/","text":"Class Hierarchy \u00b6 This inheritance list is sorted roughly, but not completely, alphabetically: class device_group_t class process_timer_t struct read_item_t class CRITICAL_SECTION struct critical_section_t","title":"Class Hierarchy"},{"location":"hierarchy/#class-hierarchy","text":"This inheritance list is sorted roughly, but not completely, alphabetically: class device_group_t class process_timer_t struct read_item_t class CRITICAL_SECTION struct critical_section_t","title":"Class Hierarchy"},{"location":"macros/","text":"Macros \u00b6","title":"Macros"},{"location":"macros/#macros","text":"","title":"Macros"},{"location":"media_8cpp/","text":"File media.cpp \u00b6 File List > src > media.cpp Go to the source code of this file. #include <winrt/Windows.Foundation.h> #include \"media.hpp\" Namespaces \u00b6 Type Name namespace WRL namespace std Classes \u00b6 Type Name struct critical_section_t Public Functions \u00b6 Type Name HRESULT configure (ComPtr< IMFStreamDescriptor > stream) noexcept HRESULT get_devices (IMFAttributes * attrs, vector< ComPtr< IMFActivate >> & devices) noexcept HRESULT get_name (IMFActivate * device, wstring & name) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) void print (IMFMediaType * media) noexcept auto startup () Public Functions Documentation \u00b6 function configure \u00b6 HRESULT configure ( ComPtr < IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video function get_devices \u00b6 HRESULT get_devices ( IMFAttributes * attrs , vector < ComPtr < IMFActivate >> & devices ) noexcept function get_name \u00b6 HRESULT get_name ( IMFActivate * device , wstring & name ) noexcept function get_stream_descriptor \u00b6 HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation , IMFStreamDescriptor ** ptr ) function print \u00b6 void print ( IMFMediaType * media ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-subtype-guids See also: https://stackoverflow.com/a/9681384 function startup \u00b6 auto startup () The documentation for this class was generated from the following file src/media.cpp","title":"File media.cpp"},{"location":"media_8cpp/#file-mediacpp","text":"File List > src > media.cpp Go to the source code of this file. #include <winrt/Windows.Foundation.h> #include \"media.hpp\"","title":"File media.cpp"},{"location":"media_8cpp/#namespaces","text":"Type Name namespace WRL namespace std","title":"Namespaces"},{"location":"media_8cpp/#classes","text":"Type Name struct critical_section_t","title":"Classes"},{"location":"media_8cpp/#public-functions","text":"Type Name HRESULT configure (ComPtr< IMFStreamDescriptor > stream) noexcept HRESULT get_devices (IMFAttributes * attrs, vector< ComPtr< IMFActivate >> & devices) noexcept HRESULT get_name (IMFActivate * device, wstring & name) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) void print (IMFMediaType * media) noexcept auto startup ()","title":"Public Functions"},{"location":"media_8cpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"media_8cpp/#function-configure","text":"HRESULT configure ( ComPtr < IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video","title":"function configure"},{"location":"media_8cpp/#function-get_devices","text":"HRESULT get_devices ( IMFAttributes * attrs , vector < ComPtr < IMFActivate >> & devices ) noexcept","title":"function get_devices"},{"location":"media_8cpp/#function-get_name","text":"HRESULT get_name ( IMFActivate * device , wstring & name ) noexcept","title":"function get_name"},{"location":"media_8cpp/#function-get_stream_descriptor","text":"HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation , IMFStreamDescriptor ** ptr )","title":"function get_stream_descriptor"},{"location":"media_8cpp/#function-print","text":"void print ( IMFMediaType * media ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-subtype-guids See also: https://stackoverflow.com/a/9681384","title":"function print"},{"location":"media_8cpp/#function-startup","text":"auto startup () The documentation for this class was generated from the following file src/media.cpp","title":"function startup"},{"location":"media_8cpp_source/","text":"File media.cpp \u00b6 File List > src > media.cpp Go to the documentation of this file. #include <winrt/Windows.Foundation.h> #include \"media.hpp\" using namespace std ; using namespace Microsoft :: WRL ; struct critical_section_t final : public CRITICAL_SECTION { public : critical_section_t () noexcept : CRITICAL_SECTION {} { InitializeCriticalSection ( this ); } ~ critical_section_t () noexcept { DeleteCriticalSection ( this ); } bool try_lock () noexcept { return TryEnterCriticalSection ( this ); } void lock () noexcept { return EnterCriticalSection ( this ); } void unlock () noexcept { return LeaveCriticalSection ( this ); } }; auto startup () -> gsl :: final_action < HRESULT ( WINAPI * )() > { switch ( auto hr = CoInitializeEx ( NULL , COINIT_APARTMENTTHREADED )) { case CO_E_NOTINITIALIZED : throw _com_error { hr }; default : break ; } if ( MFStartup ( MF_VERSION ) != S_OK ) throw runtime_error { \"MFStartup\" }; return gsl :: finally ( & MFShutdown ); } HRESULT get_devices ( IMFAttributes * attrs , vector < ComPtr < IMFActivate >>& devices ) noexcept { IMFActivate ** handles = nullptr ; UINT32 count = 0 ; HRESULT hr = MFEnumDeviceSources ( attrs , & handles , & count ); if FAILED ( hr ) return hr ; auto on_return = gsl :: finally ([ handles ]() { CoTaskMemFree ( handles ); }); for ( auto i = 0u ; i < count ; ++ i ) devices . emplace_back ( move ( handles [ i ])); return S_OK ; } HRESULT get_name ( IMFActivate * device , wstring & name ) noexcept { constexpr UINT32 max_size = 255 ; WCHAR buf [ max_size ]{}; UINT32 buflen {}; HRESULT hr = device -> GetString ( MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME , buf , max_size , & buflen ); if ( SUCCEEDED ( hr )) name = { buf , buflen }; return hr ; } HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation , IMFStreamDescriptor ** ptr ) { DWORD num_stream = 0 ; if ( auto hr = presentation -> GetStreamDescriptorCount ( & num_stream ); SUCCEEDED ( hr ) == false ) return hr ; for ( auto i = 0u ; i < num_stream ; ++ i ) { BOOL selected = false ; if ( auto hr = presentation -> GetStreamDescriptorByIndex ( i , & selected , ptr ); FAILED ( hr )) { return hr ; } if ( selected ) break ; } return S_OK ; } void print ( IMFMediaType * media ) noexcept ; HRESULT configure ( ComPtr < IMFStreamDescriptor > stream ) noexcept { ComPtr < IMFMediaTypeHandler > handler {}; if ( auto hr = stream -> GetMediaTypeHandler ( handler . GetAddressOf ()); SUCCEEDED ( hr ) == false ) return hr ; DWORD num_types = 0 ; if ( auto hr = handler -> GetMediaTypeCount ( & num_types ); SUCCEEDED ( hr ) == false ) return hr ; ComPtr < IMFMediaType > type {}; for ( auto i = 0u ; i < num_types ; ++ i ) { ComPtr < IMFMediaType > current {}; if ( auto hr = handler -> GetMediaTypeByIndex ( i , current . GetAddressOf ()); FAILED ( hr )) return hr ; if ( type == nullptr ) type = current ; print ( current . Get ()); } GUID subtype {}; type -> GetGUID ( MF_MT_SUBTYPE , & subtype ); UINT32 interlace = 0 ; type -> GetUINT32 ( MF_MT_INTERLACE_MODE , & interlace ); const auto imode = static_cast < MFVideoInterlaceMode > ( interlace ); UINT32 stride = 0 ; type -> GetUINT32 ( MF_MT_DEFAULT_STRIDE , & stride ); UINT32 ycbcr2rgb = 0 ; type -> GetUINT32 ( MF_MT_YUV_MATRIX , & ycbcr2rgb ); const auto matrix = static_cast < MFVideoTransferMatrix > ( ycbcr2rgb ); UINT64 size = 0 ; type -> GetUINT64 ( MF_MT_FRAME_SIZE , & size ); // MFGetAttributeSize UINT32 w = size >> 32 , h = size & UINT32_MAX ; UINT64 framerate = 0 ; type -> GetUINT64 ( MF_MT_FRAME_RATE_RANGE_MAX , & framerate ); type -> SetUINT64 ( MF_MT_FRAME_RATE , framerate ); framerate = framerate >> 32 ; return handler -> SetCurrentMediaType ( type . Get ()); } device_group_t :: device_group_t () noexcept ( false ) { if ( auto hr = MFCreateAttributes ( attrs . GetAddressOf (), 1 ); // FAILED ( hr )) throw _com_error { hr }; if ( auto hr = attrs -> SetGUID ( MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE , // MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID ); FAILED ( hr )) throw _com_error { hr }; if ( auto hr = get_devices ( attrs . Get (), devices ); // FAILED ( hr )) throw _com_error { hr }; } void print ( IMFMediaType * media ) noexcept { GUID major {}; media -> GetGUID ( MF_MT_MAJOR_TYPE , & major ); if ( major == MFMediaType_Default ) fprintf ( stdout , \"default \\n \" ); else if ( major == MFMediaType_Video ) fprintf ( stdout , \"video \\n \" ); else if ( major == MFMediaType_Stream ) fprintf ( stdout , \"stream \\n \" ); else fprintf ( stdout , \"unknown \\n \" ); UINT64 value = 0 ; media -> GetUINT64 ( MF_MT_FRAME_SIZE , & value ); UINT32 w = value >> 32 , h = value & UINT32_MAX ; media -> GetUINT64 ( MF_MT_FRAME_RATE_RANGE_MAX , & value ); UINT32 framerate = value >> 32 ; fprintf ( stdout , \" - width: %u \\n \" , w ); fprintf ( stdout , \" - height: %u \\n \" , h ); fprintf ( stdout , \" - fps: %u \\n \" , framerate ); GUID subtype {}; media -> GetGUID ( MF_MT_SUBTYPE , & subtype ); const char * name = \"Unknown\" ; if ( subtype == MFVideoFormat_RGB32 ) // 444 (32 bpp) name = \"D3DFMT_X8R8G8B8\" ; else if ( subtype == MFVideoFormat_ARGB32 ) name = \"D3DFMT_A8R8G8B8\" ; else if ( subtype == MFVideoFormat_RGB24 ) name = \"D3DFMT_R8G8B8\" ; else if ( subtype == MFVideoFormat_I420 ) // 420 (16 bpp) name = \"I420\" ; else if ( subtype == MFVideoFormat_NV12 ) // 420 (12 bpp) name = \"NV12\" ; else if ( subtype == MFVideoFormat_UYVY ) // 422 (12 bpp) name = \"UYVY\" ; else if ( subtype == MFVideoFormat_MJPG ) name = \"MJPG\" ; else if ( subtype == MFVideoFormat_AI44 ) // 4:4:4 Packed P name = \"AI44\" ; else if ( subtype == MFVideoFormat_AYUV ) // 4:4:4 Packed 8 name = \"AYUV\" ; else if ( subtype == MFVideoFormat_I420 ) // 4:2:0 Planar 8 name = \"I420\" ; else if ( subtype == MFVideoFormat_IYUV ) // 4:2:0 Planar 8 name = \"IYUV\" ; else if ( subtype == MFVideoFormat_NV11 ) // 4:1:1 Planar 8 name = \"NV11\" ; else if ( subtype == MFVideoFormat_NV12 ) // 4:2:0 Planar 8 name = \"NV12\" ; else if ( subtype == MFVideoFormat_UYVY ) // 4:2:2 Packed 8 name = \"UYVY\" ; else if ( subtype == MFVideoFormat_Y41P ) // 4:1:1 Packed 8 name = \"Y41P\" ; else if ( subtype == MFVideoFormat_Y41T ) // 4:1:1 Packed 8 name = \"Y41T\" ; else if ( subtype == MFVideoFormat_Y42T ) // 4:2:2 Packed 8 name = \"Y42T\" ; else if ( subtype == MFVideoFormat_YUY2 ) // 4:2:2 Packed 8 name = \"YUY2\" ; else if ( subtype == MFVideoFormat_YVU9 ) // 8:4:4 Planar 9 name = \"YVU9\" ; else if ( subtype == MFVideoFormat_YV12 ) // 4:2:0 Planar 8 name = \"YV12\" ; else if ( subtype == MFVideoFormat_YVYU ) // 4:2:2 Packed 8 name = \"YVYU\" ; fprintf ( stdout , \" - format: %s \\n \" , name ); }","title":"File media.cpp"},{"location":"media_8cpp_source/#file-mediacpp","text":"File List > src > media.cpp Go to the documentation of this file. #include <winrt/Windows.Foundation.h> #include \"media.hpp\" using namespace std ; using namespace Microsoft :: WRL ; struct critical_section_t final : public CRITICAL_SECTION { public : critical_section_t () noexcept : CRITICAL_SECTION {} { InitializeCriticalSection ( this ); } ~ critical_section_t () noexcept { DeleteCriticalSection ( this ); } bool try_lock () noexcept { return TryEnterCriticalSection ( this ); } void lock () noexcept { return EnterCriticalSection ( this ); } void unlock () noexcept { return LeaveCriticalSection ( this ); } }; auto startup () -> gsl :: final_action < HRESULT ( WINAPI * )() > { switch ( auto hr = CoInitializeEx ( NULL , COINIT_APARTMENTTHREADED )) { case CO_E_NOTINITIALIZED : throw _com_error { hr }; default : break ; } if ( MFStartup ( MF_VERSION ) != S_OK ) throw runtime_error { \"MFStartup\" }; return gsl :: finally ( & MFShutdown ); } HRESULT get_devices ( IMFAttributes * attrs , vector < ComPtr < IMFActivate >>& devices ) noexcept { IMFActivate ** handles = nullptr ; UINT32 count = 0 ; HRESULT hr = MFEnumDeviceSources ( attrs , & handles , & count ); if FAILED ( hr ) return hr ; auto on_return = gsl :: finally ([ handles ]() { CoTaskMemFree ( handles ); }); for ( auto i = 0u ; i < count ; ++ i ) devices . emplace_back ( move ( handles [ i ])); return S_OK ; } HRESULT get_name ( IMFActivate * device , wstring & name ) noexcept { constexpr UINT32 max_size = 255 ; WCHAR buf [ max_size ]{}; UINT32 buflen {}; HRESULT hr = device -> GetString ( MF_DEVSOURCE_ATTRIBUTE_FRIENDLY_NAME , buf , max_size , & buflen ); if ( SUCCEEDED ( hr )) name = { buf , buflen }; return hr ; } HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation , IMFStreamDescriptor ** ptr ) { DWORD num_stream = 0 ; if ( auto hr = presentation -> GetStreamDescriptorCount ( & num_stream ); SUCCEEDED ( hr ) == false ) return hr ; for ( auto i = 0u ; i < num_stream ; ++ i ) { BOOL selected = false ; if ( auto hr = presentation -> GetStreamDescriptorByIndex ( i , & selected , ptr ); FAILED ( hr )) { return hr ; } if ( selected ) break ; } return S_OK ; } void print ( IMFMediaType * media ) noexcept ; HRESULT configure ( ComPtr < IMFStreamDescriptor > stream ) noexcept { ComPtr < IMFMediaTypeHandler > handler {}; if ( auto hr = stream -> GetMediaTypeHandler ( handler . GetAddressOf ()); SUCCEEDED ( hr ) == false ) return hr ; DWORD num_types = 0 ; if ( auto hr = handler -> GetMediaTypeCount ( & num_types ); SUCCEEDED ( hr ) == false ) return hr ; ComPtr < IMFMediaType > type {}; for ( auto i = 0u ; i < num_types ; ++ i ) { ComPtr < IMFMediaType > current {}; if ( auto hr = handler -> GetMediaTypeByIndex ( i , current . GetAddressOf ()); FAILED ( hr )) return hr ; if ( type == nullptr ) type = current ; print ( current . Get ()); } GUID subtype {}; type -> GetGUID ( MF_MT_SUBTYPE , & subtype ); UINT32 interlace = 0 ; type -> GetUINT32 ( MF_MT_INTERLACE_MODE , & interlace ); const auto imode = static_cast < MFVideoInterlaceMode > ( interlace ); UINT32 stride = 0 ; type -> GetUINT32 ( MF_MT_DEFAULT_STRIDE , & stride ); UINT32 ycbcr2rgb = 0 ; type -> GetUINT32 ( MF_MT_YUV_MATRIX , & ycbcr2rgb ); const auto matrix = static_cast < MFVideoTransferMatrix > ( ycbcr2rgb ); UINT64 size = 0 ; type -> GetUINT64 ( MF_MT_FRAME_SIZE , & size ); // MFGetAttributeSize UINT32 w = size >> 32 , h = size & UINT32_MAX ; UINT64 framerate = 0 ; type -> GetUINT64 ( MF_MT_FRAME_RATE_RANGE_MAX , & framerate ); type -> SetUINT64 ( MF_MT_FRAME_RATE , framerate ); framerate = framerate >> 32 ; return handler -> SetCurrentMediaType ( type . Get ()); } device_group_t :: device_group_t () noexcept ( false ) { if ( auto hr = MFCreateAttributes ( attrs . GetAddressOf (), 1 ); // FAILED ( hr )) throw _com_error { hr }; if ( auto hr = attrs -> SetGUID ( MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE , // MF_DEVSOURCE_ATTRIBUTE_SOURCE_TYPE_VIDCAP_GUID ); FAILED ( hr )) throw _com_error { hr }; if ( auto hr = get_devices ( attrs . Get (), devices ); // FAILED ( hr )) throw _com_error { hr }; } void print ( IMFMediaType * media ) noexcept { GUID major {}; media -> GetGUID ( MF_MT_MAJOR_TYPE , & major ); if ( major == MFMediaType_Default ) fprintf ( stdout , \"default \\n \" ); else if ( major == MFMediaType_Video ) fprintf ( stdout , \"video \\n \" ); else if ( major == MFMediaType_Stream ) fprintf ( stdout , \"stream \\n \" ); else fprintf ( stdout , \"unknown \\n \" ); UINT64 value = 0 ; media -> GetUINT64 ( MF_MT_FRAME_SIZE , & value ); UINT32 w = value >> 32 , h = value & UINT32_MAX ; media -> GetUINT64 ( MF_MT_FRAME_RATE_RANGE_MAX , & value ); UINT32 framerate = value >> 32 ; fprintf ( stdout , \" - width: %u \\n \" , w ); fprintf ( stdout , \" - height: %u \\n \" , h ); fprintf ( stdout , \" - fps: %u \\n \" , framerate ); GUID subtype {}; media -> GetGUID ( MF_MT_SUBTYPE , & subtype ); const char * name = \"Unknown\" ; if ( subtype == MFVideoFormat_RGB32 ) // 444 (32 bpp) name = \"D3DFMT_X8R8G8B8\" ; else if ( subtype == MFVideoFormat_ARGB32 ) name = \"D3DFMT_A8R8G8B8\" ; else if ( subtype == MFVideoFormat_RGB24 ) name = \"D3DFMT_R8G8B8\" ; else if ( subtype == MFVideoFormat_I420 ) // 420 (16 bpp) name = \"I420\" ; else if ( subtype == MFVideoFormat_NV12 ) // 420 (12 bpp) name = \"NV12\" ; else if ( subtype == MFVideoFormat_UYVY ) // 422 (12 bpp) name = \"UYVY\" ; else if ( subtype == MFVideoFormat_MJPG ) name = \"MJPG\" ; else if ( subtype == MFVideoFormat_AI44 ) // 4:4:4 Packed P name = \"AI44\" ; else if ( subtype == MFVideoFormat_AYUV ) // 4:4:4 Packed 8 name = \"AYUV\" ; else if ( subtype == MFVideoFormat_I420 ) // 4:2:0 Planar 8 name = \"I420\" ; else if ( subtype == MFVideoFormat_IYUV ) // 4:2:0 Planar 8 name = \"IYUV\" ; else if ( subtype == MFVideoFormat_NV11 ) // 4:1:1 Planar 8 name = \"NV11\" ; else if ( subtype == MFVideoFormat_NV12 ) // 4:2:0 Planar 8 name = \"NV12\" ; else if ( subtype == MFVideoFormat_UYVY ) // 4:2:2 Packed 8 name = \"UYVY\" ; else if ( subtype == MFVideoFormat_Y41P ) // 4:1:1 Packed 8 name = \"Y41P\" ; else if ( subtype == MFVideoFormat_Y41T ) // 4:1:1 Packed 8 name = \"Y41T\" ; else if ( subtype == MFVideoFormat_Y42T ) // 4:2:2 Packed 8 name = \"Y42T\" ; else if ( subtype == MFVideoFormat_YUY2 ) // 4:2:2 Packed 8 name = \"YUY2\" ; else if ( subtype == MFVideoFormat_YVU9 ) // 8:4:4 Planar 9 name = \"YVU9\" ; else if ( subtype == MFVideoFormat_YV12 ) // 4:2:0 Planar 8 name = \"YV12\" ; else if ( subtype == MFVideoFormat_YVYU ) // 4:2:2 Packed 8 name = \"YVYU\" ; fprintf ( stdout , \" - format: %s \\n \" , name ); }","title":"File media.cpp"},{"location":"media_8hpp/","text":"File media.hpp \u00b6 File List > src > media.hpp Go to the source code of this file. #include <chrono> #include <ctime> #include <gsl/gsl> #include <comdef.h> #include <shlwapi.h> #include <wrl/client.h> #include <mfapi.h> #include <mfidl.h> #include <mfreadwrite.h> Classes \u00b6 Type Name class device_group_t class process_timer_t struct read_item_t Public Functions \u00b6 Type Name HRESULT configure (ComPtr< IMFStreamDescriptor > stream) noexcept HRESULT get_devices (IMFAttributes * attrs, std::vector< ComPtr< IMFActivate >> & devices) noexcept HRESULT get_name (IMFActivate * device, std::wstring & name) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) auto startup () Public Functions Documentation \u00b6 function configure \u00b6 HRESULT configure ( ComPtr < IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video function get_devices \u00b6 HRESULT get_devices ( IMFAttributes * attrs , std :: vector < ComPtr < IMFActivate >> & devices ) noexcept function get_name \u00b6 HRESULT get_name ( IMFActivate * device , std :: wstring & name ) noexcept function get_stream_descriptor \u00b6 HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation , IMFStreamDescriptor ** ptr ) function startup \u00b6 auto startup () The documentation for this class was generated from the following file src/media.hpp","title":"File media.hpp"},{"location":"media_8hpp/#file-mediahpp","text":"File List > src > media.hpp Go to the source code of this file. #include <chrono> #include <ctime> #include <gsl/gsl> #include <comdef.h> #include <shlwapi.h> #include <wrl/client.h> #include <mfapi.h> #include <mfidl.h> #include <mfreadwrite.h>","title":"File media.hpp"},{"location":"media_8hpp/#classes","text":"Type Name class device_group_t class process_timer_t struct read_item_t","title":"Classes"},{"location":"media_8hpp/#public-functions","text":"Type Name HRESULT configure (ComPtr< IMFStreamDescriptor > stream) noexcept HRESULT get_devices (IMFAttributes * attrs, std::vector< ComPtr< IMFActivate >> & devices) noexcept HRESULT get_name (IMFActivate * device, std::wstring & name) noexcept HRESULT get_stream_descriptor (IMFPresentationDescriptor * presentation, IMFStreamDescriptor ** ptr) auto startup ()","title":"Public Functions"},{"location":"media_8hpp/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"media_8hpp/#function-configure","text":"HRESULT configure ( ComPtr < IMFStreamDescriptor > stream ) noexcept See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-processor-mft See also: https://docs.microsoft.com/en-us/windows/win32/medfound/video-media-types See also: https://docs.microsoft.com/en-us/windows/win32/medfound/about-yuv-video","title":"function configure"},{"location":"media_8hpp/#function-get_devices","text":"HRESULT get_devices ( IMFAttributes * attrs , std :: vector < ComPtr < IMFActivate >> & devices ) noexcept","title":"function get_devices"},{"location":"media_8hpp/#function-get_name","text":"HRESULT get_name ( IMFActivate * device , std :: wstring & name ) noexcept","title":"function get_name"},{"location":"media_8hpp/#function-get_stream_descriptor","text":"HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation , IMFStreamDescriptor ** ptr )","title":"function get_stream_descriptor"},{"location":"media_8hpp/#function-startup","text":"auto startup () The documentation for this class was generated from the following file src/media.hpp","title":"function startup"},{"location":"media_8hpp_source/","text":"File media.hpp \u00b6 File List > src > media.hpp Go to the documentation of this file. #pragma once #include <chrono> #include <ctime> #include <gsl/gsl> #include <comdef.h> #include <shlwapi.h> #include <wrl/client.h> //#include <mferror.h> #include <mfapi.h> #include <mfidl.h> #include <mfreadwrite.h> using Microsoft :: WRL :: ComPtr ; auto startup () -> gsl :: final_action < HRESULT ( WINAPI * )() > ; HRESULT get_devices ( IMFAttributes * attrs , std :: vector < ComPtr < IMFActivate >>& devices ) noexcept ; HRESULT get_name ( IMFActivate * device , std :: wstring & name ) noexcept ; HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation , IMFStreamDescriptor ** ptr ); HRESULT configure ( ComPtr < IMFStreamDescriptor > stream ) noexcept ; class device_group_t final { public : ComPtr < IMFAttributes > attrs {}; std :: vector < ComPtr < IMFActivate >> devices {}; public : device_group_t () noexcept ( false ); }; struct read_item_t final { HRESULT status ; DWORD index ; DWORD flags ; std :: chrono :: nanoseconds timestamp ; // unit: 100 nanosecond ComPtr < IMFSample > sample ; }; static_assert ( sizeof ( read_item_t ) == 32 ); class process_timer_t final { clock_t start = clock (); public : float pick () const noexcept { const auto now = clock (); return static_cast < float > ( now - start ) / CLOCKS_PER_SEC ; } float reset () noexcept { const auto d = this -> pick (); start = clock (); return d ; } };","title":"File media.hpp"},{"location":"media_8hpp_source/#file-mediahpp","text":"File List > src > media.hpp Go to the documentation of this file. #pragma once #include <chrono> #include <ctime> #include <gsl/gsl> #include <comdef.h> #include <shlwapi.h> #include <wrl/client.h> //#include <mferror.h> #include <mfapi.h> #include <mfidl.h> #include <mfreadwrite.h> using Microsoft :: WRL :: ComPtr ; auto startup () -> gsl :: final_action < HRESULT ( WINAPI * )() > ; HRESULT get_devices ( IMFAttributes * attrs , std :: vector < ComPtr < IMFActivate >>& devices ) noexcept ; HRESULT get_name ( IMFActivate * device , std :: wstring & name ) noexcept ; HRESULT get_stream_descriptor ( IMFPresentationDescriptor * presentation , IMFStreamDescriptor ** ptr ); HRESULT configure ( ComPtr < IMFStreamDescriptor > stream ) noexcept ; class device_group_t final { public : ComPtr < IMFAttributes > attrs {}; std :: vector < ComPtr < IMFActivate >> devices {}; public : device_group_t () noexcept ( false ); }; struct read_item_t final { HRESULT status ; DWORD index ; DWORD flags ; std :: chrono :: nanoseconds timestamp ; // unit: 100 nanosecond ComPtr < IMFSample > sample ; }; static_assert ( sizeof ( read_item_t ) == 32 ); class process_timer_t final { clock_t start = clock (); public : float pick () const noexcept { const auto now = clock (); return static_cast < float > ( now - start ) / CLOCKS_PER_SEC ; } float reset () noexcept { const auto d = this -> pick (); start = clock (); return d ; } };","title":"File media.hpp"},{"location":"modules/","text":"Modules \u00b6 Here is a list of all modules:","title":"Modules"},{"location":"modules/#modules","text":"Here is a list of all modules:","title":"Modules"},{"location":"namespaceMicrosoft_1_1WRL/","text":"Namespace Microsoft::WRL \u00b6 Class List > WRL The documentation for this class was generated from the following file src/media.cpp","title":"Namespace Microsoft::WRL"},{"location":"namespaceMicrosoft_1_1WRL/#namespace-microsoftwrl","text":"Class List > WRL The documentation for this class was generated from the following file src/media.cpp","title":"Namespace Microsoft::WRL"},{"location":"namespace_member_enums/","text":"Namespace Member Enums \u00b6","title":"Namespace Member Enums"},{"location":"namespace_member_enums/#namespace-member-enums","text":"","title":"Namespace Member Enums"},{"location":"namespace_member_functions/","text":"Namespace Member Functions \u00b6","title":"Namespace Member Functions"},{"location":"namespace_member_functions/#namespace-member-functions","text":"","title":"Namespace Member Functions"},{"location":"namespace_member_typedefs/","text":"Namespace Member Typedefs \u00b6","title":"Namespace Member Typedefs"},{"location":"namespace_member_typedefs/#namespace-member-typedefs","text":"","title":"Namespace Member Typedefs"},{"location":"namespace_member_variables/","text":"Namespace Member Variables \u00b6","title":"Namespace Member Variables"},{"location":"namespace_member_variables/#namespace-member-variables","text":"","title":"Namespace Member Variables"},{"location":"namespace_members/","text":"Namespace Members \u00b6","title":"Namespace Members"},{"location":"namespace_members/#namespace-members","text":"","title":"Namespace Members"},{"location":"namespaces/","text":"Namespace List \u00b6 Here is a list of all namespaces with brief descriptions: namespace WRL namespace std","title":"Namespaces"},{"location":"namespaces/#namespace-list","text":"Here is a list of all namespaces with brief descriptions: namespace WRL namespace std","title":"Namespace List"},{"location":"namespacestd/","text":"Namespace std \u00b6 Class List > std The documentation for this class was generated from the following file src/media.cpp","title":"Namespace std"},{"location":"namespacestd/#namespace-std","text":"Class List > std The documentation for this class was generated from the following file src/media.cpp","title":"Namespace std"},{"location":"pages/","text":"Related Pages \u00b6 Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"pages/#related-pages","text":"Here is a list of all related documentation pages:","title":"Related Pages"},{"location":"structcritical__section__t/","text":"Struct critical_section_t \u00b6 Class List > critical_section_t Inherits the following classes: CRITICAL_SECTION Public Functions \u00b6 Type Name critical_section_t () noexcept void lock () noexcept bool try_lock () noexcept void unlock () noexcept ~critical_section_t () noexcept Public Functions Documentation \u00b6 function critical_section_t \u00b6 inline critical_section_t :: critical_section_t () noexcept function lock \u00b6 inline void critical_section_t :: lock () noexcept function try_lock \u00b6 inline bool critical_section_t :: try_lock () noexcept function unlock \u00b6 inline void critical_section_t :: unlock () noexcept function ~critical_section_t \u00b6 inline critical_section_t ::~ critical_section_t () noexcept The documentation for this class was generated from the following file src/media.cpp","title":"Struct critical\\_section\\_t"},{"location":"structcritical__section__t/#struct-critical_section_t","text":"Class List > critical_section_t Inherits the following classes: CRITICAL_SECTION","title":"Struct critical_section_t"},{"location":"structcritical__section__t/#public-functions","text":"Type Name critical_section_t () noexcept void lock () noexcept bool try_lock () noexcept void unlock () noexcept ~critical_section_t () noexcept","title":"Public Functions"},{"location":"structcritical__section__t/#public-functions-documentation","text":"","title":"Public Functions Documentation"},{"location":"structcritical__section__t/#function-critical_section_t","text":"inline critical_section_t :: critical_section_t () noexcept","title":"function critical_section_t"},{"location":"structcritical__section__t/#function-lock","text":"inline void critical_section_t :: lock () noexcept","title":"function lock"},{"location":"structcritical__section__t/#function-try_lock","text":"inline bool critical_section_t :: try_lock () noexcept","title":"function try_lock"},{"location":"structcritical__section__t/#function-unlock","text":"inline void critical_section_t :: unlock () noexcept","title":"function unlock"},{"location":"structcritical__section__t/#function-critical_section_t_1","text":"inline critical_section_t ::~ critical_section_t () noexcept The documentation for this class was generated from the following file src/media.cpp","title":"function ~critical_section_t"},{"location":"structread__item__t/","text":"Struct read_item_t \u00b6 Class List > read_item_t More... #include <media.hpp> Public Attributes \u00b6 Type Name DWORD flags DWORD index ComPtr< IMFSample > sample HRESULT status std::chrono::nanoseconds timestamp Detailed Description \u00b6 See also: OnReadSample Public Attributes Documentation \u00b6 variable flags \u00b6 DWORD read_item_t :: flags ; variable index \u00b6 DWORD read_item_t :: index ; variable sample \u00b6 ComPtr < IMFSample > read_item_t :: sample ; variable status \u00b6 HRESULT read_item_t :: status ; variable timestamp \u00b6 std :: chrono :: nanoseconds read_item_t :: timestamp ; The documentation for this class was generated from the following file src/media.hpp","title":"Struct read\\_item\\_t"},{"location":"structread__item__t/#struct-read_item_t","text":"Class List > read_item_t More... #include <media.hpp>","title":"Struct read_item_t"},{"location":"structread__item__t/#public-attributes","text":"Type Name DWORD flags DWORD index ComPtr< IMFSample > sample HRESULT status std::chrono::nanoseconds timestamp","title":"Public Attributes"},{"location":"structread__item__t/#detailed-description","text":"See also: OnReadSample","title":"Detailed Description"},{"location":"structread__item__t/#public-attributes-documentation","text":"","title":"Public Attributes Documentation"},{"location":"structread__item__t/#variable-flags","text":"DWORD read_item_t :: flags ;","title":"variable flags"},{"location":"structread__item__t/#variable-index","text":"DWORD read_item_t :: index ;","title":"variable index"},{"location":"structread__item__t/#variable-sample","text":"ComPtr < IMFSample > read_item_t :: sample ;","title":"variable sample"},{"location":"structread__item__t/#variable-status","text":"HRESULT read_item_t :: status ;","title":"variable status"},{"location":"structread__item__t/#variable-timestamp","text":"std :: chrono :: nanoseconds read_item_t :: timestamp ; The documentation for this class was generated from the following file src/media.hpp","title":"variable timestamp"},{"location":"variables/","text":"Variables \u00b6","title":"Variables"},{"location":"variables/#variables","text":"","title":"Variables"}]}